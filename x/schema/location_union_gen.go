// Code generated by mkunion. DO NOT EDIT.
package schema

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(LocationShape())
	shape.Register(LocationFieldShape())
	shape.Register(LocationIndexShape())
	shape.Register(LocationAnythingShape())
}

type LocationVisitor interface {
	VisitLocationField(v *LocationField) any
	VisitLocationIndex(v *LocationIndex) any
	VisitLocationAnything(v *LocationAnything) any
}

type Location interface {
	AcceptLocation(g LocationVisitor) any
}

var (
	_ Location = (*LocationField)(nil)
	_ Location = (*LocationIndex)(nil)
	_ Location = (*LocationAnything)(nil)
)

func (r *LocationField) AcceptLocation(v LocationVisitor) any    { return v.VisitLocationField(r) }
func (r *LocationIndex) AcceptLocation(v LocationVisitor) any    { return v.VisitLocationIndex(r) }
func (r *LocationAnything) AcceptLocation(v LocationVisitor) any { return v.VisitLocationAnything(r) }

func MatchLocationR3[T0, T1, T2 any](
	x Location,
	f1 func(x *LocationField) (T0, T1, T2),
	f2 func(x *LocationIndex) (T0, T1, T2),
	f3 func(x *LocationAnything) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *LocationField:
		return f1(v)
	case *LocationIndex:
		return f2(v)
	case *LocationAnything:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchLocationR2[T0, T1 any](
	x Location,
	f1 func(x *LocationField) (T0, T1),
	f2 func(x *LocationIndex) (T0, T1),
	f3 func(x *LocationAnything) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *LocationField:
		return f1(v)
	case *LocationIndex:
		return f2(v)
	case *LocationAnything:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchLocationR1[T0 any](
	x Location,
	f1 func(x *LocationField) T0,
	f2 func(x *LocationIndex) T0,
	f3 func(x *LocationAnything) T0,
) T0 {
	switch v := x.(type) {
	case *LocationField:
		return f1(v)
	case *LocationIndex:
		return f2(v)
	case *LocationAnything:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchLocationR0(
	x Location,
	f1 func(x *LocationField),
	f2 func(x *LocationIndex),
	f3 func(x *LocationAnything),
) {
	switch v := x.(type) {
	case *LocationField:
		f1(v)
	case *LocationIndex:
		f2(v)
	case *LocationAnything:
		f3(v)
	}
}

func LocationShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Location",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		Variant: []shape.Shape{
			LocationFieldShape(),
			LocationIndexShape(),
			LocationAnythingShape(),
		},
	}
}

func LocationFieldShape() shape.Shape {
	return &shape.StructLike{
		Name:          "LocationField",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		Fields: []*shape.FieldLike{
			{
				Name: "Name",
				Type: &shape.PrimitiveLike{Kind: &shape.StringLike{}},
			},
		},
	}
}

func LocationIndexShape() shape.Shape {
	return &shape.StructLike{
		Name:          "LocationIndex",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
		Fields: []*shape.FieldLike{
			{
				Name: "Index",
				Type: &shape.PrimitiveLike{
					Kind: &shape.NumberLike{
						Kind: &shape.Int{},
					},
				},
			},
		},
	}
}

func LocationAnythingShape() shape.Shape {
	return &shape.StructLike{
		Name:          "LocationAnything",
		PkgName:       "schema",
		PkgImportName: "github.com/widmogrod/mkunion/x/schema",
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.Location", LocationFromJSON, LocationToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.LocationField", LocationFieldFromJSON, LocationFieldToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.LocationIndex", LocationIndexFromJSON, LocationIndexToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/schema.LocationAnything", LocationAnythingFromJSON, LocationAnythingToJSON)
}

type LocationUnionJSON struct {
	Type             string          `json:"$type,omitempty"`
	LocationField    json.RawMessage `json:"schema.LocationField,omitempty"`
	LocationIndex    json.RawMessage `json:"schema.LocationIndex,omitempty"`
	LocationAnything json.RawMessage `json:"schema.LocationAnything,omitempty"`
}

func LocationFromJSON(x []byte) (Location, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data LocationUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "schema.LocationField":
		return LocationFieldFromJSON(data.LocationField)
	case "schema.LocationIndex":
		return LocationIndexFromJSON(data.LocationIndex)
	case "schema.LocationAnything":
		return LocationAnythingFromJSON(data.LocationAnything)
	}

	if data.LocationField != nil {
		return LocationFieldFromJSON(data.LocationField)
	} else if data.LocationIndex != nil {
		return LocationIndexFromJSON(data.LocationIndex)
	} else if data.LocationAnything != nil {
		return LocationAnythingFromJSON(data.LocationAnything)
	}

	return nil, fmt.Errorf("schema.Location: unknown type %s", data.Type)
}

func LocationToJSON(x Location) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MatchLocationR2(
		x,
		func(x *LocationField) ([]byte, error) {
			body, err := LocationFieldToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(LocationUnionJSON{
				Type:          "schema.LocationField",
				LocationField: body,
			})
		},
		func(x *LocationIndex) ([]byte, error) {
			body, err := LocationIndexToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(LocationUnionJSON{
				Type:          "schema.LocationIndex",
				LocationIndex: body,
			})
		},
		func(x *LocationAnything) ([]byte, error) {
			body, err := LocationAnythingToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(LocationUnionJSON{
				Type:             "schema.LocationAnything",
				LocationAnything: body,
			})
		},
	)
}

func LocationFieldFromJSON(x []byte) (*LocationField, error) {
	result := new(LocationField)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LocationFieldToJSON(x *LocationField) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*LocationField)(nil)
	_ json.Marshaler   = (*LocationField)(nil)
)

func (r *LocationField) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONLocationField(*r)
}
func (r *LocationField) _marshalJSONLocationField(x LocationField) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldName []byte
	fieldName, err = r._marshalJSONstring(x.Name)
	if err != nil {
		return nil, fmt.Errorf("schema: LocationField._marshalJSONLocationField: field name Name; %w", err)
	}
	partial["Name"] = fieldName
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("schema: LocationField._marshalJSONLocationField: struct; %w", err)
	}
	return result, nil
}
func (r *LocationField) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("schema: LocationField._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *LocationField) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONLocationField(data)
	if err != nil {
		return fmt.Errorf("schema: LocationField.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *LocationField) _unmarshalJSONLocationField(data []byte) (LocationField, error) {
	result := LocationField{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("schema: LocationField._unmarshalJSONLocationField: native struct unwrap; %w", err)
	}
	if fieldName, ok := partial["Name"]; ok {
		result.Name, err = r._unmarshalJSONstring(fieldName)
		if err != nil {
			return result, fmt.Errorf("schema: LocationField._unmarshalJSONLocationField: field Name; %w", err)
		}
	}
	return result, nil
}
func (r *LocationField) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("schema: LocationField._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func LocationIndexFromJSON(x []byte) (*LocationIndex, error) {
	result := new(LocationIndex)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LocationIndexToJSON(x *LocationIndex) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*LocationIndex)(nil)
	_ json.Marshaler   = (*LocationIndex)(nil)
)

func (r *LocationIndex) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONLocationIndex(*r)
}
func (r *LocationIndex) _marshalJSONLocationIndex(x LocationIndex) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldIndex []byte
	fieldIndex, err = r._marshalJSONint(x.Index)
	if err != nil {
		return nil, fmt.Errorf("schema: LocationIndex._marshalJSONLocationIndex: field name Index; %w", err)
	}
	partial["Index"] = fieldIndex
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("schema: LocationIndex._marshalJSONLocationIndex: struct; %w", err)
	}
	return result, nil
}
func (r *LocationIndex) _marshalJSONint(x int) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("schema: LocationIndex._marshalJSONint:; %w", err)
	}
	return result, nil
}
func (r *LocationIndex) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONLocationIndex(data)
	if err != nil {
		return fmt.Errorf("schema: LocationIndex.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *LocationIndex) _unmarshalJSONLocationIndex(data []byte) (LocationIndex, error) {
	result := LocationIndex{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("schema: LocationIndex._unmarshalJSONLocationIndex: native struct unwrap; %w", err)
	}
	if fieldIndex, ok := partial["Index"]; ok {
		result.Index, err = r._unmarshalJSONint(fieldIndex)
		if err != nil {
			return result, fmt.Errorf("schema: LocationIndex._unmarshalJSONLocationIndex: field Index; %w", err)
		}
	}
	return result, nil
}
func (r *LocationIndex) _unmarshalJSONint(data []byte) (int, error) {
	var result int
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("schema: LocationIndex._unmarshalJSONint: native primitive unwrap; %w", err)
	}
	return result, nil
}

func LocationAnythingFromJSON(x []byte) (*LocationAnything, error) {
	result := new(LocationAnything)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func LocationAnythingToJSON(x *LocationAnything) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*LocationAnything)(nil)
	_ json.Marshaler   = (*LocationAnything)(nil)
)

func (r *LocationAnything) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONLocationAnything(*r)
}
func (r *LocationAnything) _marshalJSONLocationAnything(x LocationAnything) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("schema: LocationAnything._marshalJSONLocationAnything: struct; %w", err)
	}
	return result, nil
}
func (r *LocationAnything) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONLocationAnything(data)
	if err != nil {
		return fmt.Errorf("schema: LocationAnything.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *LocationAnything) _unmarshalJSONLocationAnything(data []byte) (LocationAnything, error) {
	result := LocationAnything{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("schema: LocationAnything._unmarshalJSONLocationAnything: native struct unwrap; %w", err)
	}
	return result, nil
}
