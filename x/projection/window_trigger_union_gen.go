// Code generated by mkunion. DO NOT EDIT.
package projection

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type TriggerDescriptionVisitor interface {
	VisitAtWatermark(v *AtWatermark) any
}

type TriggerDescription interface {
	AcceptTriggerDescription(g TriggerDescriptionVisitor) any
}

var (
	_ TriggerDescription = (*AtWatermark)(nil)
)

func (r *AtWatermark) AcceptTriggerDescription(v TriggerDescriptionVisitor) any {
	return v.VisitAtWatermark(r)
}

func MatchTriggerDescriptionR3[T0, T1, T2 any](
	x TriggerDescription,
	f1 func(x *AtWatermark) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *AtWatermark:
		return f1(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchTriggerDescriptionR2[T0, T1 any](
	x TriggerDescription,
	f1 func(x *AtWatermark) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *AtWatermark:
		return f1(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchTriggerDescriptionR1[T0 any](
	x TriggerDescription,
	f1 func(x *AtWatermark) T0,
) T0 {
	switch v := x.(type) {
	case *AtWatermark:
		return f1(v)
	}
	var result1 T0
	return result1
}

func MatchTriggerDescriptionR0(
	x TriggerDescription,
	f1 func(x *AtWatermark),
) {
	switch v := x.(type) {
	case *AtWatermark:
		f1(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/projection.TriggerDescription", TriggerDescriptionFromJSON, TriggerDescriptionToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/projection.AtWatermark", AtWatermarkFromJSON, AtWatermarkToJSON)
}

type TriggerDescriptionUnionJSON struct {
	Type        string          `json:"$type,omitempty"`
	AtWatermark json.RawMessage `json:"projection.AtWatermark,omitempty"`
}

func TriggerDescriptionFromJSON(x []byte) (TriggerDescription, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data TriggerDescriptionUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "projection.AtWatermark":
		return AtWatermarkFromJSON(data.AtWatermark)
	}

	if data.AtWatermark != nil {
		return AtWatermarkFromJSON(data.AtWatermark)
	}

	return nil, fmt.Errorf("projection.TriggerDescription: unknown type %s", data.Type)
}

func TriggerDescriptionToJSON(x TriggerDescription) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MatchTriggerDescriptionR2(
		x,
		func(x *AtWatermark) ([]byte, error) {
			body, err := AtWatermarkToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerDescriptionUnionJSON{
				Type:        "projection.AtWatermark",
				AtWatermark: body,
			})
		},
	)
}

func AtWatermarkFromJSON(x []byte) (*AtWatermark, error) {
	result := new(AtWatermark)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AtWatermarkToJSON(x *AtWatermark) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AtWatermark)(nil)
	_ json.Marshaler   = (*AtWatermark)(nil)
)

func (r *AtWatermark) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAtWatermark(*r)
}
func (r *AtWatermark) _marshalJSONAtWatermark(x AtWatermark) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AtWatermark._marshalJSONAtWatermark: struct; %w", err)
	}
	return result, nil
}
func (r *AtWatermark) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAtWatermark(data)
	if err != nil {
		return fmt.Errorf("projection: AtWatermark.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AtWatermark) _unmarshalJSONAtWatermark(data []byte) (AtWatermark, error) {
	result := AtWatermark{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AtWatermark._unmarshalJSONAtWatermark: native struct unwrap; %w", err)
	}
	return result, nil
}
