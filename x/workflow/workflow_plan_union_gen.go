// Code generated by mkunion. DO NOT EDIT.
package workflow

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type PlanStepVisitor interface {
	VisitExecuteStep(v *ExecuteStep) any
	VisitAssignStep(v *AssignStep) any
	VisitReturnStep(v *ReturnStep) any
}

type PlanStep interface {
	AcceptPlanStep(g PlanStepVisitor) any
}

var (
	_ PlanStep = (*ExecuteStep)(nil)
	_ PlanStep = (*AssignStep)(nil)
	_ PlanStep = (*ReturnStep)(nil)
)

func (r *ExecuteStep) AcceptPlanStep(v PlanStepVisitor) any { return v.VisitExecuteStep(r) }
func (r *AssignStep) AcceptPlanStep(v PlanStepVisitor) any { return v.VisitAssignStep(r) }
func (r *ReturnStep) AcceptPlanStep(v PlanStepVisitor) any { return v.VisitReturnStep(r) }

func MatchPlanStepR3[T0, T1, T2 any](
	x PlanStep,
	f1 func(x *ExecuteStep) (T0, T1, T2),
	f2 func(x *AssignStep) (T0, T1, T2),
	f3 func(x *ReturnStep) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *ExecuteStep:
		return f1(v)
	case *AssignStep:
		return f2(v)
	case *ReturnStep:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchPlanStepR2[T0, T1 any](
	x PlanStep,
	f1 func(x *ExecuteStep) (T0, T1),
	f2 func(x *AssignStep) (T0, T1),
	f3 func(x *ReturnStep) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *ExecuteStep:
		return f1(v)
	case *AssignStep:
		return f2(v)
	case *ReturnStep:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchPlanStepR1[T0 any](
	x PlanStep,
	f1 func(x *ExecuteStep) T0,
	f2 func(x *AssignStep) T0,
	f3 func(x *ReturnStep) T0,
) T0 {
	switch v := x.(type) {
	case *ExecuteStep:
		return f1(v)
	case *AssignStep:
		return f2(v)
	case *ReturnStep:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchPlanStepR0(
	x PlanStep,
	f1 func(x *ExecuteStep),
	f2 func(x *AssignStep),
	f3 func(x *ReturnStep),
) {
	switch v := x.(type) {
	case *ExecuteStep:
		f1(v)
	case *AssignStep:
		f2(v)
	case *ReturnStep:
		f3(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.AssignStep", AssignStepFromJSON, AssignStepToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ExecuteStep", ExecuteStepFromJSON, ExecuteStepToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.PlanStep", PlanStepFromJSON, PlanStepToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/workflow.ReturnStep", ReturnStepFromJSON, ReturnStepToJSON)
}

type PlanStepUnionJSON struct {
	Type string `json:"$type,omitempty"`
	ExecuteStep json.RawMessage `json:"workflow.ExecuteStep,omitempty"`
	AssignStep json.RawMessage `json:"workflow.AssignStep,omitempty"`
	ReturnStep json.RawMessage `json:"workflow.ReturnStep,omitempty"`
}

func PlanStepFromJSON(x []byte) (PlanStep, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data PlanStepUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("workflow.PlanStepFromJSON: %w", err)
	}

	switch data.Type {
	case "workflow.ExecuteStep":
		return ExecuteStepFromJSON(data.ExecuteStep)
	case "workflow.AssignStep":
		return AssignStepFromJSON(data.AssignStep)
	case "workflow.ReturnStep":
		return ReturnStepFromJSON(data.ReturnStep)
	}

	if data.ExecuteStep != nil {
		return ExecuteStepFromJSON(data.ExecuteStep)
	} else if data.AssignStep != nil {
		return AssignStepFromJSON(data.AssignStep)
	} else if data.ReturnStep != nil {
		return ReturnStepFromJSON(data.ReturnStep)
	}
	return nil, fmt.Errorf("workflow.PlanStepFromJSON: unknown type: %s", data.Type)
}

func PlanStepToJSON(x PlanStep) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchPlanStepR2(
		x,
		func (y *ExecuteStep) ([]byte, error) {
			body, err := ExecuteStepToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.PlanStepToJSON: %w", err)
			}
			return json.Marshal(PlanStepUnionJSON{
				Type: "workflow.ExecuteStep",
				ExecuteStep: body,
			})
		},
		func (y *AssignStep) ([]byte, error) {
			body, err := AssignStepToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.PlanStepToJSON: %w", err)
			}
			return json.Marshal(PlanStepUnionJSON{
				Type: "workflow.AssignStep",
				AssignStep: body,
			})
		},
		func (y *ReturnStep) ([]byte, error) {
			body, err := ReturnStepToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("workflow.PlanStepToJSON: %w", err)
			}
			return json.Marshal(PlanStepUnionJSON{
				Type: "workflow.ReturnStep",
				ReturnStep: body,
			})
		},
	)
}

func ExecuteStepFromJSON(x []byte) (*ExecuteStep, error) {
	result := new(ExecuteStep)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ExecuteStepFromJSON: %w", err)
	}
	return result, nil
}

func ExecuteStepToJSON(x *ExecuteStep) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ExecuteStep)(nil)
	_ json.Marshaler   = (*ExecuteStep)(nil)
)

func (r *ExecuteStep) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONExecuteStep(*r)
}
func (r *ExecuteStep) _marshalJSONExecuteStep(x ExecuteStep) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldStepID []byte
	fieldStepID, err = r._marshalJSONstring(x.StepID)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONExecuteStep: field name StepID; %w", err)
	}
	partial["StepID"] = fieldStepID
	var fieldExpr []byte
	fieldExpr, err = r._marshalJSONExpr(x.Expr)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONExecuteStep: field name Expr; %w", err)
	}
	partial["Expr"] = fieldExpr
	var fieldDependsOn []byte
	fieldDependsOn, err = r._marshalJSONSlicestring(x.DependsOn)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONExecuteStep: field name DependsOn; %w", err)
	}
	partial["DependsOn"] = fieldDependsOn
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONExecuteStep: struct; %w", err)
	}
	return result, nil
}
func (r *ExecuteStep) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *ExecuteStep) _marshalJSONExpr(x Expr) ([]byte, error) {
	result, err := shared.JSONMarshal[Expr](x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONExpr:; %w", err)
	}
	return result, nil
}
func (r *ExecuteStep) _marshalJSONSlicestring(x []string) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONstring(v)
		if err != nil {
			return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONSlicestring: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ExecuteStep._marshalJSONSlicestring:; %w", err)
	}
	return result, nil
}
func (r *ExecuteStep) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONExecuteStep(data)
	if err != nil {
		return fmt.Errorf("workflow: ExecuteStep.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ExecuteStep) _unmarshalJSONExecuteStep(data []byte) (ExecuteStep, error) {
	result := ExecuteStep{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONExecuteStep: native struct unwrap; %w", err)
	}
	if fieldStepID, ok := partial["StepID"]; ok {
		result.StepID, err = r._unmarshalJSONstring(fieldStepID)
		if err != nil {
			return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONExecuteStep: field StepID; %w", err)
		}
	}
	if fieldExpr, ok := partial["Expr"]; ok {
		result.Expr, err = r._unmarshalJSONExpr(fieldExpr)
		if err != nil {
			return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONExecuteStep: field Expr; %w", err)
		}
	}
	if fieldDependsOn, ok := partial["DependsOn"]; ok {
		result.DependsOn, err = r._unmarshalJSONSlicestring(fieldDependsOn)
		if err != nil {
			return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONExecuteStep: field DependsOn; %w", err)
		}
	}
	return result, nil
}
func (r *ExecuteStep) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *ExecuteStep) _unmarshalJSONExpr(data []byte) (Expr, error) {
	result, err := shared.JSONUnmarshal[Expr](data)
	if err != nil {
		return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONExpr: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *ExecuteStep) _unmarshalJSONSlicestring(data []byte) ([]string, error) {
	result := make([]string, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONSlicestring: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONstring(v)
		if err != nil {
			return result, fmt.Errorf("workflow: ExecuteStep._unmarshalJSONSlicestring: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}

func AssignStepFromJSON(x []byte) (*AssignStep, error) {
	result := new(AssignStep)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.AssignStepFromJSON: %w", err)
	}
	return result, nil
}

func AssignStepToJSON(x *AssignStep) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AssignStep)(nil)
	_ json.Marshaler   = (*AssignStep)(nil)
)

func (r *AssignStep) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAssignStep(*r)
}
func (r *AssignStep) _marshalJSONAssignStep(x AssignStep) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldStepID []byte
	fieldStepID, err = r._marshalJSONstring(x.StepID)
	if err != nil {
		return nil, fmt.Errorf("workflow: AssignStep._marshalJSONAssignStep: field name StepID; %w", err)
	}
	partial["StepID"] = fieldStepID
	var fieldVarName []byte
	fieldVarName, err = r._marshalJSONstring(x.VarName)
	if err != nil {
		return nil, fmt.Errorf("workflow: AssignStep._marshalJSONAssignStep: field name VarName; %w", err)
	}
	partial["VarName"] = fieldVarName
	var fieldFromStep []byte
	fieldFromStep, err = r._marshalJSONstring(x.FromStep)
	if err != nil {
		return nil, fmt.Errorf("workflow: AssignStep._marshalJSONAssignStep: field name FromStep; %w", err)
	}
	partial["FromStep"] = fieldFromStep
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: AssignStep._marshalJSONAssignStep: struct; %w", err)
	}
	return result, nil
}
func (r *AssignStep) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: AssignStep._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *AssignStep) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAssignStep(data)
	if err != nil {
		return fmt.Errorf("workflow: AssignStep.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AssignStep) _unmarshalJSONAssignStep(data []byte) (AssignStep, error) {
	result := AssignStep{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: AssignStep._unmarshalJSONAssignStep: native struct unwrap; %w", err)
	}
	if fieldStepID, ok := partial["StepID"]; ok {
		result.StepID, err = r._unmarshalJSONstring(fieldStepID)
		if err != nil {
			return result, fmt.Errorf("workflow: AssignStep._unmarshalJSONAssignStep: field StepID; %w", err)
		}
	}
	if fieldVarName, ok := partial["VarName"]; ok {
		result.VarName, err = r._unmarshalJSONstring(fieldVarName)
		if err != nil {
			return result, fmt.Errorf("workflow: AssignStep._unmarshalJSONAssignStep: field VarName; %w", err)
		}
	}
	if fieldFromStep, ok := partial["FromStep"]; ok {
		result.FromStep, err = r._unmarshalJSONstring(fieldFromStep)
		if err != nil {
			return result, fmt.Errorf("workflow: AssignStep._unmarshalJSONAssignStep: field FromStep; %w", err)
		}
	}
	return result, nil
}
func (r *AssignStep) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: AssignStep._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func ReturnStepFromJSON(x []byte) (*ReturnStep, error) {
	result := new(ReturnStep)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("workflow.ReturnStepFromJSON: %w", err)
	}
	return result, nil
}

func ReturnStepToJSON(x *ReturnStep) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ReturnStep)(nil)
	_ json.Marshaler   = (*ReturnStep)(nil)
)

func (r *ReturnStep) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONReturnStep(*r)
}
func (r *ReturnStep) _marshalJSONReturnStep(x ReturnStep) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldStepID []byte
	fieldStepID, err = r._marshalJSONstring(x.StepID)
	if err != nil {
		return nil, fmt.Errorf("workflow: ReturnStep._marshalJSONReturnStep: field name StepID; %w", err)
	}
	partial["StepID"] = fieldStepID
	var fieldFromStep []byte
	fieldFromStep, err = r._marshalJSONstring(x.FromStep)
	if err != nil {
		return nil, fmt.Errorf("workflow: ReturnStep._marshalJSONReturnStep: field name FromStep; %w", err)
	}
	partial["FromStep"] = fieldFromStep
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("workflow: ReturnStep._marshalJSONReturnStep: struct; %w", err)
	}
	return result, nil
}
func (r *ReturnStep) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("workflow: ReturnStep._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *ReturnStep) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONReturnStep(data)
	if err != nil {
		return fmt.Errorf("workflow: ReturnStep.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ReturnStep) _unmarshalJSONReturnStep(data []byte) (ReturnStep, error) {
	result := ReturnStep{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("workflow: ReturnStep._unmarshalJSONReturnStep: native struct unwrap; %w", err)
	}
	if fieldStepID, ok := partial["StepID"]; ok {
		result.StepID, err = r._unmarshalJSONstring(fieldStepID)
		if err != nil {
			return result, fmt.Errorf("workflow: ReturnStep._unmarshalJSONReturnStep: field StepID; %w", err)
		}
	}
	if fieldFromStep, ok := partial["FromStep"]; ok {
		result.FromStep, err = r._unmarshalJSONstring(fieldFromStep)
		if err != nil {
			return result, fmt.Errorf("workflow: ReturnStep._unmarshalJSONReturnStep: field FromStep; %w", err)
		}
	}
	return result, nil
}
func (r *ReturnStep) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("workflow: ReturnStep._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

