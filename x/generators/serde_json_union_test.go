package generators

import (
	"bytes"
	"fmt"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/widmogrod/mkunion/x/shape"
	"os"
	"sort"
	"testing"

	_ "github.com/widmogrod/mkunion/x/generators/testutils"
)

func TestSerdeJSONUnion_Generate_Tree(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	inferred, err := shape.InferFromFile("testutils/tree.go")
	assert.NoError(t, err)

	g := NewSerdeJSONUnion(inferred.RetrieveUnion("Tree"))

	result, err := g.Generate()
	assert.NoError(t, err)

	reference, err := os.ReadFile("serde_json_union_test.go.asset")
	assert.NoError(t, err)
	assert.Equal(t, string(reference), string(result))
}

func TestSerdeJSONUnion_Generate_Forest(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	inferred, err := shape.InferFromFile("testutils/tree.go")
	assert.NoError(t, err)

	g := NewSerdeJSONUnion(inferred.RetrieveUnion("Forest"))

	result, err := g.Generate()
	assert.NoError(t, err)

	reference, err := os.ReadFile("serde_json_union_alias_test.go.asset")
	assert.NoError(t, err)
	assert.Equal(t, string(reference), string(result))
}

func TestSerdeJSONUnion_Generate_Generic(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	inferred, err := shape.InferFromFile("testutils/generic.go")
	assert.NoError(t, err)

	g := NewSerdeJSONUnion(inferred.RetrieveUnion("Record"))

	result, err := g.Generate()
	assert.NoError(t, err)

	reference, err := os.ReadFile("serde_json_union_generic_test.go.asset")
	assert.NoError(t, err)
	assert.Equal(t, string(reference), string(result))
}

func TestStrRegisterUnionFuncName(t *testing.T) {
	contents := `package testutils

import (
	"github.com/widmogrod/mkunion/f"
	. "github.com/widmogrod/mkunion/f"
)

var v0 Generic[f.Result[int, error]] = &testutils.Never[f.Result[int, error]]{}
var v1 Generic[Result[float64, error]] = &testutils.Never[Result[float64, error]]{}
var v2 f.Result[Generic[bool], error] = &f.Result[*testutils.Never[bool], error]{}
var v3 Result[Generic[string], error] = &f.Result[*testutils.Ever[string], error]{}

//go:tag mkunion:"Generic[A]"
type (
	Never[A any] struct{}
	Ever[A any]  struct{ Value A }
)
`

	pkgName := "github.com/widmogrod/mkunion/x/generators/testutils"

	inferred, err := shape.InferFromFileWithContentBody(contents, pkgName)
	//inferred, err := shape.InferFromFile("testutils/tree.go")
	require.NoError(t, err)

	union := inferred.RetrieveUnion("Generic")
	assert.NotNil(t, union)
	t.Log(shape.ToStr(union))

	st := NewShapeTagged(union)
	result, err := st.Generate()
	assert.NoError(t, err)

	t.Log(result)

	//g := NewSerdeJSONUnion(union)
	//result2, err2 := g.Generate()
	//assert.NoError(t, err2)
	//
	//t.Log(string(result2))

	// Used to generate type registry
	walker := shape.NewIndexedTypeWalkerWithContentBody(contents,
		func(x *shape.IndexedTypeWalker) {
			x.SetPkgImportName(pkgName)
		},
	)
	t.Log("expanded...")
	for _, s := range walker.IndexedShapes() {
		found := false
		if ref, ok := s.(*shape.RefName); ok {
			for _, sh := range inferred.RetrieveShapes() {
				if shape.Name(sh) == ref.Name &&
					shape.PkgName(sh) == ref.PkgName {
					s = sh
					found = true
					break
				}
			}
			if !found {
				s, found = shape.LookupShapeOnDisk(ref)
			}
			if found {
				s = shape.IndexWith(s, ref)
			}
		}
		//switch ss := s.(type) {
		//case *shape.UnionLike:
		g2 := NewShapeTagged(s)
		str, err := g2.generateShapeFunc(s)
		t.Log(str)
		t.Log(err)
		//resultg, _ := g2.Generate()
		//require.NoError(t, errg)
		//t.Log(string(resultg))
		//default:
		//t.Log(shape.ToStr(s))
		//}
	}

	buff, err3 := GenerateTypeRegistry(walker, inferred)
	assert.NoError(t, err3)
	t.Log(string(buff.Bytes()))
}

func GenerateTypeRegistry(inferred *shape.IndexedTypeWalker, infshapes *shape.InferredInfo) (bytes.Buffer, error) {
	packageName := inferred.PackageName()

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	found := inferred.ExpandedShapes()
	if len(found) == 0 {
		return contents, nil
	}

	sortedKeys := make([]string, 0, len(found))
	for k := range found {
		sortedKeys = append(sortedKeys, k)
	}

	sort.Strings(sortedKeys)

	maps := []PkgMap{
		{
			"shared": "github.com/widmogrod/mkunion/x/shared",
		},
	}
	for _, key := range sortedKeys {
		inst := found[key]
		next := shape.ExtractPkgImportNamesForTypeInitialisation(inst)
		maps = append(maps, next)
	}
	pkgMap := MergePkgMaps(maps...)
	delete(pkgMap, packageName)

	contents.WriteString(GenerateImports(pkgMap))

	contents.WriteString("func init() {\n")
	// generate type registry

	for _, key := range sortedKeys {
		inst := found[key]
		instantiatedTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithRootPackage(packageName),
		)
		fullTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithPkgImportName(),
		)

		// Register go type
		if packageName == "shared" {
			contents.WriteString(fmt.Sprintf("\tTypeRegistryStore[%s](%q)\n", instantiatedTypeName, fullTypeName))
		} else {
			contents.WriteString(fmt.Sprintf("\tshared.TypeRegistryStore[%s](%q)\n", instantiatedTypeName, fullTypeName))
		}

		// Try to register type JSON marshaller
		if ref, ok := inst.(*shape.RefName); ok {
			var some shape.Shape
			var found bool
			for _, sh := range infshapes.RetrieveShapes() {
				if shape.Name(sh) == ref.Name &&
					shape.PkgName(sh) == ref.PkgName {
					some = sh
					found = true
					break
				}
			}
			if !found {
				some, found = shape.LookupShapeOnDisk(ref)
				if !found {
					continue
				}
			}
			some = shape.IndexWith(some, ref)
			if shape.IsUnion(some) {
				contents.WriteString(fmt.Sprintf("\t%s\n", StrRegisterUnionFuncName(packageName, some)))
			}
		}
	}

	contents.WriteString("}\n")

	return contents, nil
}
