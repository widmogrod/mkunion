package generators

import (
	"bytes"
	"fmt"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/widmogrod/mkunion/x/shape"
	"os"
	"sort"
	"testing"

	_ "github.com/widmogrod/mkunion/x/generators/testutils"
)

func TestSerdeJSONUnion_Generate_Tree(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	inferred, err := shape.InferFromFile("testutils/tree.go")
	assert.NoError(t, err)

	g := NewSerdeJSONUnion(inferred.RetrieveUnion("Tree"))

	result, err := g.Generate()
	assert.NoError(t, err)

	reference, err := os.ReadFile("serde_json_union_test.go.asset")
	assert.NoError(t, err)
	assert.Equal(t, string(reference), string(result))
}

func TestSerdeJSONUnion_Generate_Forest(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	inferred, err := shape.InferFromFile("testutils/tree.go")
	assert.NoError(t, err)

	g := NewSerdeJSONUnion(inferred.RetrieveUnion("Forest"))

	result, err := g.Generate()
	assert.NoError(t, err)

	reference, err := os.ReadFile("serde_json_union_alias_test.go.asset")
	assert.NoError(t, err)
	assert.Equal(t, string(reference), string(result))
}

func TestSerdeJSONUnion_Generate_Generic(t *testing.T) {
	log.SetLevel(log.DebugLevel)
	inferred, err := shape.InferFromFile("testutils/generic.go")
	assert.NoError(t, err)

	g := NewSerdeJSONUnion(inferred.RetrieveUnion("Record"))

	result, err := g.Generate()
	assert.NoError(t, err)

	reference, err := os.ReadFile("serde_json_union_generic_test.go.asset")
	assert.NoError(t, err)
	assert.Equal(t, string(reference), string(result))
}

func TestStrRegisterUnionFuncName(t *testing.T) {
	log.SetLevel(log.ErrorLevel)
	contents := `package testutils

import (
	. "github.com/widmogrod/mkunion/f"
)

type User struct{ Name string }

type APIError struct {
	Code    int
	Message string
}

// --8<-- [start:fetch-type]

// FetchResult combine unions for rich error handling
type FetchResult = Result[Option[User], APIError]


// handleFetch uses nested pattern matching to handle result
func handleFetch(result FetchResult) string {
	return MatchResultR1(result,
		func(ok *Ok[Option[User], APIError]) string {
			return MatchOptionR1(ok.Value,
				func(*None[User]) string { return "User not found" },
				func(some *Some[User]) string {
					return fmt.Sprintf("Found user: %s", some.Value.Name)
				},
			)
		},
		func(err *Err[Option[User], APIError]) string {
			return fmt.Sprintf("API error: %v", err.Error)
		},
	)
}
`

	pkgName := "github.com/widmogrod/mkunion/x/generators/testutils"

	inferred, err := shape.InferFromFileWithContentBody(contents, pkgName)
	//inferred, err := shape.InferFromFile("testutils/tree.go")
	require.NoError(t, err)

	//union := inferred.RetrieveUnion("Generic")
	//assert.NotNil(t, union)
	//t.Log(shape.ToStr(union))
	//
	//st := NewShapeTagged(union)
	//result, err := st.Generate()
	//assert.NoError(t, err)
	//
	//t.Log(result)

	//g := NewSerdeJSONUnion(union)
	//result2, err2 := g.Generate()
	//assert.NoError(t, err2)
	//
	//t.Log(string(result2))

	// Used to generate type registry
	walker := shape.NewIndexedTypeWalkerWithContentBody(contents,
		func(x *shape.IndexedTypeWalker) {
			x.SetPkgImportName(pkgName)
		},
	)

	expanded := walker.ExpandedShapes()
	t.Log("expanded...", expanded)
	for _, s := range expanded {
		found := false
		if ref, ok := s.(*shape.RefName); ok {
			for _, sh := range inferred.RetrieveShapes() {
				if shape.Name(sh) == ref.Name &&
					shape.PkgName(sh) == ref.PkgName {
					s = sh
					found = true
					break
				}
			}
			if !found {
				s, found = shape.LookupShapeOnDisk(ref)
			}
			if found {
				s = shape.IndexWith(s, ref)
			}
		}
		//switch ss := s.(type) {
		//case *shape.UnionLike:
		g2 := NewShapeTagged(s)
		str, err := g2.generateShapeFunc(s)
		t.Log(str)
		t.Log(err)
		//resultg, _ := g2.Generate()
		//require.NoError(t, errg)
		//t.Log(string(resultg))
		//default:
		//t.Log(shape.ToStr(s))
		//}
	}

	buff, err3 := GenerateTypeRegistry(walker, inferred)
	assert.NoError(t, err3)
	t.Log(string(buff.Bytes()))
}

func GenerateTypeRegistry(inferred *shape.IndexedTypeWalker, infshapes *shape.InferredInfo) (bytes.Buffer, error) {
	packageName := inferred.PackageName()

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	found := inferred.ExpandedShapes()
	if len(found) == 0 {
		return contents, nil
	}

	sortedKeys := make([]string, 0, len(found))
	for k := range found {
		sortedKeys = append(sortedKeys, k)
	}

	sort.Strings(sortedKeys)

	maps := []PkgMap{
		{
			"shared": "github.com/widmogrod/mkunion/x/shared",
		},
	}
	for _, key := range sortedKeys {
		inst := found[key]
		next := shape.ExtractPkgImportNamesForTypeInitialisation(inst)
		maps = append(maps, next)
	}
	pkgMap := MergePkgMaps(maps...)
	delete(pkgMap, packageName)

	contents.WriteString(GenerateImports(pkgMap))

	contents.WriteString("func init() {\n")
	// generate type registry

	for _, key := range sortedKeys {
		inst := found[key]
		instantiatedTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithRootPkgName(packageName),
		)
		fullTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithPkgImportName(),
		)

		// Register go type
		if packageName == "shared" {
			contents.WriteString(fmt.Sprintf("\tTypeRegistryStore[%s](%q)\n", instantiatedTypeName, fullTypeName))
		} else {
			contents.WriteString(fmt.Sprintf("\tshared.TypeRegistryStore[%s](%q)\n", instantiatedTypeName, fullTypeName))
		}

		// Try to register type JSON marshaller
		if ref, ok := inst.(*shape.RefName); ok {
			var some shape.Shape
			var found bool
			for _, sh := range infshapes.RetrieveShapes() {
				if shape.Name(sh) == ref.Name &&
					shape.PkgName(sh) == ref.PkgName {
					some = sh
					found = true
					break
				}
			}
			if !found {
				some, found = shape.LookupShapeOnDisk(ref)
				if !found {
					continue
				}
			}
			some = shape.IndexWith(some, ref)
			if shape.IsUnion(some) {
				contents.WriteString(fmt.Sprintf("\t%s\n", StrRegisterUnionFuncName(packageName, some)))
			}
		}
	}

	contents.WriteString("}\n")

	return contents, nil
}

func TestToGoPkgName(t *testing.T) {
	subject := &shape.StructLike{
		Name:          "Err",
		PkgName:       "f",
		PkgImportName: "github.com/widmogrod/mkunion/f",
		TypeParams: []shape.TypeParam{
			shape.TypeParam{
				Name: "A",
				//Name: "Option[testutils.User]",
				Type: &shape.RefName{
					Name:          "Option",
					PkgName:       "f",
					PkgImportName: "github.com/widmogrod/mkunion/f",
					Indexed: []shape.Shape{
						&shape.RefName{
							Name:          "User",
							PkgName:       "testutils",
							PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
						},
					},
				},
			},
			shape.TypeParam{
				Name: "E",
				//Name: "testutils.APIError",
				Type: &shape.RefName{
					Name:          "APIError",
					PkgName:       "testutils",
					PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
				},
			},
		},
		Fields: []*shape.FieldLike{
			{
				Name: "Error",
				Type: &shape.RefName{
					Name:          "APIError",
					PkgName:       "testutils",
					PkgImportName: "github.com/widmogrod/mkunion/x/generators/testutils",
				},
			},
		},
		Tags: map[string]shape.Tag{
			"mkunion": {
				Value: "Result",
			},
		},
	}

	assert.Equal(t, "f", shape.ToGoPkgName(subject), "root package name is incorrect")

	result := shape.ToGoTypeName(subject,
		shape.WithInstantiation(),
		shape.WithPkgImportName(),
	)
	assert.Equal(t, "github.com/widmogrod/mkunion/f.Err[github.com/widmogrod/mkunion/f.Option[github.com/widmogrod/mkunion/x/generators/testutils.User],github.com/widmogrod/mkunion/x/generators/testutils.APIError]", result)
	//assert.Equal(t, "github.com/widmogrod/mkunion/f.Err[github.com/widmogrod/mkunion/f.Option[github.com/widmogrod/mkunion/x/generators/testutils.User],github.com/widmogrod/mkunion/x/generators/testutils.APIError]", result)

	result2 := shape.ToGoTypeName(subject,
		shape.WithInstantiation(),
	)
	assert.Equal(t, "f.Err[Option[testutils.User],testutils.APIError]", result2)

	result3 := shape.ToGoTypeName(subject,
		shape.WithPkgImportName(),
	)
	assert.Equal(t, "github.com/widmogrod/mkunion/f.Err[A,E]", result3)

	result4 := shape.ToGoTypeName(subject,
		shape.WithRootPkgName("f"),
	)
	assert.Equal(t, "Err[A,E]", result4)

	result5 := shape.ToGoTypeName(subject,
		shape.WithInstantiation(),
		shape.WithRootPkgName("f"),
	)
	assert.Equal(t, "Err[Option[testutils.User],testutils.APIError]", result5)

	result5b := shape.ToGoTypeName(subject,
		shape.WithInstantiation(),
		shape.WithRootPkgName("testutils"),
	)
	assert.Equal(t, "f.Err[f.Option[User],APIError]", result5b)

	result6 := shape.ToGoTypeName(subject,
		shape.WithInstantiation(),
		shape.WithPkgImportName(),
		shape.WithRootPkgName("f"),
	)
	assert.Equal(t, "Err[Option[github.com/widmogrod/mkunion/x/generators/testutils.User],github.com/widmogrod/mkunion/x/generators/testutils.APIError]", result6)
}
