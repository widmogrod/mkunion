// Code generated by mkunion. DO NOT EDIT.
package testutils

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type AlphabetVisitor interface {
	VisitA1(v *A1) any
	VisitB2(v *B2) any
	VisitC3(v *C3) any
}

type Alphabet interface {
	AcceptAlphabet(g AlphabetVisitor) any
}

var (
	_ Alphabet = (*A1)(nil)
	_ Alphabet = (*B2)(nil)
	_ Alphabet = (*C3)(nil)
)

func (r *A1) AcceptAlphabet(v AlphabetVisitor) any { return v.VisitA1(r) }
func (r *B2) AcceptAlphabet(v AlphabetVisitor) any { return v.VisitB2(r) }
func (r *C3) AcceptAlphabet(v AlphabetVisitor) any { return v.VisitC3(r) }

func MatchAlphabetR3[T0, T1, T2 any](
	x Alphabet,
	f1 func(x *A1) (T0, T1, T2),
	f2 func(x *B2) (T0, T1, T2),
	f3 func(x *C3) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *A1:
		return f1(v)
	case *B2:
		return f2(v)
	case *C3:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchAlphabetR2[T0, T1 any](
	x Alphabet,
	f1 func(x *A1) (T0, T1),
	f2 func(x *B2) (T0, T1),
	f3 func(x *C3) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *A1:
		return f1(v)
	case *B2:
		return f2(v)
	case *C3:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchAlphabetR1[T0 any](
	x Alphabet,
	f1 func(x *A1) T0,
	f2 func(x *B2) T0,
	f3 func(x *C3) T0,
) T0 {
	switch v := x.(type) {
	case *A1:
		return f1(v)
	case *B2:
		return f2(v)
	case *C3:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchAlphabetR0(
	x Alphabet,
	f1 func(x *A1),
	f2 func(x *B2),
	f3 func(x *C3),
) {
	switch v := x.(type) {
	case *A1:
		f1(v)
	case *B2:
		f2(v)
	case *C3:
		f3(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.A1", A1FromJSON, A1ToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Alphabet", AlphabetFromJSON, AlphabetToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.B2", B2FromJSON, B2ToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.C3", C3FromJSON, C3ToJSON)
}

type AlphabetUnionJSON struct {
	Type string          `json:"$type,omitempty"`
	A1   json.RawMessage `json:"testutils.A1,omitempty"`
	B2   json.RawMessage `json:"testutils.B2,omitempty"`
	C3   json.RawMessage `json:"testutils.C3,omitempty"`
}

func AlphabetFromJSON(x []byte) (Alphabet, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data AlphabetUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("testutils.AlphabetFromJSON: %w", err)
	}

	switch data.Type {
	case "testutils.A1":
		return A1FromJSON(data.A1)
	case "testutils.B2":
		return B2FromJSON(data.B2)
	case "testutils.C3":
		return C3FromJSON(data.C3)
	}

	if data.A1 != nil {
		return A1FromJSON(data.A1)
	} else if data.B2 != nil {
		return B2FromJSON(data.B2)
	} else if data.C3 != nil {
		return C3FromJSON(data.C3)
	}
	return nil, fmt.Errorf("testutils.AlphabetFromJSON: unknown type: %s", data.Type)
}

func AlphabetToJSON(x Alphabet) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchAlphabetR2(
		x,
		func(y *A1) ([]byte, error) {
			body, err := A1ToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("testutils.AlphabetToJSON: %w", err)
			}
			return json.Marshal(AlphabetUnionJSON{
				Type: "testutils.A1",
				A1:   body,
			})
		},
		func(y *B2) ([]byte, error) {
			body, err := B2ToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("testutils.AlphabetToJSON: %w", err)
			}
			return json.Marshal(AlphabetUnionJSON{
				Type: "testutils.B2",
				B2:   body,
			})
		},
		func(y *C3) ([]byte, error) {
			body, err := C3ToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("testutils.AlphabetToJSON: %w", err)
			}
			return json.Marshal(AlphabetUnionJSON{
				Type: "testutils.C3",
				C3:   body,
			})
		},
	)
}

func A1FromJSON(x []byte) (*A1, error) {
	result := new(A1)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("testutils.A1FromJSON: %w", err)
	}
	return result, nil
}

func A1ToJSON(x *A1) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*A1)(nil)
	_ json.Marshaler   = (*A1)(nil)
)

func (r *A1) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONA1(*r)
}
func (r *A1) _marshalJSONA1(x A1) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutils: A1._marshalJSONA1: struct; %w", err)
	}
	return result, nil
}
func (r *A1) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONA1(data)
	if err != nil {
		return fmt.Errorf("testutils: A1.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *A1) _unmarshalJSONA1(data []byte) (A1, error) {
	result := A1{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutils: A1._unmarshalJSONA1: native struct unwrap; %w", err)
	}
	return result, nil
}

func B2FromJSON(x []byte) (*B2, error) {
	result := new(B2)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("testutils.B2FromJSON: %w", err)
	}
	return result, nil
}

func B2ToJSON(x *B2) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*B2)(nil)
	_ json.Marshaler   = (*B2)(nil)
)

func (r *B2) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONB2(*r)
}
func (r *B2) _marshalJSONB2(x B2) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutils: B2._marshalJSONB2: struct; %w", err)
	}
	return result, nil
}
func (r *B2) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONB2(data)
	if err != nil {
		return fmt.Errorf("testutils: B2.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *B2) _unmarshalJSONB2(data []byte) (B2, error) {
	result := B2{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutils: B2._unmarshalJSONB2: native struct unwrap; %w", err)
	}
	return result, nil
}

func C3FromJSON(x []byte) (*C3, error) {
	result := new(C3)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("testutils.C3FromJSON: %w", err)
	}
	return result, nil
}

func C3ToJSON(x *C3) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*C3)(nil)
	_ json.Marshaler   = (*C3)(nil)
)

func (r *C3) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONC3(*r)
}
func (r *C3) _marshalJSONC3(x C3) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutils: C3._marshalJSONC3: struct; %w", err)
	}
	return result, nil
}
func (r *C3) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONC3(data)
	if err != nil {
		return fmt.Errorf("testutils: C3.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *C3) _unmarshalJSONC3(data []byte) (C3, error) {
	result := C3{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutils: C3._unmarshalJSONC3: native struct unwrap; %w", err)
	}
	return result, nil
}

type NumberVisitor interface {
	VisitN0(v *N0) any
	VisitN1(v *N1) any
}

type Number interface {
	AcceptNumber(g NumberVisitor) any
}

var (
	_ Number = (*N0)(nil)
	_ Number = (*N1)(nil)
)

func (r *N0) AcceptNumber(v NumberVisitor) any { return v.VisitN0(r) }
func (r *N1) AcceptNumber(v NumberVisitor) any { return v.VisitN1(r) }

func MatchNumberR3[T0, T1, T2 any](
	x Number,
	f1 func(x *N0) (T0, T1, T2),
	f2 func(x *N1) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *N0:
		return f1(v)
	case *N1:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchNumberR2[T0, T1 any](
	x Number,
	f1 func(x *N0) (T0, T1),
	f2 func(x *N1) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *N0:
		return f1(v)
	case *N1:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchNumberR1[T0 any](
	x Number,
	f1 func(x *N0) T0,
	f2 func(x *N1) T0,
) T0 {
	switch v := x.(type) {
	case *N0:
		return f1(v)
	case *N1:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchNumberR0(
	x Number,
	f1 func(x *N0),
	f2 func(x *N1),
) {
	switch v := x.(type) {
	case *N0:
		f1(v)
	case *N1:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.N0", N0FromJSON, N0ToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.N1", N1FromJSON, N1ToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/generators/testutils.Number", NumberFromJSON, NumberToJSON)
}

type NumberUnionJSON struct {
	Type string          `json:"$type,omitempty"`
	N0   json.RawMessage `json:"testutils.N0,omitempty"`
	N1   json.RawMessage `json:"testutils.N1,omitempty"`
}

func NumberFromJSON(x []byte) (Number, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data NumberUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("testutils.NumberFromJSON: %w", err)
	}

	switch data.Type {
	case "testutils.N0":
		return N0FromJSON(data.N0)
	case "testutils.N1":
		return N1FromJSON(data.N1)
	}

	if data.N0 != nil {
		return N0FromJSON(data.N0)
	} else if data.N1 != nil {
		return N1FromJSON(data.N1)
	}
	return nil, fmt.Errorf("testutils.NumberFromJSON: unknown type: %s", data.Type)
}

func NumberToJSON(x Number) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchNumberR2(
		x,
		func(y *N0) ([]byte, error) {
			body, err := N0ToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("testutils.NumberToJSON: %w", err)
			}
			return json.Marshal(NumberUnionJSON{
				Type: "testutils.N0",
				N0:   body,
			})
		},
		func(y *N1) ([]byte, error) {
			body, err := N1ToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("testutils.NumberToJSON: %w", err)
			}
			return json.Marshal(NumberUnionJSON{
				Type: "testutils.N1",
				N1:   body,
			})
		},
	)
}

func N0FromJSON(x []byte) (*N0, error) {
	result := new(N0)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("testutils.N0FromJSON: %w", err)
	}
	return result, nil
}

func N0ToJSON(x *N0) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*N0)(nil)
	_ json.Marshaler   = (*N0)(nil)
)

func (r *N0) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONN0(*r)
}
func (r *N0) _marshalJSONN0(x N0) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutils: N0._marshalJSONN0: struct; %w", err)
	}
	return result, nil
}
func (r *N0) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONN0(data)
	if err != nil {
		return fmt.Errorf("testutils: N0.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *N0) _unmarshalJSONN0(data []byte) (N0, error) {
	result := N0{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutils: N0._unmarshalJSONN0: native struct unwrap; %w", err)
	}
	return result, nil
}

func N1FromJSON(x []byte) (*N1, error) {
	result := new(N1)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("testutils.N1FromJSON: %w", err)
	}
	return result, nil
}

func N1ToJSON(x *N1) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*N1)(nil)
	_ json.Marshaler   = (*N1)(nil)
)

func (r *N1) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONN1(*r)
}
func (r *N1) _marshalJSONN1(x N1) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutils: N1._marshalJSONN1: struct; %w", err)
	}
	return result, nil
}
func (r *N1) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONN1(data)
	if err != nil {
		return fmt.Errorf("testutils: N1.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *N1) _unmarshalJSONN1(data []byte) (N1, error) {
	result := N1{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutils: N1._unmarshalJSONN1: native struct unwrap; %w", err)
	}
	return result, nil
}
