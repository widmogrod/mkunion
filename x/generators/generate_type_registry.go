package generators

import (
	"bytes"
	"fmt"
	"github.com/widmogrod/mkunion/x/shape"
	"sort"
)

func GenerateTypeRegistry(inferred *shape.IndexedTypeWalker, lookupShape func(*shape.RefName) (shape.Shape, bool)) (bytes.Buffer, error) {
	packageName := inferred.PackageName()

	contents := bytes.Buffer{}
	contents.WriteString("// Code generated by mkunion. DO NOT EDIT.\n")
	contents.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	found := inferred.ExpandedShapes()
	if len(found) == 0 {
		return contents, nil
	}

	sortedKeys := make([]string, 0, len(found))
	for k := range found {
		sortedKeys = append(sortedKeys, k)
	}

	sort.Strings(sortedKeys)

	maps := []PkgMap{
		{
			"shared": "github.com/widmogrod/mkunion/x/shared",
		},
	}
	for _, key := range sortedKeys {
		inst := found[key]
		next := shape.ExtractPkgImportNamesForTypeInitialisation(inst)
		maps = append(maps, next)
	}
	pkgMap := MergePkgMaps(maps...)
	delete(pkgMap, packageName)

	contents.WriteString(GenerateImports(pkgMap))

	contents.WriteString("func init() {\n")
	// generate type registry

	for _, key := range sortedKeys {
		inst := found[key]
		instantiatedTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithRootPkgName(packageName),
		)
		fullTypeName := shape.ToGoTypeName(inst,
			shape.WithInstantiation(),
			shape.WithPkgImportName(),
		)

		// Register go type
		if packageName == "shared" {
			contents.WriteString(fmt.Sprintf("\tTypeRegistryStore[%s](%q)\n", instantiatedTypeName, fullTypeName))
		} else {
			contents.WriteString(fmt.Sprintf("\tshared.TypeRegistryStore[%s](%q)\n", instantiatedTypeName, fullTypeName))
		}

		// Try to register type JSON marshaller
		if ref, ok := inst.(*shape.RefName); ok {
			some, found := lookupShape(ref)
			if !found {
				continue
			}
			some = shape.IndexWith(some, ref)
			if shape.IsUnion(some) {
				contents.WriteString(fmt.Sprintf("\t%s\n", StrRegisterUnionFuncName(packageName, some)))
			}
		}
	}

	contents.WriteString("}\n")

	return contents, nil
}
