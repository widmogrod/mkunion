// Code generated by mkunion. DO NOT EDIT.
package testutil

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/schema"
	"github.com/widmogrod/mkunion/x/shared"
)

type TreeishVisitor interface {
	VisitBranch(v *Branch) any
	VisitLeaf(v *Leaf) any
}

type Treeish interface {
	AcceptTreeish(g TreeishVisitor) any
}

var (
	_ Treeish = (*Branch)(nil)
	_ Treeish = (*Leaf)(nil)
)

func (r *Branch) AcceptTreeish(v TreeishVisitor) any { return v.VisitBranch(r) }
func (r *Leaf) AcceptTreeish(v TreeishVisitor) any   { return v.VisitLeaf(r) }

func MatchTreeishR3[T0, T1, T2 any](
	x Treeish,
	f1 func(x *Branch) (T0, T1, T2),
	f2 func(x *Leaf) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Branch:
		return f1(v)
	case *Leaf:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchTreeishR2[T0, T1 any](
	x Treeish,
	f1 func(x *Branch) (T0, T1),
	f2 func(x *Leaf) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Branch:
		return f1(v)
	case *Leaf:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchTreeishR1[T0 any](
	x Treeish,
	f1 func(x *Branch) T0,
	f2 func(x *Leaf) T0,
) T0 {
	switch v := x.(type) {
	case *Branch:
		return f1(v)
	case *Leaf:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchTreeishR0(
	x Treeish,
	f1 func(x *Branch),
	f2 func(x *Leaf),
) {
	switch v := x.(type) {
	case *Branch:
		f1(v)
	case *Leaf:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate/testutil.Branch", BranchFromJSON, BranchToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate/testutil.Leaf", LeafFromJSON, LeafToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/predicate/testutil.Treeish", TreeishFromJSON, TreeishToJSON)
}

type TreeishUnionJSON struct {
	Type   string          `json:"$type,omitempty"`
	Branch json.RawMessage `json:"testutil.Branch,omitempty"`
	Leaf   json.RawMessage `json:"testutil.Leaf,omitempty"`
}

func TreeishFromJSON(x []byte) (Treeish, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data TreeishUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("testutil.TreeishFromJSON: %w", err)
	}

	switch data.Type {
	case "testutil.Branch":
		return BranchFromJSON(data.Branch)
	case "testutil.Leaf":
		return LeafFromJSON(data.Leaf)
	}

	if data.Branch != nil {
		return BranchFromJSON(data.Branch)
	} else if data.Leaf != nil {
		return LeafFromJSON(data.Leaf)
	}
	return nil, fmt.Errorf("testutil.TreeishFromJSON: unknown type: %s", data.Type)
}

func TreeishToJSON(x Treeish) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchTreeishR2(
		x,
		func(y *Branch) ([]byte, error) {
			body, err := BranchToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("testutil.TreeishToJSON: %w", err)
			}
			return json.Marshal(TreeishUnionJSON{
				Type:   "testutil.Branch",
				Branch: body,
			})
		},
		func(y *Leaf) ([]byte, error) {
			body, err := LeafToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("testutil.TreeishToJSON: %w", err)
			}
			return json.Marshal(TreeishUnionJSON{
				Type: "testutil.Leaf",
				Leaf: body,
			})
		},
	)
}

func BranchFromJSON(x []byte) (*Branch, error) {
	result := new(Branch)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("testutil.BranchFromJSON: %w", err)
	}
	return result, nil
}

func BranchToJSON(x *Branch) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Branch)(nil)
	_ json.Marshaler   = (*Branch)(nil)
)

func (r *Branch) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONBranch(*r)
}
func (r *Branch) _marshalJSONBranch(x Branch) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldName []byte
	fieldName, err = r._marshalJSONstring(x.Name)
	if err != nil {
		return nil, fmt.Errorf("testutil: Branch._marshalJSONBranch: field name Name; %w", err)
	}
	partial["Name"] = fieldName
	var fieldLeft []byte
	fieldLeft, err = r._marshalJSONTreeish(x.Left)
	if err != nil {
		return nil, fmt.Errorf("testutil: Branch._marshalJSONBranch: field name Left; %w", err)
	}
	partial["Left"] = fieldLeft
	var fieldRight []byte
	fieldRight, err = r._marshalJSONTreeish(x.Right)
	if err != nil {
		return nil, fmt.Errorf("testutil: Branch._marshalJSONBranch: field name Right; %w", err)
	}
	partial["Right"] = fieldRight
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutil: Branch._marshalJSONBranch: struct; %w", err)
	}
	return result, nil
}
func (r *Branch) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("testutil: Branch._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Branch) _marshalJSONTreeish(x Treeish) ([]byte, error) {
	result, err := shared.JSONMarshal[Treeish](x)
	if err != nil {
		return nil, fmt.Errorf("testutil: Branch._marshalJSONTreeish:; %w", err)
	}
	return result, nil
}
func (r *Branch) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONBranch(data)
	if err != nil {
		return fmt.Errorf("testutil: Branch.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Branch) _unmarshalJSONBranch(data []byte) (Branch, error) {
	result := Branch{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutil: Branch._unmarshalJSONBranch: native struct unwrap; %w", err)
	}
	if fieldName, ok := partial["Name"]; ok {
		result.Name, err = r._unmarshalJSONstring(fieldName)
		if err != nil {
			return result, fmt.Errorf("testutil: Branch._unmarshalJSONBranch: field Name; %w", err)
		}
	}
	if fieldLeft, ok := partial["Left"]; ok {
		result.Left, err = r._unmarshalJSONTreeish(fieldLeft)
		if err != nil {
			return result, fmt.Errorf("testutil: Branch._unmarshalJSONBranch: field Left; %w", err)
		}
	}
	if fieldRight, ok := partial["Right"]; ok {
		result.Right, err = r._unmarshalJSONTreeish(fieldRight)
		if err != nil {
			return result, fmt.Errorf("testutil: Branch._unmarshalJSONBranch: field Right; %w", err)
		}
	}
	return result, nil
}
func (r *Branch) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("testutil: Branch._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Branch) _unmarshalJSONTreeish(data []byte) (Treeish, error) {
	result, err := shared.JSONUnmarshal[Treeish](data)
	if err != nil {
		return result, fmt.Errorf("testutil: Branch._unmarshalJSONTreeish: native ref unwrap; %w", err)
	}
	return result, nil
}

func LeafFromJSON(x []byte) (*Leaf, error) {
	result := new(Leaf)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("testutil.LeafFromJSON: %w", err)
	}
	return result, nil
}

func LeafToJSON(x *Leaf) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Leaf)(nil)
	_ json.Marshaler   = (*Leaf)(nil)
)

func (r *Leaf) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONLeaf(*r)
}
func (r *Leaf) _marshalJSONLeaf(x Leaf) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldValue []byte
	fieldValue, err = r._marshalJSONschema_Schema(x.Value)
	if err != nil {
		return nil, fmt.Errorf("testutil: Leaf._marshalJSONLeaf: field name Value; %w", err)
	}
	partial["Value"] = fieldValue
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("testutil: Leaf._marshalJSONLeaf: struct; %w", err)
	}
	return result, nil
}
func (r *Leaf) _marshalJSONschema_Schema(x schema.Schema) ([]byte, error) {
	result, err := shared.JSONMarshal[schema.Schema](x)
	if err != nil {
		return nil, fmt.Errorf("testutil: Leaf._marshalJSONschema_Schema:; %w", err)
	}
	return result, nil
}
func (r *Leaf) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONLeaf(data)
	if err != nil {
		return fmt.Errorf("testutil: Leaf.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Leaf) _unmarshalJSONLeaf(data []byte) (Leaf, error) {
	result := Leaf{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("testutil: Leaf._unmarshalJSONLeaf: native struct unwrap; %w", err)
	}
	if fieldValue, ok := partial["Value"]; ok {
		result.Value, err = r._unmarshalJSONschema_Schema(fieldValue)
		if err != nil {
			return result, fmt.Errorf("testutil: Leaf._unmarshalJSONLeaf: field Value; %w", err)
		}
	}
	return result, nil
}
func (r *Leaf) _unmarshalJSONschema_Schema(data []byte) (schema.Schema, error) {
	result, err := shared.JSONUnmarshal[schema.Schema](data)
	if err != nil {
		return result, fmt.Errorf("testutil: Leaf._unmarshalJSONschema_Schema: native ref unwrap; %w", err)
	}
	return result, nil
}
