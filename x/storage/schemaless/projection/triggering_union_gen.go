// Code generated by mkunion. DO NOT EDIT.
package projection

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
	"time"
)

func init() {
	shape.Register(TriggerTypeShape())
	shape.Register(AtPeriod1Shape())
	shape.Register(AtWindowItemSize1Shape())
	shape.Register(AtWatermark1Shape())
	shape.Register(TriggerDescriptionShape())
	shape.Register(AtPeriodShape())
	shape.Register(AtWindowItemSizeShape())
	shape.Register(AtWatermarkShape())
	shape.Register(AnyOfShape())
	shape.Register(AllOfShape())
	shape.Register(WindowFlushModeShape())
	shape.Register(AccumulateShape())
	shape.Register(DiscardShape())
	shape.Register(AccumulatingAndRetractingShape())
}

type TriggerTypeVisitor interface {
	VisitAtPeriod1(v *AtPeriod1) any
	VisitAtWindowItemSize1(v *AtWindowItemSize1) any
	VisitAtWatermark1(v *AtWatermark1) any
}

type TriggerType interface {
	AcceptTriggerType(g TriggerTypeVisitor) any
}

var (
	_ TriggerType = (*AtPeriod1)(nil)
	_ TriggerType = (*AtWindowItemSize1)(nil)
	_ TriggerType = (*AtWatermark1)(nil)
)

func (r *AtPeriod1) AcceptTriggerType(v TriggerTypeVisitor) any { return v.VisitAtPeriod1(r) }
func (r *AtWindowItemSize1) AcceptTriggerType(v TriggerTypeVisitor) any {
	return v.VisitAtWindowItemSize1(r)
}
func (r *AtWatermark1) AcceptTriggerType(v TriggerTypeVisitor) any { return v.VisitAtWatermark1(r) }

func MatchTriggerTypeR3[T0, T1, T2 any](
	x TriggerType,
	f1 func(x *AtPeriod1) (T0, T1, T2),
	f2 func(x *AtWindowItemSize1) (T0, T1, T2),
	f3 func(x *AtWatermark1) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *AtPeriod1:
		return f1(v)
	case *AtWindowItemSize1:
		return f2(v)
	case *AtWatermark1:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchTriggerTypeR2[T0, T1 any](
	x TriggerType,
	f1 func(x *AtPeriod1) (T0, T1),
	f2 func(x *AtWindowItemSize1) (T0, T1),
	f3 func(x *AtWatermark1) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *AtPeriod1:
		return f1(v)
	case *AtWindowItemSize1:
		return f2(v)
	case *AtWatermark1:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchTriggerTypeR1[T0 any](
	x TriggerType,
	f1 func(x *AtPeriod1) T0,
	f2 func(x *AtWindowItemSize1) T0,
	f3 func(x *AtWatermark1) T0,
) T0 {
	switch v := x.(type) {
	case *AtPeriod1:
		return f1(v)
	case *AtWindowItemSize1:
		return f2(v)
	case *AtWatermark1:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchTriggerTypeR0(
	x TriggerType,
	f1 func(x *AtPeriod1),
	f2 func(x *AtWindowItemSize1),
	f3 func(x *AtWatermark1),
) {
	switch v := x.(type) {
	case *AtPeriod1:
		f1(v)
	case *AtWindowItemSize1:
		f2(v)
	case *AtWatermark1:
		f3(v)
	}
}

func TriggerTypeShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "TriggerType",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Variant: []shape.Shape{
			AtPeriod1Shape(),
			AtWindowItemSize1Shape(),
			AtWatermark1Shape(),
		},
	}
}

func AtPeriod1Shape() shape.Shape {
	return &shape.AliasLike{
		Name:          "AtPeriod1",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		IsAlias:       true,
		Type: &shape.RefName{
			Name:          "AtPeriod",
			PkgName:       "projection",
			PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		},
	}
}

func AtWindowItemSize1Shape() shape.Shape {
	return &shape.AliasLike{
		Name:          "AtWindowItemSize1",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		IsAlias:       true,
		Type: &shape.RefName{
			Name:          "AtWindowItemSize",
			PkgName:       "projection",
			PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		},
	}
}

func AtWatermark1Shape() shape.Shape {
	return &shape.AliasLike{
		Name:          "AtWatermark1",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		IsAlias:       true,
		Type: &shape.RefName{
			Name:          "AtWatermark",
			PkgName:       "projection",
			PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		},
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.TriggerType", TriggerTypeFromJSON, TriggerTypeToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AtPeriod1", AtPeriod1FromJSON, AtPeriod1ToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AtWindowItemSize1", AtWindowItemSize1FromJSON, AtWindowItemSize1ToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AtWatermark1", AtWatermark1FromJSON, AtWatermark1ToJSON)
}

type TriggerTypeUnionJSON struct {
	Type              string          `json:"$type,omitempty"`
	AtPeriod1         json.RawMessage `json:"projection.AtPeriod1,omitempty"`
	AtWindowItemSize1 json.RawMessage `json:"projection.AtWindowItemSize1,omitempty"`
	AtWatermark1      json.RawMessage `json:"projection.AtWatermark1,omitempty"`
}

func TriggerTypeFromJSON(x []byte) (TriggerType, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data TriggerTypeUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "projection.AtPeriod1":
		return AtPeriod1FromJSON(data.AtPeriod1)
	case "projection.AtWindowItemSize1":
		return AtWindowItemSize1FromJSON(data.AtWindowItemSize1)
	case "projection.AtWatermark1":
		return AtWatermark1FromJSON(data.AtWatermark1)
	}

	if data.AtPeriod1 != nil {
		return AtPeriod1FromJSON(data.AtPeriod1)
	} else if data.AtWindowItemSize1 != nil {
		return AtWindowItemSize1FromJSON(data.AtWindowItemSize1)
	} else if data.AtWatermark1 != nil {
		return AtWatermark1FromJSON(data.AtWatermark1)
	}

	return nil, fmt.Errorf("projection.TriggerType: unknown type %s", data.Type)
}

func TriggerTypeToJSON(x TriggerType) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MatchTriggerTypeR2(
		x,
		func(x *AtPeriod1) ([]byte, error) {
			body, err := AtPeriod1ToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerTypeUnionJSON{
				Type:      "projection.AtPeriod1",
				AtPeriod1: body,
			})
		},
		func(x *AtWindowItemSize1) ([]byte, error) {
			body, err := AtWindowItemSize1ToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerTypeUnionJSON{
				Type:              "projection.AtWindowItemSize1",
				AtWindowItemSize1: body,
			})
		},
		func(x *AtWatermark1) ([]byte, error) {
			body, err := AtWatermark1ToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerTypeUnionJSON{
				Type:         "projection.AtWatermark1",
				AtWatermark1: body,
			})
		},
	)
}

func AtPeriod1FromJSON(x []byte) (*AtPeriod1, error) {
	result := new(AtPeriod1)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AtPeriod1ToJSON(x *AtPeriod1) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AtPeriod1)(nil)
	_ json.Marshaler   = (*AtPeriod1)(nil)
)

func AtWindowItemSize1FromJSON(x []byte) (*AtWindowItemSize1, error) {
	result := new(AtWindowItemSize1)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AtWindowItemSize1ToJSON(x *AtWindowItemSize1) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AtWindowItemSize1)(nil)
	_ json.Marshaler   = (*AtWindowItemSize1)(nil)
)

func AtWatermark1FromJSON(x []byte) (*AtWatermark1, error) {
	result := new(AtWatermark1)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AtWatermark1ToJSON(x *AtWatermark1) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AtWatermark1)(nil)
	_ json.Marshaler   = (*AtWatermark1)(nil)
)

type TriggerDescriptionVisitor interface {
	VisitAtPeriod(v *AtPeriod) any
	VisitAtWindowItemSize(v *AtWindowItemSize) any
	VisitAtWatermark(v *AtWatermark) any
	VisitAnyOf(v *AnyOf) any
	VisitAllOf(v *AllOf) any
}

type TriggerDescription interface {
	AcceptTriggerDescription(g TriggerDescriptionVisitor) any
}

var (
	_ TriggerDescription = (*AtPeriod)(nil)
	_ TriggerDescription = (*AtWindowItemSize)(nil)
	_ TriggerDescription = (*AtWatermark)(nil)
	_ TriggerDescription = (*AnyOf)(nil)
	_ TriggerDescription = (*AllOf)(nil)
)

func (r *AtPeriod) AcceptTriggerDescription(v TriggerDescriptionVisitor) any {
	return v.VisitAtPeriod(r)
}
func (r *AtWindowItemSize) AcceptTriggerDescription(v TriggerDescriptionVisitor) any {
	return v.VisitAtWindowItemSize(r)
}
func (r *AtWatermark) AcceptTriggerDescription(v TriggerDescriptionVisitor) any {
	return v.VisitAtWatermark(r)
}
func (r *AnyOf) AcceptTriggerDescription(v TriggerDescriptionVisitor) any { return v.VisitAnyOf(r) }
func (r *AllOf) AcceptTriggerDescription(v TriggerDescriptionVisitor) any { return v.VisitAllOf(r) }

func MatchTriggerDescriptionR3[T0, T1, T2 any](
	x TriggerDescription,
	f1 func(x *AtPeriod) (T0, T1, T2),
	f2 func(x *AtWindowItemSize) (T0, T1, T2),
	f3 func(x *AtWatermark) (T0, T1, T2),
	f4 func(x *AnyOf) (T0, T1, T2),
	f5 func(x *AllOf) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *AtPeriod:
		return f1(v)
	case *AtWindowItemSize:
		return f2(v)
	case *AtWatermark:
		return f3(v)
	case *AnyOf:
		return f4(v)
	case *AllOf:
		return f5(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchTriggerDescriptionR2[T0, T1 any](
	x TriggerDescription,
	f1 func(x *AtPeriod) (T0, T1),
	f2 func(x *AtWindowItemSize) (T0, T1),
	f3 func(x *AtWatermark) (T0, T1),
	f4 func(x *AnyOf) (T0, T1),
	f5 func(x *AllOf) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *AtPeriod:
		return f1(v)
	case *AtWindowItemSize:
		return f2(v)
	case *AtWatermark:
		return f3(v)
	case *AnyOf:
		return f4(v)
	case *AllOf:
		return f5(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchTriggerDescriptionR1[T0 any](
	x TriggerDescription,
	f1 func(x *AtPeriod) T0,
	f2 func(x *AtWindowItemSize) T0,
	f3 func(x *AtWatermark) T0,
	f4 func(x *AnyOf) T0,
	f5 func(x *AllOf) T0,
) T0 {
	switch v := x.(type) {
	case *AtPeriod:
		return f1(v)
	case *AtWindowItemSize:
		return f2(v)
	case *AtWatermark:
		return f3(v)
	case *AnyOf:
		return f4(v)
	case *AllOf:
		return f5(v)
	}
	var result1 T0
	return result1
}

func MatchTriggerDescriptionR0(
	x TriggerDescription,
	f1 func(x *AtPeriod),
	f2 func(x *AtWindowItemSize),
	f3 func(x *AtWatermark),
	f4 func(x *AnyOf),
	f5 func(x *AllOf),
) {
	switch v := x.(type) {
	case *AtPeriod:
		f1(v)
	case *AtWindowItemSize:
		f2(v)
	case *AtWatermark:
		f3(v)
	case *AnyOf:
		f4(v)
	case *AllOf:
		f5(v)
	}
}

func TriggerDescriptionShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "TriggerDescription",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Variant: []shape.Shape{
			AtPeriodShape(),
			AtWindowItemSizeShape(),
			AtWatermarkShape(),
			AnyOfShape(),
			AllOfShape(),
		},
	}
}

func AtPeriodShape() shape.Shape {
	return &shape.StructLike{
		Name:          "AtPeriod",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Duration",
				Type: &shape.RefName{
					Name:          "Duration",
					PkgName:       "time",
					PkgImportName: "time",
				},
			},
		},
	}
}

func AtWindowItemSizeShape() shape.Shape {
	return &shape.StructLike{
		Name:          "AtWindowItemSize",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Number",
				Type: &shape.PrimitiveLike{
					Kind: &shape.NumberLike{
						Kind: &shape.Int{},
					},
				},
			},
		},
	}
}

func AtWatermarkShape() shape.Shape {
	return &shape.StructLike{
		Name:          "AtWatermark",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Timestamp",
				Type: &shape.PrimitiveLike{
					Kind: &shape.NumberLike{
						Kind: &shape.Int64{},
					},
				},
			},
		},
	}
}

func AnyOfShape() shape.Shape {
	return &shape.StructLike{
		Name:          "AnyOf",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Triggers",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "TriggerDescription",
						PkgName:       "projection",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
					},
				},
			},
		},
	}
}

func AllOfShape() shape.Shape {
	return &shape.StructLike{
		Name:          "AllOf",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Triggers",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "TriggerDescription",
						PkgName:       "projection",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
					},
				},
			},
		},
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.TriggerDescription", TriggerDescriptionFromJSON, TriggerDescriptionToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AtPeriod", AtPeriodFromJSON, AtPeriodToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AtWindowItemSize", AtWindowItemSizeFromJSON, AtWindowItemSizeToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AtWatermark", AtWatermarkFromJSON, AtWatermarkToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AnyOf", AnyOfFromJSON, AnyOfToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AllOf", AllOfFromJSON, AllOfToJSON)
}

type TriggerDescriptionUnionJSON struct {
	Type             string          `json:"$type,omitempty"`
	AtPeriod         json.RawMessage `json:"projection.AtPeriod,omitempty"`
	AtWindowItemSize json.RawMessage `json:"projection.AtWindowItemSize,omitempty"`
	AtWatermark      json.RawMessage `json:"projection.AtWatermark,omitempty"`
	AnyOf            json.RawMessage `json:"projection.AnyOf,omitempty"`
	AllOf            json.RawMessage `json:"projection.AllOf,omitempty"`
}

func TriggerDescriptionFromJSON(x []byte) (TriggerDescription, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data TriggerDescriptionUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "projection.AtPeriod":
		return AtPeriodFromJSON(data.AtPeriod)
	case "projection.AtWindowItemSize":
		return AtWindowItemSizeFromJSON(data.AtWindowItemSize)
	case "projection.AtWatermark":
		return AtWatermarkFromJSON(data.AtWatermark)
	case "projection.AnyOf":
		return AnyOfFromJSON(data.AnyOf)
	case "projection.AllOf":
		return AllOfFromJSON(data.AllOf)
	}

	if data.AtPeriod != nil {
		return AtPeriodFromJSON(data.AtPeriod)
	} else if data.AtWindowItemSize != nil {
		return AtWindowItemSizeFromJSON(data.AtWindowItemSize)
	} else if data.AtWatermark != nil {
		return AtWatermarkFromJSON(data.AtWatermark)
	} else if data.AnyOf != nil {
		return AnyOfFromJSON(data.AnyOf)
	} else if data.AllOf != nil {
		return AllOfFromJSON(data.AllOf)
	}

	return nil, fmt.Errorf("projection.TriggerDescription: unknown type %s", data.Type)
}

func TriggerDescriptionToJSON(x TriggerDescription) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MatchTriggerDescriptionR2(
		x,
		func(x *AtPeriod) ([]byte, error) {
			body, err := AtPeriodToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerDescriptionUnionJSON{
				Type:     "projection.AtPeriod",
				AtPeriod: body,
			})
		},
		func(x *AtWindowItemSize) ([]byte, error) {
			body, err := AtWindowItemSizeToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerDescriptionUnionJSON{
				Type:             "projection.AtWindowItemSize",
				AtWindowItemSize: body,
			})
		},
		func(x *AtWatermark) ([]byte, error) {
			body, err := AtWatermarkToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerDescriptionUnionJSON{
				Type:        "projection.AtWatermark",
				AtWatermark: body,
			})
		},
		func(x *AnyOf) ([]byte, error) {
			body, err := AnyOfToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerDescriptionUnionJSON{
				Type:  "projection.AnyOf",
				AnyOf: body,
			})
		},
		func(x *AllOf) ([]byte, error) {
			body, err := AllOfToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(TriggerDescriptionUnionJSON{
				Type:  "projection.AllOf",
				AllOf: body,
			})
		},
	)
}

func AtPeriodFromJSON(x []byte) (*AtPeriod, error) {
	result := new(AtPeriod)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AtPeriodToJSON(x *AtPeriod) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AtPeriod)(nil)
	_ json.Marshaler   = (*AtPeriod)(nil)
)

func (r *AtPeriod) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAtPeriod(*r)
}
func (r *AtPeriod) _marshalJSONAtPeriod(x AtPeriod) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldDuration []byte
	fieldDuration, err = r._marshalJSONtime_Duration(x.Duration)
	if err != nil {
		return nil, fmt.Errorf("projection: AtPeriod._marshalJSONAtPeriod: field name Duration; %w", err)
	}
	partial["Duration"] = fieldDuration
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AtPeriod._marshalJSONAtPeriod: struct; %w", err)
	}
	return result, nil
}
func (r *AtPeriod) _marshalJSONtime_Duration(x time.Duration) ([]byte, error) {
	result, err := shared.JSONMarshal[time.Duration](x)
	if err != nil {
		return nil, fmt.Errorf("projection: AtPeriod._marshalJSONtime_Duration:; %w", err)
	}
	return result, nil
}
func (r *AtPeriod) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAtPeriod(data)
	if err != nil {
		return fmt.Errorf("projection: AtPeriod.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AtPeriod) _unmarshalJSONAtPeriod(data []byte) (AtPeriod, error) {
	result := AtPeriod{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AtPeriod._unmarshalJSONAtPeriod: native struct unwrap; %w", err)
	}
	if fieldDuration, ok := partial["Duration"]; ok {
		result.Duration, err = r._unmarshalJSONtime_Duration(fieldDuration)
		if err != nil {
			return result, fmt.Errorf("projection: AtPeriod._unmarshalJSONAtPeriod: field Duration; %w", err)
		}
	}
	return result, nil
}
func (r *AtPeriod) _unmarshalJSONtime_Duration(data []byte) (time.Duration, error) {
	result, err := shared.JSONUnmarshal[time.Duration](data)
	if err != nil {
		return result, fmt.Errorf("projection: AtPeriod._unmarshalJSONtime_Duration: native ref unwrap; %w", err)
	}
	return result, nil
}

func AtWindowItemSizeFromJSON(x []byte) (*AtWindowItemSize, error) {
	result := new(AtWindowItemSize)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AtWindowItemSizeToJSON(x *AtWindowItemSize) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AtWindowItemSize)(nil)
	_ json.Marshaler   = (*AtWindowItemSize)(nil)
)

func (r *AtWindowItemSize) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAtWindowItemSize(*r)
}
func (r *AtWindowItemSize) _marshalJSONAtWindowItemSize(x AtWindowItemSize) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldNumber []byte
	fieldNumber, err = r._marshalJSONint(x.Number)
	if err != nil {
		return nil, fmt.Errorf("projection: AtWindowItemSize._marshalJSONAtWindowItemSize: field name Number; %w", err)
	}
	partial["Number"] = fieldNumber
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AtWindowItemSize._marshalJSONAtWindowItemSize: struct; %w", err)
	}
	return result, nil
}
func (r *AtWindowItemSize) _marshalJSONint(x int) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("projection: AtWindowItemSize._marshalJSONint:; %w", err)
	}
	return result, nil
}
func (r *AtWindowItemSize) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAtWindowItemSize(data)
	if err != nil {
		return fmt.Errorf("projection: AtWindowItemSize.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AtWindowItemSize) _unmarshalJSONAtWindowItemSize(data []byte) (AtWindowItemSize, error) {
	result := AtWindowItemSize{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AtWindowItemSize._unmarshalJSONAtWindowItemSize: native struct unwrap; %w", err)
	}
	if fieldNumber, ok := partial["Number"]; ok {
		result.Number, err = r._unmarshalJSONint(fieldNumber)
		if err != nil {
			return result, fmt.Errorf("projection: AtWindowItemSize._unmarshalJSONAtWindowItemSize: field Number; %w", err)
		}
	}
	return result, nil
}
func (r *AtWindowItemSize) _unmarshalJSONint(data []byte) (int, error) {
	var result int
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("projection: AtWindowItemSize._unmarshalJSONint: native primitive unwrap; %w", err)
	}
	return result, nil
}

func AtWatermarkFromJSON(x []byte) (*AtWatermark, error) {
	result := new(AtWatermark)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AtWatermarkToJSON(x *AtWatermark) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AtWatermark)(nil)
	_ json.Marshaler   = (*AtWatermark)(nil)
)

func (r *AtWatermark) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAtWatermark(*r)
}
func (r *AtWatermark) _marshalJSONAtWatermark(x AtWatermark) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldTimestamp []byte
	fieldTimestamp, err = r._marshalJSONint64(x.Timestamp)
	if err != nil {
		return nil, fmt.Errorf("projection: AtWatermark._marshalJSONAtWatermark: field name Timestamp; %w", err)
	}
	partial["Timestamp"] = fieldTimestamp
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AtWatermark._marshalJSONAtWatermark: struct; %w", err)
	}
	return result, nil
}
func (r *AtWatermark) _marshalJSONint64(x int64) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("projection: AtWatermark._marshalJSONint64:; %w", err)
	}
	return result, nil
}
func (r *AtWatermark) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAtWatermark(data)
	if err != nil {
		return fmt.Errorf("projection: AtWatermark.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AtWatermark) _unmarshalJSONAtWatermark(data []byte) (AtWatermark, error) {
	result := AtWatermark{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AtWatermark._unmarshalJSONAtWatermark: native struct unwrap; %w", err)
	}
	if fieldTimestamp, ok := partial["Timestamp"]; ok {
		result.Timestamp, err = r._unmarshalJSONint64(fieldTimestamp)
		if err != nil {
			return result, fmt.Errorf("projection: AtWatermark._unmarshalJSONAtWatermark: field Timestamp; %w", err)
		}
	}
	return result, nil
}
func (r *AtWatermark) _unmarshalJSONint64(data []byte) (int64, error) {
	var result int64
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("projection: AtWatermark._unmarshalJSONint64: native primitive unwrap; %w", err)
	}
	return result, nil
}

func AnyOfFromJSON(x []byte) (*AnyOf, error) {
	result := new(AnyOf)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AnyOfToJSON(x *AnyOf) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AnyOf)(nil)
	_ json.Marshaler   = (*AnyOf)(nil)
)

func (r *AnyOf) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAnyOf(*r)
}
func (r *AnyOf) _marshalJSONAnyOf(x AnyOf) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldTriggers []byte
	fieldTriggers, err = r._marshalJSONSliceTriggerDescription(x.Triggers)
	if err != nil {
		return nil, fmt.Errorf("projection: AnyOf._marshalJSONAnyOf: field name Triggers; %w", err)
	}
	partial["Triggers"] = fieldTriggers
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AnyOf._marshalJSONAnyOf: struct; %w", err)
	}
	return result, nil
}
func (r *AnyOf) _marshalJSONSliceTriggerDescription(x []TriggerDescription) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONTriggerDescription(v)
		if err != nil {
			return nil, fmt.Errorf("projection: AnyOf._marshalJSONSliceTriggerDescription: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AnyOf._marshalJSONSliceTriggerDescription:; %w", err)
	}
	return result, nil
}
func (r *AnyOf) _marshalJSONTriggerDescription(x TriggerDescription) ([]byte, error) {
	result, err := shared.JSONMarshal[TriggerDescription](x)
	if err != nil {
		return nil, fmt.Errorf("projection: AnyOf._marshalJSONTriggerDescription:; %w", err)
	}
	return result, nil
}
func (r *AnyOf) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAnyOf(data)
	if err != nil {
		return fmt.Errorf("projection: AnyOf.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AnyOf) _unmarshalJSONAnyOf(data []byte) (AnyOf, error) {
	result := AnyOf{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AnyOf._unmarshalJSONAnyOf: native struct unwrap; %w", err)
	}
	if fieldTriggers, ok := partial["Triggers"]; ok {
		result.Triggers, err = r._unmarshalJSONSliceTriggerDescription(fieldTriggers)
		if err != nil {
			return result, fmt.Errorf("projection: AnyOf._unmarshalJSONAnyOf: field Triggers; %w", err)
		}
	}
	return result, nil
}
func (r *AnyOf) _unmarshalJSONSliceTriggerDescription(data []byte) ([]TriggerDescription, error) {
	result := make([]TriggerDescription, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AnyOf._unmarshalJSONSliceTriggerDescription: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONTriggerDescription(v)
		if err != nil {
			return result, fmt.Errorf("projection: AnyOf._unmarshalJSONSliceTriggerDescription: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *AnyOf) _unmarshalJSONTriggerDescription(data []byte) (TriggerDescription, error) {
	result, err := shared.JSONUnmarshal[TriggerDescription](data)
	if err != nil {
		return result, fmt.Errorf("projection: AnyOf._unmarshalJSONTriggerDescription: native ref unwrap; %w", err)
	}
	return result, nil
}

func AllOfFromJSON(x []byte) (*AllOf, error) {
	result := new(AllOf)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AllOfToJSON(x *AllOf) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AllOf)(nil)
	_ json.Marshaler   = (*AllOf)(nil)
)

func (r *AllOf) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAllOf(*r)
}
func (r *AllOf) _marshalJSONAllOf(x AllOf) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldTriggers []byte
	fieldTriggers, err = r._marshalJSONSliceTriggerDescription(x.Triggers)
	if err != nil {
		return nil, fmt.Errorf("projection: AllOf._marshalJSONAllOf: field name Triggers; %w", err)
	}
	partial["Triggers"] = fieldTriggers
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AllOf._marshalJSONAllOf: struct; %w", err)
	}
	return result, nil
}
func (r *AllOf) _marshalJSONSliceTriggerDescription(x []TriggerDescription) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONTriggerDescription(v)
		if err != nil {
			return nil, fmt.Errorf("projection: AllOf._marshalJSONSliceTriggerDescription: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AllOf._marshalJSONSliceTriggerDescription:; %w", err)
	}
	return result, nil
}
func (r *AllOf) _marshalJSONTriggerDescription(x TriggerDescription) ([]byte, error) {
	result, err := shared.JSONMarshal[TriggerDescription](x)
	if err != nil {
		return nil, fmt.Errorf("projection: AllOf._marshalJSONTriggerDescription:; %w", err)
	}
	return result, nil
}
func (r *AllOf) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAllOf(data)
	if err != nil {
		return fmt.Errorf("projection: AllOf.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AllOf) _unmarshalJSONAllOf(data []byte) (AllOf, error) {
	result := AllOf{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AllOf._unmarshalJSONAllOf: native struct unwrap; %w", err)
	}
	if fieldTriggers, ok := partial["Triggers"]; ok {
		result.Triggers, err = r._unmarshalJSONSliceTriggerDescription(fieldTriggers)
		if err != nil {
			return result, fmt.Errorf("projection: AllOf._unmarshalJSONAllOf: field Triggers; %w", err)
		}
	}
	return result, nil
}
func (r *AllOf) _unmarshalJSONSliceTriggerDescription(data []byte) ([]TriggerDescription, error) {
	result := make([]TriggerDescription, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AllOf._unmarshalJSONSliceTriggerDescription: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONTriggerDescription(v)
		if err != nil {
			return result, fmt.Errorf("projection: AllOf._unmarshalJSONSliceTriggerDescription: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *AllOf) _unmarshalJSONTriggerDescription(data []byte) (TriggerDescription, error) {
	result, err := shared.JSONUnmarshal[TriggerDescription](data)
	if err != nil {
		return result, fmt.Errorf("projection: AllOf._unmarshalJSONTriggerDescription: native ref unwrap; %w", err)
	}
	return result, nil
}

type WindowFlushModeVisitor interface {
	VisitAccumulate(v *Accumulate) any
	VisitDiscard(v *Discard) any
	VisitAccumulatingAndRetracting(v *AccumulatingAndRetracting) any
}

type WindowFlushMode interface {
	AcceptWindowFlushMode(g WindowFlushModeVisitor) any
}

var (
	_ WindowFlushMode = (*Accumulate)(nil)
	_ WindowFlushMode = (*Discard)(nil)
	_ WindowFlushMode = (*AccumulatingAndRetracting)(nil)
)

func (r *Accumulate) AcceptWindowFlushMode(v WindowFlushModeVisitor) any { return v.VisitAccumulate(r) }
func (r *Discard) AcceptWindowFlushMode(v WindowFlushModeVisitor) any    { return v.VisitDiscard(r) }
func (r *AccumulatingAndRetracting) AcceptWindowFlushMode(v WindowFlushModeVisitor) any {
	return v.VisitAccumulatingAndRetracting(r)
}

func MatchWindowFlushModeR3[T0, T1, T2 any](
	x WindowFlushMode,
	f1 func(x *Accumulate) (T0, T1, T2),
	f2 func(x *Discard) (T0, T1, T2),
	f3 func(x *AccumulatingAndRetracting) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Accumulate:
		return f1(v)
	case *Discard:
		return f2(v)
	case *AccumulatingAndRetracting:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchWindowFlushModeR2[T0, T1 any](
	x WindowFlushMode,
	f1 func(x *Accumulate) (T0, T1),
	f2 func(x *Discard) (T0, T1),
	f3 func(x *AccumulatingAndRetracting) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Accumulate:
		return f1(v)
	case *Discard:
		return f2(v)
	case *AccumulatingAndRetracting:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchWindowFlushModeR1[T0 any](
	x WindowFlushMode,
	f1 func(x *Accumulate) T0,
	f2 func(x *Discard) T0,
	f3 func(x *AccumulatingAndRetracting) T0,
) T0 {
	switch v := x.(type) {
	case *Accumulate:
		return f1(v)
	case *Discard:
		return f2(v)
	case *AccumulatingAndRetracting:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchWindowFlushModeR0(
	x WindowFlushMode,
	f1 func(x *Accumulate),
	f2 func(x *Discard),
	f3 func(x *AccumulatingAndRetracting),
) {
	switch v := x.(type) {
	case *Accumulate:
		f1(v)
	case *Discard:
		f2(v)
	case *AccumulatingAndRetracting:
		f3(v)
	}
}

func WindowFlushModeShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "WindowFlushMode",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Variant: []shape.Shape{
			AccumulateShape(),
			DiscardShape(),
			AccumulatingAndRetractingShape(),
		},
	}
}

func AccumulateShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Accumulate",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "AllowLateArrival",
				Type: &shape.RefName{
					Name:          "Duration",
					PkgName:       "time",
					PkgImportName: "time",
				},
			},
		},
	}
}

func DiscardShape() shape.Shape {
	return &shape.StructLike{
		Name:          "Discard",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
	}
}

func AccumulatingAndRetractingShape() shape.Shape {
	return &shape.StructLike{
		Name:          "AccumulatingAndRetracting",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "AllowLateArrival",
				Type: &shape.RefName{
					Name:          "Duration",
					PkgName:       "time",
					PkgImportName: "time",
				},
			},
		},
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.WindowFlushMode", WindowFlushModeFromJSON, WindowFlushModeToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.Accumulate", AccumulateFromJSON, AccumulateToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.Discard", DiscardFromJSON, DiscardToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.AccumulatingAndRetracting", AccumulatingAndRetractingFromJSON, AccumulatingAndRetractingToJSON)
}

type WindowFlushModeUnionJSON struct {
	Type                      string          `json:"$type,omitempty"`
	Accumulate                json.RawMessage `json:"projection.Accumulate,omitempty"`
	Discard                   json.RawMessage `json:"projection.Discard,omitempty"`
	AccumulatingAndRetracting json.RawMessage `json:"projection.AccumulatingAndRetracting,omitempty"`
}

func WindowFlushModeFromJSON(x []byte) (WindowFlushMode, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data WindowFlushModeUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "projection.Accumulate":
		return AccumulateFromJSON(data.Accumulate)
	case "projection.Discard":
		return DiscardFromJSON(data.Discard)
	case "projection.AccumulatingAndRetracting":
		return AccumulatingAndRetractingFromJSON(data.AccumulatingAndRetracting)
	}

	if data.Accumulate != nil {
		return AccumulateFromJSON(data.Accumulate)
	} else if data.Discard != nil {
		return DiscardFromJSON(data.Discard)
	} else if data.AccumulatingAndRetracting != nil {
		return AccumulatingAndRetractingFromJSON(data.AccumulatingAndRetracting)
	}

	return nil, fmt.Errorf("projection.WindowFlushMode: unknown type %s", data.Type)
}

func WindowFlushModeToJSON(x WindowFlushMode) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MatchWindowFlushModeR2(
		x,
		func(x *Accumulate) ([]byte, error) {
			body, err := AccumulateToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(WindowFlushModeUnionJSON{
				Type:       "projection.Accumulate",
				Accumulate: body,
			})
		},
		func(x *Discard) ([]byte, error) {
			body, err := DiscardToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(WindowFlushModeUnionJSON{
				Type:    "projection.Discard",
				Discard: body,
			})
		},
		func(x *AccumulatingAndRetracting) ([]byte, error) {
			body, err := AccumulatingAndRetractingToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(WindowFlushModeUnionJSON{
				Type:                      "projection.AccumulatingAndRetracting",
				AccumulatingAndRetracting: body,
			})
		},
	)
}

func AccumulateFromJSON(x []byte) (*Accumulate, error) {
	result := new(Accumulate)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AccumulateToJSON(x *Accumulate) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Accumulate)(nil)
	_ json.Marshaler   = (*Accumulate)(nil)
)

func (r *Accumulate) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAccumulate(*r)
}
func (r *Accumulate) _marshalJSONAccumulate(x Accumulate) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldAllowLateArrival []byte
	fieldAllowLateArrival, err = r._marshalJSONtime_Duration(x.AllowLateArrival)
	if err != nil {
		return nil, fmt.Errorf("projection: Accumulate._marshalJSONAccumulate: field name AllowLateArrival; %w", err)
	}
	partial["AllowLateArrival"] = fieldAllowLateArrival
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: Accumulate._marshalJSONAccumulate: struct; %w", err)
	}
	return result, nil
}
func (r *Accumulate) _marshalJSONtime_Duration(x time.Duration) ([]byte, error) {
	result, err := shared.JSONMarshal[time.Duration](x)
	if err != nil {
		return nil, fmt.Errorf("projection: Accumulate._marshalJSONtime_Duration:; %w", err)
	}
	return result, nil
}
func (r *Accumulate) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAccumulate(data)
	if err != nil {
		return fmt.Errorf("projection: Accumulate.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Accumulate) _unmarshalJSONAccumulate(data []byte) (Accumulate, error) {
	result := Accumulate{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: Accumulate._unmarshalJSONAccumulate: native struct unwrap; %w", err)
	}
	if fieldAllowLateArrival, ok := partial["AllowLateArrival"]; ok {
		result.AllowLateArrival, err = r._unmarshalJSONtime_Duration(fieldAllowLateArrival)
		if err != nil {
			return result, fmt.Errorf("projection: Accumulate._unmarshalJSONAccumulate: field AllowLateArrival; %w", err)
		}
	}
	return result, nil
}
func (r *Accumulate) _unmarshalJSONtime_Duration(data []byte) (time.Duration, error) {
	result, err := shared.JSONUnmarshal[time.Duration](data)
	if err != nil {
		return result, fmt.Errorf("projection: Accumulate._unmarshalJSONtime_Duration: native ref unwrap; %w", err)
	}
	return result, nil
}

func DiscardFromJSON(x []byte) (*Discard, error) {
	result := new(Discard)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func DiscardToJSON(x *Discard) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Discard)(nil)
	_ json.Marshaler   = (*Discard)(nil)
)

func (r *Discard) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDiscard(*r)
}
func (r *Discard) _marshalJSONDiscard(x Discard) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: Discard._marshalJSONDiscard: struct; %w", err)
	}
	return result, nil
}
func (r *Discard) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDiscard(data)
	if err != nil {
		return fmt.Errorf("projection: Discard.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Discard) _unmarshalJSONDiscard(data []byte) (Discard, error) {
	result := Discard{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: Discard._unmarshalJSONDiscard: native struct unwrap; %w", err)
	}
	return result, nil
}

func AccumulatingAndRetractingFromJSON(x []byte) (*AccumulatingAndRetracting, error) {
	result := new(AccumulatingAndRetracting)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func AccumulatingAndRetractingToJSON(x *AccumulatingAndRetracting) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*AccumulatingAndRetracting)(nil)
	_ json.Marshaler   = (*AccumulatingAndRetracting)(nil)
)

func (r *AccumulatingAndRetracting) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAccumulatingAndRetracting(*r)
}
func (r *AccumulatingAndRetracting) _marshalJSONAccumulatingAndRetracting(x AccumulatingAndRetracting) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldAllowLateArrival []byte
	fieldAllowLateArrival, err = r._marshalJSONtime_Duration(x.AllowLateArrival)
	if err != nil {
		return nil, fmt.Errorf("projection: AccumulatingAndRetracting._marshalJSONAccumulatingAndRetracting: field name AllowLateArrival; %w", err)
	}
	partial["AllowLateArrival"] = fieldAllowLateArrival
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: AccumulatingAndRetracting._marshalJSONAccumulatingAndRetracting: struct; %w", err)
	}
	return result, nil
}
func (r *AccumulatingAndRetracting) _marshalJSONtime_Duration(x time.Duration) ([]byte, error) {
	result, err := shared.JSONMarshal[time.Duration](x)
	if err != nil {
		return nil, fmt.Errorf("projection: AccumulatingAndRetracting._marshalJSONtime_Duration:; %w", err)
	}
	return result, nil
}
func (r *AccumulatingAndRetracting) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAccumulatingAndRetracting(data)
	if err != nil {
		return fmt.Errorf("projection: AccumulatingAndRetracting.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *AccumulatingAndRetracting) _unmarshalJSONAccumulatingAndRetracting(data []byte) (AccumulatingAndRetracting, error) {
	result := AccumulatingAndRetracting{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: AccumulatingAndRetracting._unmarshalJSONAccumulatingAndRetracting: native struct unwrap; %w", err)
	}
	if fieldAllowLateArrival, ok := partial["AllowLateArrival"]; ok {
		result.AllowLateArrival, err = r._unmarshalJSONtime_Duration(fieldAllowLateArrival)
		if err != nil {
			return result, fmt.Errorf("projection: AccumulatingAndRetracting._unmarshalJSONAccumulatingAndRetracting: field AllowLateArrival; %w", err)
		}
	}
	return result, nil
}
func (r *AccumulatingAndRetracting) _unmarshalJSONtime_Duration(data []byte) (time.Duration, error) {
	result, err := shared.JSONUnmarshal[time.Duration](data)
	if err != nil {
		return result, fmt.Errorf("projection: AccumulatingAndRetracting._unmarshalJSONtime_Duration: native ref unwrap; %w", err)
	}
	return result, nil
}
