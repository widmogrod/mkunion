// Code generated by mkunion. DO NOT EDIT.
package projection

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shape"
	"github.com/widmogrod/mkunion/x/shared"
)

func init() {
	shape.Register(NodeShape())
	shape.Register(DoWindowShape())
	shape.Register(DoMapShape())
	shape.Register(DoLoadShape())
	shape.Register(DoJoinShape())
}

type NodeVisitor interface {
	VisitDoWindow(v *DoWindow) any
	VisitDoMap(v *DoMap) any
	VisitDoLoad(v *DoLoad) any
	VisitDoJoin(v *DoJoin) any
}

type Node interface {
	AcceptNode(g NodeVisitor) any
}

var (
	_ Node = (*DoWindow)(nil)
	_ Node = (*DoMap)(nil)
	_ Node = (*DoLoad)(nil)
	_ Node = (*DoJoin)(nil)
)

func (r *DoWindow) AcceptNode(v NodeVisitor) any { return v.VisitDoWindow(r) }
func (r *DoMap) AcceptNode(v NodeVisitor) any    { return v.VisitDoMap(r) }
func (r *DoLoad) AcceptNode(v NodeVisitor) any   { return v.VisitDoLoad(r) }
func (r *DoJoin) AcceptNode(v NodeVisitor) any   { return v.VisitDoJoin(r) }

func MatchNodeR3[T0, T1, T2 any](
	x Node,
	f1 func(x *DoWindow) (T0, T1, T2),
	f2 func(x *DoMap) (T0, T1, T2),
	f3 func(x *DoLoad) (T0, T1, T2),
	f4 func(x *DoJoin) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *DoWindow:
		return f1(v)
	case *DoMap:
		return f2(v)
	case *DoLoad:
		return f3(v)
	case *DoJoin:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchNodeR2[T0, T1 any](
	x Node,
	f1 func(x *DoWindow) (T0, T1),
	f2 func(x *DoMap) (T0, T1),
	f3 func(x *DoLoad) (T0, T1),
	f4 func(x *DoJoin) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *DoWindow:
		return f1(v)
	case *DoMap:
		return f2(v)
	case *DoLoad:
		return f3(v)
	case *DoJoin:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchNodeR1[T0 any](
	x Node,
	f1 func(x *DoWindow) T0,
	f2 func(x *DoMap) T0,
	f3 func(x *DoLoad) T0,
	f4 func(x *DoJoin) T0,
) T0 {
	switch v := x.(type) {
	case *DoWindow:
		return f1(v)
	case *DoMap:
		return f2(v)
	case *DoLoad:
		return f3(v)
	case *DoJoin:
		return f4(v)
	}
	var result1 T0
	return result1
}

func MatchNodeR0(
	x Node,
	f1 func(x *DoWindow),
	f2 func(x *DoMap),
	f3 func(x *DoLoad),
	f4 func(x *DoJoin),
) {
	switch v := x.(type) {
	case *DoWindow:
		f1(v)
	case *DoMap:
		f2(v)
	case *DoLoad:
		f3(v)
	case *DoJoin:
		f4(v)
	}
}

func NodeShape() shape.Shape {
	return &shape.UnionLike{
		Name:          "Node",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Variant: []shape.Shape{
			DoWindowShape(),
			DoMapShape(),
			DoLoadShape(),
			DoJoinShape(),
		},
	}
}

func DoWindowShape() shape.Shape {
	return &shape.StructLike{
		Name:          "DoWindow",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Ctx",
				Type: &shape.PointerLike{
					Type: &shape.RefName{
						Name:          "DefaultContext",
						PkgName:       "projection",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
					},
				},
			},
			{
				Name: "Input",
				Type: &shape.RefName{
					Name:          "Node",
					PkgName:       "projection",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
				},
			},
		},
	}
}

func DoMapShape() shape.Shape {
	return &shape.StructLike{
		Name:          "DoMap",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Ctx",
				Type: &shape.PointerLike{
					Type: &shape.RefName{
						Name:          "DefaultContext",
						PkgName:       "projection",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
					},
				},
			},
			{
				Name: "OnMap",
				Type: &shape.RefName{
					Name:          "Handler",
					PkgName:       "projection",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
				},
			},
			{
				Name: "Input",
				Type: &shape.RefName{
					Name:          "Node",
					PkgName:       "projection",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
				},
			},
		},
	}
}

func DoLoadShape() shape.Shape {
	return &shape.StructLike{
		Name:          "DoLoad",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Ctx",
				Type: &shape.PointerLike{
					Type: &shape.RefName{
						Name:          "DefaultContext",
						PkgName:       "projection",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
					},
				},
			},
			{
				Name: "OnLoad",
				Type: &shape.RefName{
					Name:          "Handler",
					PkgName:       "projection",
					PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
				},
			},
		},
	}
}

func DoJoinShape() shape.Shape {
	return &shape.StructLike{
		Name:          "DoJoin",
		PkgName:       "projection",
		PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
		Fields: []*shape.FieldLike{
			{
				Name: "Ctx",
				Type: &shape.PointerLike{
					Type: &shape.RefName{
						Name:          "DefaultContext",
						PkgName:       "projection",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
					},
				},
			},
			{
				Name: "Input",
				Type: &shape.ListLike{
					Element: &shape.RefName{
						Name:          "Node",
						PkgName:       "projection",
						PkgImportName: "github.com/widmogrod/mkunion/x/storage/schemaless/projection",
					},
				},
			},
		},
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.Node", NodeFromJSON, NodeToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoWindow", DoWindowFromJSON, DoWindowToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoMap", DoMapFromJSON, DoMapToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoLoad", DoLoadFromJSON, DoLoadToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/x/storage/schemaless/projection.DoJoin", DoJoinFromJSON, DoJoinToJSON)
}

type NodeUnionJSON struct {
	Type     string          `json:"$type,omitempty"`
	DoWindow json.RawMessage `json:"projection.DoWindow,omitempty"`
	DoMap    json.RawMessage `json:"projection.DoMap,omitempty"`
	DoLoad   json.RawMessage `json:"projection.DoLoad,omitempty"`
	DoJoin   json.RawMessage `json:"projection.DoJoin,omitempty"`
}

func NodeFromJSON(x []byte) (Node, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}

	var data NodeUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, err
	}

	switch data.Type {
	case "projection.DoWindow":
		return DoWindowFromJSON(data.DoWindow)
	case "projection.DoMap":
		return DoMapFromJSON(data.DoMap)
	case "projection.DoLoad":
		return DoLoadFromJSON(data.DoLoad)
	case "projection.DoJoin":
		return DoJoinFromJSON(data.DoJoin)
	}

	if data.DoWindow != nil {
		return DoWindowFromJSON(data.DoWindow)
	} else if data.DoMap != nil {
		return DoMapFromJSON(data.DoMap)
	} else if data.DoLoad != nil {
		return DoLoadFromJSON(data.DoLoad)
	} else if data.DoJoin != nil {
		return DoJoinFromJSON(data.DoJoin)
	}

	return nil, fmt.Errorf("projection.Node: unknown type %s", data.Type)
}

func NodeToJSON(x Node) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return MatchNodeR2(
		x,
		func(x *DoWindow) ([]byte, error) {
			body, err := DoWindowToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(NodeUnionJSON{
				Type:     "projection.DoWindow",
				DoWindow: body,
			})
		},
		func(x *DoMap) ([]byte, error) {
			body, err := DoMapToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(NodeUnionJSON{
				Type:  "projection.DoMap",
				DoMap: body,
			})
		},
		func(x *DoLoad) ([]byte, error) {
			body, err := DoLoadToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(NodeUnionJSON{
				Type:   "projection.DoLoad",
				DoLoad: body,
			})
		},
		func(x *DoJoin) ([]byte, error) {
			body, err := DoJoinToJSON(x)
			if err != nil {
				return nil, err
			}

			return json.Marshal(NodeUnionJSON{
				Type:   "projection.DoJoin",
				DoJoin: body,
			})
		},
	)
}

func DoWindowFromJSON(x []byte) (*DoWindow, error) {
	result := new(DoWindow)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func DoWindowToJSON(x *DoWindow) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoWindow)(nil)
	_ json.Marshaler   = (*DoWindow)(nil)
)

func (r *DoWindow) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoWindow(*r)
}
func (r *DoWindow) _marshalJSONDoWindow(x DoWindow) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDoWindow: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldInput []byte
	fieldInput, err = r._marshalJSONNode(x.Input)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDoWindow: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDoWindow: struct; %w", err)
	}
	return result, nil
}
func (r *DoWindow) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoWindow) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoWindow) _marshalJSONNode(x Node) ([]byte, error) {
	result, err := shared.JSONMarshal[Node](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._marshalJSONNode:; %w", err)
	}
	return result, nil
}
func (r *DoWindow) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoWindow(data)
	if err != nil {
		return fmt.Errorf("projection: DoWindow.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoWindow) _unmarshalJSONDoWindow(data []byte) (DoWindow, error) {
	result := DoWindow{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDoWindow: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDoWindow: field Ctx; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONNode(fieldInput)
		if err != nil {
			return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDoWindow: field Input; %w", err)
		}
	}
	return result, nil
}
func (r *DoWindow) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoWindow._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoWindow) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoWindow._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoWindow) _unmarshalJSONNode(data []byte) (Node, error) {
	result, err := shared.JSONUnmarshal[Node](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoWindow._unmarshalJSONNode: native ref unwrap; %w", err)
	}
	return result, nil
}

func DoMapFromJSON(x []byte) (*DoMap, error) {
	result := new(DoMap)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func DoMapToJSON(x *DoMap) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoMap)(nil)
	_ json.Marshaler   = (*DoMap)(nil)
)

func (r *DoMap) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoMap(*r)
}
func (r *DoMap) _marshalJSONDoMap(x DoMap) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldOnMap []byte
	fieldOnMap, err = r._marshalJSONHandler(x.OnMap)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: field name OnMap; %w", err)
	}
	partial["OnMap"] = fieldOnMap
	var fieldInput []byte
	fieldInput, err = r._marshalJSONNode(x.Input)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDoMap: struct; %w", err)
	}
	return result, nil
}
func (r *DoMap) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoMap) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoMap) _marshalJSONHandler(x Handler) ([]byte, error) {
	result, err := shared.JSONMarshal[Handler](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONHandler:; %w", err)
	}
	return result, nil
}
func (r *DoMap) _marshalJSONNode(x Node) ([]byte, error) {
	result, err := shared.JSONMarshal[Node](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._marshalJSONNode:; %w", err)
	}
	return result, nil
}
func (r *DoMap) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoMap(data)
	if err != nil {
		return fmt.Errorf("projection: DoMap.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoMap) _unmarshalJSONDoMap(data []byte) (DoMap, error) {
	result := DoMap{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: field Ctx; %w", err)
		}
	}
	if fieldOnMap, ok := partial["OnMap"]; ok {
		result.OnMap, err = r._unmarshalJSONHandler(fieldOnMap)
		if err != nil {
			return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: field OnMap; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONNode(fieldInput)
		if err != nil {
			return result, fmt.Errorf("projection: DoMap._unmarshalJSONDoMap: field Input; %w", err)
		}
	}
	return result, nil
}
func (r *DoMap) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoMap._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoMap) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoMap) _unmarshalJSONHandler(data []byte) (Handler, error) {
	result, err := shared.JSONUnmarshal[Handler](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONHandler: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoMap) _unmarshalJSONNode(data []byte) (Node, error) {
	result, err := shared.JSONUnmarshal[Node](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoMap._unmarshalJSONNode: native ref unwrap; %w", err)
	}
	return result, nil
}

func DoLoadFromJSON(x []byte) (*DoLoad, error) {
	result := new(DoLoad)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func DoLoadToJSON(x *DoLoad) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoLoad)(nil)
	_ json.Marshaler   = (*DoLoad)(nil)
)

func (r *DoLoad) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoLoad(*r)
}
func (r *DoLoad) _marshalJSONDoLoad(x DoLoad) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDoLoad: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldOnLoad []byte
	fieldOnLoad, err = r._marshalJSONHandler(x.OnLoad)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDoLoad: field name OnLoad; %w", err)
	}
	partial["OnLoad"] = fieldOnLoad
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDoLoad: struct; %w", err)
	}
	return result, nil
}
func (r *DoLoad) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoLoad) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoLoad) _marshalJSONHandler(x Handler) ([]byte, error) {
	result, err := shared.JSONMarshal[Handler](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._marshalJSONHandler:; %w", err)
	}
	return result, nil
}
func (r *DoLoad) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoLoad(data)
	if err != nil {
		return fmt.Errorf("projection: DoLoad.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoLoad) _unmarshalJSONDoLoad(data []byte) (DoLoad, error) {
	result := DoLoad{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDoLoad: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDoLoad: field Ctx; %w", err)
		}
	}
	if fieldOnLoad, ok := partial["OnLoad"]; ok {
		result.OnLoad, err = r._unmarshalJSONHandler(fieldOnLoad)
		if err != nil {
			return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDoLoad: field OnLoad; %w", err)
		}
	}
	return result, nil
}
func (r *DoLoad) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoLoad._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoLoad) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoLoad._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoLoad) _unmarshalJSONHandler(data []byte) (Handler, error) {
	result, err := shared.JSONUnmarshal[Handler](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoLoad._unmarshalJSONHandler: native ref unwrap; %w", err)
	}
	return result, nil
}

func DoJoinFromJSON(x []byte) (*DoJoin, error) {
	result := new(DoJoin)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, err
	}

	return result, nil
}

func DoJoinToJSON(x *DoJoin) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*DoJoin)(nil)
	_ json.Marshaler   = (*DoJoin)(nil)
)

func (r *DoJoin) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDoJoin(*r)
}
func (r *DoJoin) _marshalJSONDoJoin(x DoJoin) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCtx []byte
	fieldCtx, err = r._marshalJSONPtrDefaultContext(x.Ctx)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDoJoin: field name Ctx; %w", err)
	}
	if fieldCtx != nil {
		partial["Ctx"] = fieldCtx
	}
	var fieldInput []byte
	fieldInput, err = r._marshalJSONSliceNode(x.Input)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDoJoin: field name Input; %w", err)
	}
	partial["Input"] = fieldInput
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDoJoin: struct; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _marshalJSONPtrDefaultContext(x *DefaultContext) ([]byte, error) {
	if x == nil {
		return nil, nil
	}
	return r._marshalJSONDefaultContext(*x)
}
func (r *DoJoin) _marshalJSONDefaultContext(x DefaultContext) ([]byte, error) {
	result, err := shared.JSONMarshal[DefaultContext](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONDefaultContext:; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _marshalJSONSliceNode(x []Node) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONNode(v)
		if err != nil {
			return nil, fmt.Errorf("projection: DoJoin._marshalJSONSliceNode: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONSliceNode:; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _marshalJSONNode(x Node) ([]byte, error) {
	result, err := shared.JSONMarshal[Node](x)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._marshalJSONNode:; %w", err)
	}
	return result, nil
}
func (r *DoJoin) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDoJoin(data)
	if err != nil {
		return fmt.Errorf("projection: DoJoin.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *DoJoin) _unmarshalJSONDoJoin(data []byte) (DoJoin, error) {
	result := DoJoin{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDoJoin: native struct unwrap; %w", err)
	}
	if fieldCtx, ok := partial["Ctx"]; ok {
		result.Ctx, err = r._unmarshalJSONPtrDefaultContext(fieldCtx)
		if err != nil {
			return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDoJoin: field Ctx; %w", err)
		}
	}
	if fieldInput, ok := partial["Input"]; ok {
		result.Input, err = r._unmarshalJSONSliceNode(fieldInput)
		if err != nil {
			return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDoJoin: field Input; %w", err)
		}
	}
	return result, nil
}
func (r *DoJoin) _unmarshalJSONPtrDefaultContext(data []byte) (*DefaultContext, error) {
	if len(data) == 0 {
		return nil, nil
	}
	if string(data[:4]) == "null" {
		return nil, nil
	}
	result, err := r._unmarshalJSONDefaultContext(data)
	if err != nil {
		return nil, fmt.Errorf("projection: DoJoin._unmarshalJSONPtrDefaultContext: pointer; %w", err)
	}
	return &result, nil
}
func (r *DoJoin) _unmarshalJSONDefaultContext(data []byte) (DefaultContext, error) {
	result, err := shared.JSONUnmarshal[DefaultContext](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONDefaultContext: native ref unwrap; %w", err)
	}
	return result, nil
}
func (r *DoJoin) _unmarshalJSONSliceNode(data []byte) ([]Node, error) {
	result := make([]Node, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONSliceNode: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONNode(v)
		if err != nil {
			return result, fmt.Errorf("projection: DoJoin._unmarshalJSONSliceNode: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *DoJoin) _unmarshalJSONNode(data []byte) (Node, error) {
	result, err := shared.JSONUnmarshal[Node](data)
	if err != nil {
		return result, fmt.Errorf("projection: DoJoin._unmarshalJSONNode: native ref unwrap; %w", err)
	}
	return result, nil
}
