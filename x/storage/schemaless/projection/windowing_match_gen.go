// Code generated by mkunion. DO NOT EDIT.
package projection

func EvaluateTriggerR0[T0 TriggerDescription, T1 TriggerType](
	t0 T0,
	t1 T1,
	f0 func(x0 *AtPeriod, x1 *AtPeriod),
	f1 func(x0 *AtWindowItemSize, x1 *AtWindowItemSize),
	f2 func(x0 *AtWatermark, x1 *AtWatermark),
	f3 func(x0 *AnyOf, x1 TriggerType),
	f4 func(x0 *AllOf, x1 TriggerType),
	f5 func(x0 T0, x1 T1),
) {
	c0t0, c0t0ok := any(t0).(*AtPeriod)
	c0t1, c0t1ok := any(t1).(*AtPeriod)
	if c0t0ok && c0t1ok {
		f0(c0t0, c0t1)
		return
	}
	c1t0, c1t0ok := any(t0).(*AtWindowItemSize)
	c1t1, c1t1ok := any(t1).(*AtWindowItemSize)
	if c1t0ok && c1t1ok {
		f1(c1t0, c1t1)
		return
	}
	c2t0, c2t0ok := any(t0).(*AtWatermark)
	c2t1, c2t1ok := any(t1).(*AtWatermark)
	if c2t0ok && c2t1ok {
		f2(c2t0, c2t1)
		return
	}
	c3t0, c3t0ok := any(t0).(*AnyOf)
	c3t1, c3t1ok := any(t1).(TriggerType)
	if c3t0ok && c3t1ok {
		f3(c3t0, c3t1)
		return
	}
	c4t0, c4t0ok := any(t0).(*AllOf)
	c4t1, c4t1ok := any(t1).(TriggerType)
	if c4t0ok && c4t1ok {
		f4(c4t0, c4t1)
		return
	}
	c5t0, c5t0ok := any(t0).(T0)
	c5t1, c5t1ok := any(t1).(T1)
	if c5t0ok && c5t1ok {
		f5(c5t0, c5t1)
		return
	}
	panic("EvaluateTriggerR0 is not exhaustive")
}

func EvaluateTriggerR1[T0 TriggerDescription, T1 TriggerType, TOut1 any](
	t0 T0,
	t1 T1,
	f0 func(x0 *AtPeriod, x1 *AtPeriod) TOut1,
	f1 func(x0 *AtWindowItemSize, x1 *AtWindowItemSize) TOut1,
	f2 func(x0 *AtWatermark, x1 *AtWatermark) TOut1,
	f3 func(x0 *AnyOf, x1 TriggerType) TOut1,
	f4 func(x0 *AllOf, x1 TriggerType) TOut1,
	f5 func(x0 T0, x1 T1) TOut1,
) TOut1 {
	c0t0, c0t0ok := any(t0).(*AtPeriod)
	c0t1, c0t1ok := any(t1).(*AtPeriod)
	if c0t0ok && c0t1ok {
		return f0(c0t0, c0t1)
	}
	c1t0, c1t0ok := any(t0).(*AtWindowItemSize)
	c1t1, c1t1ok := any(t1).(*AtWindowItemSize)
	if c1t0ok && c1t1ok {
		return f1(c1t0, c1t1)
	}
	c2t0, c2t0ok := any(t0).(*AtWatermark)
	c2t1, c2t1ok := any(t1).(*AtWatermark)
	if c2t0ok && c2t1ok {
		return f2(c2t0, c2t1)
	}
	c3t0, c3t0ok := any(t0).(*AnyOf)
	c3t1, c3t1ok := any(t1).(TriggerType)
	if c3t0ok && c3t1ok {
		return f3(c3t0, c3t1)
	}
	c4t0, c4t0ok := any(t0).(*AllOf)
	c4t1, c4t1ok := any(t1).(TriggerType)
	if c4t0ok && c4t1ok {
		return f4(c4t0, c4t1)
	}
	c5t0, c5t0ok := any(t0).(T0)
	c5t1, c5t1ok := any(t1).(T1)
	if c5t0ok && c5t1ok {
		return f5(c5t0, c5t1)
	}
	panic("EvaluateTriggerR1 is not exhaustive")
}

func EvaluateTriggerR2[T0 TriggerDescription, T1 TriggerType, TOut1 any, TOut2 any](
	t0 T0,
	t1 T1,
	f0 func(x0 *AtPeriod, x1 *AtPeriod) (TOut1, TOut2),
	f1 func(x0 *AtWindowItemSize, x1 *AtWindowItemSize) (TOut1, TOut2),
	f2 func(x0 *AtWatermark, x1 *AtWatermark) (TOut1, TOut2),
	f3 func(x0 *AnyOf, x1 TriggerType) (TOut1, TOut2),
	f4 func(x0 *AllOf, x1 TriggerType) (TOut1, TOut2),
	f5 func(x0 T0, x1 T1) (TOut1, TOut2),
) (TOut1, TOut2) {
	c0t0, c0t0ok := any(t0).(*AtPeriod)
	c0t1, c0t1ok := any(t1).(*AtPeriod)
	if c0t0ok && c0t1ok {
		return f0(c0t0, c0t1)
	}
	c1t0, c1t0ok := any(t0).(*AtWindowItemSize)
	c1t1, c1t1ok := any(t1).(*AtWindowItemSize)
	if c1t0ok && c1t1ok {
		return f1(c1t0, c1t1)
	}
	c2t0, c2t0ok := any(t0).(*AtWatermark)
	c2t1, c2t1ok := any(t1).(*AtWatermark)
	if c2t0ok && c2t1ok {
		return f2(c2t0, c2t1)
	}
	c3t0, c3t0ok := any(t0).(*AnyOf)
	c3t1, c3t1ok := any(t1).(TriggerType)
	if c3t0ok && c3t1ok {
		return f3(c3t0, c3t1)
	}
	c4t0, c4t0ok := any(t0).(*AllOf)
	c4t1, c4t1ok := any(t1).(TriggerType)
	if c4t0ok && c4t1ok {
		return f4(c4t0, c4t1)
	}
	c5t0, c5t0ok := any(t0).(T0)
	c5t1, c5t1ok := any(t1).(T1)
	if c5t0ok && c5t1ok {
		return f5(c5t0, c5t1)
	}
	panic("EvaluateTriggerR2 is not exhaustive")
}

func EvaluateTriggerR3[T0 TriggerDescription, T1 TriggerType, TOut1 any, TOut2 any, TOut3 any](
	t0 T0,
	t1 T1,
	f0 func(x0 *AtPeriod, x1 *AtPeriod) (TOut1, TOut2, TOut3),
	f1 func(x0 *AtWindowItemSize, x1 *AtWindowItemSize) (TOut1, TOut2, TOut3),
	f2 func(x0 *AtWatermark, x1 *AtWatermark) (TOut1, TOut2, TOut3),
	f3 func(x0 *AnyOf, x1 TriggerType) (TOut1, TOut2, TOut3),
	f4 func(x0 *AllOf, x1 TriggerType) (TOut1, TOut2, TOut3),
	f5 func(x0 T0, x1 T1) (TOut1, TOut2, TOut3),
) (TOut1, TOut2, TOut3) {
	c0t0, c0t0ok := any(t0).(*AtPeriod)
	c0t1, c0t1ok := any(t1).(*AtPeriod)
	if c0t0ok && c0t1ok {
		return f0(c0t0, c0t1)
	}
	c1t0, c1t0ok := any(t0).(*AtWindowItemSize)
	c1t1, c1t1ok := any(t1).(*AtWindowItemSize)
	if c1t0ok && c1t1ok {
		return f1(c1t0, c1t1)
	}
	c2t0, c2t0ok := any(t0).(*AtWatermark)
	c2t1, c2t1ok := any(t1).(*AtWatermark)
	if c2t0ok && c2t1ok {
		return f2(c2t0, c2t1)
	}
	c3t0, c3t0ok := any(t0).(*AnyOf)
	c3t1, c3t1ok := any(t1).(TriggerType)
	if c3t0ok && c3t1ok {
		return f3(c3t0, c3t1)
	}
	c4t0, c4t0ok := any(t0).(*AllOf)
	c4t1, c4t1ok := any(t1).(TriggerType)
	if c4t0ok && c4t1ok {
		return f4(c4t0, c4t1)
	}
	c5t0, c5t0ok := any(t0).(T0)
	c5t1, c5t1ok := any(t1).(T1)
	if c5t0ok && c5t1ok {
		return f5(c5t0, c5t1)
	}
	panic("EvaluateTriggerR3 is not exhaustive")
}
