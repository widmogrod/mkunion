---
title: State machines and unions
---
# MkUnion and state machines in Go

This document will show how to use `mkunion` to manage application state using the example of an Order Service. 
You will learn:

- how to model state machines in Go, and find similarities to "__clean architecture__"
- How to **test state machines** (with fuzzing), and as a bonus, you will get mermaid diagrams for free
- How to **persist state in a database** and how optimistic concurrency helps __resolve concurrency conflicts__
- How to **handle errors** in state machines and build foundations for __self-healing__ systems


## Working example

As a driving example, we will use an e-commerce inspired Order Service that can be in one of the following states:

- `Pending` - The order is created and is waiting for someone to process it.
- `Processing` - The order is being processed; a human is going to pick up items from the warehouse and pack them.
- `Cancelled` - The order was cancelled. There can be many reasons, one of them being that the warehouse is out of stock.
- `Completed` - The order is completed and can be shipped to the customer.

Such states have rules that govern **transitions**; for example, an order cannot be cancelled if it's already completed, and so on.

We need to have a way to trigger changes in state, like creating an order that is pending for processing, or cancelling an order. We will call these triggers **commands**.

Some of these rules could change in the future, and we want to be able to change them without rewriting the whole application.
This also informs us that our design should be open for extension.

Side note: if you want to go straight to the final code product, then go into the [example/state/](https://github.com/widmogrod/mkunion/tree/main/example/state) directory and have fun exploring.

## Modeling commands and states

Our example can be represented as a state machine that looks like this:
[simple_machine_test.go.state_diagram.mmd](https://github.com/widmogrod/mkunion/tree/main/example/state/simple_machine_test.go.state_diagram.mmd)
```mermaid
--8<-- "example/state/machine_test.go.state_diagram.mmd"
```

In this diagram, we can see that we have 5 states and 6 commands that can trigger transitions between states, shown as arrows.

Because this diagram is generated from code, it has names that represent types in Go that we use in the implementation. 

For example, `*state.CreateOrderCMD`:

- `state` is the package name.
- `CreateOrderCMD` is a struct name in that package.
- The `CMD` suffix is a naming convention that is optional, but I find it makes the code more readable and easier to distinguish commands from states.


Below is a code snippet that demonstrates a complete model of the **state** and **commands** of the Order Service that we discussed.

**Notice** that we use `mkunion` to group commands and states. (Look for `//go:tag mkunion:"Command"`)

This is one example of how union types can be used in Go. 
Historically in Go, it would be very hard to achieve such a thing, and it would require a lot of boilerplate code.
Here, the interface that groups these types is generated automatically. You can focus on modeling your domain.

```go title="example/state/model.go"
--8<-- "example/state/model.go"
```

## Modeling transitions
One thing that is missing is the implementation of transitions between states. 
There are a few ways to do it. I will show you how to do it using a functional approach (think `reduce` or `map` function).

Let's name the function that we will build `Transition` and define it as:

```go
func Transition(ctx context.Context, dep Dependencies, cmd Command, state State) (State, error)
```

Our function has a few arguments; let's break them down:

- `ctx` is the standard Go context, which is used to pass deadlines, cancellation signals, etc.
- `dep` encapsulates dependencies like API clients, database connections, configuration, context, etc.
   â€” everything that is needed for a complete production implementation.
- `cmd` is a command that we want to apply to the state, 
   and it has the `Command` interface, which was generated by `mkunion` when it was used to group commands.
- `state` is a state that we want to apply our command to and change, 
   and it has the `State` interface, which was generated similarly to the `Command` interface.


Our function must return either a new state or an error if something went wrong during the transition, like a network error or a validation error.

Below is a snippet of the implementation of the `Transition` function for our Order Service:

```go title="example/state/machine.go"
--8<-- "example/state/machine.go:30:81"
// ...
// rest removed for brevity 
// ...
```

You can notice a few patterns in this snippet:

- The `Dependency` interface helps us to keep dependencies well-defined, which greatly helps in testability and readability of the code. 
- The use of the generated function `MatchCommandR2` to exhaustively match all commands. 
  This is powerful; when a new command is added, you can be sure that you will get a compile-time error if you don't handle it.
- Validation of commands is done in the transition function. The current implementation is simple, but you can use go-validate to make it more robust, or refactor the code and introduce domain helper functions or methods to the types.
- Each command checks the state to which it is being applied using a `switch` statement; it ignores states that it doesn't care about. 
  This means as an implementer, you have to focus only on a small part of the picture and not worry about the rest of the states. 
  This is also an example where non-exhaustive use of the `switch` statement is welcome.

Simple, isn't it? Simplicity also comes from the fact that we don't have to worry about marshalling/unmarshalling data or working with the database; those are things that will be done in other parts of the application, keeping this part clean and focused on business logic.

Note: The implementation for educational purposes is kept in one big function, 
but for large projects, it may be better to split it into smaller functions, 
or define an `OrderService` struct that conforms to the visitor pattern interface, which was also generated for you:

```go  title="example/state/model_union_gen.go"
--8<-- "example/state/model_union_gen.go:11:17"
```

## Testing state machines & self-documenting
Before we go further, let's talk about testing our implementation.

Testing will not only help us ensure that our implementation is correct but also help us document our state machine 
and discover transitions that we didn't think about, that should or shouldn't be possible.

Here is how you can test a state machine in a declarative way, using the `mkunion/x/machine` package:

```go title="example/state/machine_test.go"
--8<-- "example/state/machine_test.go:15:151"
```
A few things to notice in this test:

- We use standard Go testing.
- We use `machine.NewTestSuite` as a standard way to test state machines.
- We start with describing the **happy path** and use `suite.Case` to define a test case.
- But most importantly, we define test cases using `GivenCommand` and `ThenState` functions, which help make the test more readable and hopefully self-documenting.
- You can see the use of the `ForkCase` command, which allows you to take the definition of a state declared in the `ThenState` command, apply a new command to it, and expect a new state.
- Less visible is the use of `moq` to generate `DependencyMock` for dependencies, but it's still important for writing more concise code.

I know it's subjective, but I find it very readable and easy to understand, even for non-programmers.

## Generating state diagram from tests
The last bit is this line at the bottom of the test file:

```go title="example/state/machine_test.go"
if suite.AssertSelfDocumentStateDiagram(t, "machine_test.go") {
   suite.SelfDocumentStateDiagram(t, "machine_test.go")
}
```

This code takes all inputs provided in the test suite and fuzzes them, applies commands to random states, and records the results of those transitions.

 - `SelfDocumentStateDiagram` - produces two `mermaid` diagrams that show all possible transitions that are possible in our state machine.
 - `AssertSelfDocumentStateDiagram` can be used to compare newly generated diagrams to diagrams committed to the repository and fail the test if they are different.
   You don't have to use it, but it's good practice to ensure that your state machine is well-tested and doesn't regress without you noticing.


There are two diagrams that are generated.

One is a diagram of ONLY successful transitions that you saw at the beginning of this post.

```mermaid 
--8<-- "example/state/machine_test.go.state_diagram.mmd"
```

Second is a diagram that includes commands that resulted in errors:
```mermaid 
--8<-- "example/state/machine_test.go.state_diagram_with_errors.mmd"
```

Those diagrams are stored in the same directory as the test file and are prefixed with the name used in the `AssertSelfDocumentStateDiagram` function.
```
machine_test.go.state_diagram.mmd
machine_test.go.state_diagram_with_errors.mmd
```

## State machines builder

MkUnion provides a `*machine.Machine[Dependency, Command, State]` struct that wires the Transition, dependencies, and state together.
It provides methods like:

- `Handle(ctx context.Context, cmd C) error` that applies a command to the state and returns an error if something went wrong during the transition.
- `State() S` that returns the current state of the machine.
- `Dep() D` that returns the dependencies the machine was built with.


This standard helps build on top of it; for example, the testing library we use in [Testing state machines & self-documenting](#testing-state-machines-self-documenting) leverages it.

Another good practice is that every package that defines a state machine in the way described here 
should provide a `NewMachine` function that will return a bootstrapped machine with package types, like so:

```go title="example/state/machine.go"
--8<-- "example/state/machine.go:9:12"
```

## Conclusion

Now we have all the pieces in place, and we can start building our application.

- We have a `NewMachine` constructor that will give us an object to use in our application.
- We have tests that will ensure that our state machine is correct; fuzzy tests help discover edge cases, and lastly, we get diagrams showing which paths we tested and covered.
- We saw how this approach focuses on business logic and keeps it separate from other concerns like the database or API clients. This is one of the principles of clean architecture.

## Best Practices

When building state machines with mkunion, following these practices will help you create maintainable and robust systems:

### Naming Conventions

1. **States**: Use descriptive nouns that clearly indicate the state (e.g., `OrderPending`, `PaymentProcessing`)
2. **Commands**: Suffix with `CMD` for clarity (e.g., `CreateOrderCMD`, `CancelOrderCMD`)
3. **Packages**: Keep state machines in dedicated packages named after the domain (e.g., `order`, `payment`)

### State Design

1. **Keep States Focused**: Each state should represent one clear condition
2. **Immutable Data**: States should contain immutable data; create new states instead of modifying
3. **Minimal State Data**: Only store data that's essential for the state's identity
4. **Use Zero Values**: Design states so Go's zero values are meaningful defaults

### Command Validation

```go
// Good: Validate commands in the transition function
func Transition(ctx context.Context, deps Dependencies, cmd Command, state State) (State, error) {
    return MatchCommandR2(cmd,
        func(c *CreateOrderCMD) (State, error) {
            // Validate command first
            if c.CustomerID == "" {
                return nil, fmt.Errorf("customer ID is required")
            }
            if len(c.Items) == 0 {
                return nil, fmt.Errorf("order must contain at least one item")
            }
            // Then check state
            // ...
        },
    )
}
```

### Dependency Management

1. **Define Clear Interfaces**: Dependencies should be interfaces, not concrete types
2. **Keep Dependencies Minimal**: Only inject what's absolutely necessary
3. **Mock Dependencies in Tests**: Use generated mocks for thorough testing

## Common Pitfalls

Avoid these common mistakes when implementing state machines:

### 1. State Explosion

**Problem**: Creating too many states for every minor variation
```go
// Bad: Too granular
type (
    OrderPendingWithOneItem struct{}
    OrderPendingWithTwoItems struct{}
    OrderPendingWithThreeItems struct{}
    // ... and so on
)
```

**Solution**: Use state data instead
```go
// Good: Single state with data
type OrderPending struct {
    Items []OrderItem
}
```

### 2. Circular Dependencies

**Problem**: States that can transition in circles without progress
```go
// Problematic: A -> B -> C -> A without any business value
```

**Solution**: Ensure each transition represents meaningful progress or explicitly document allowed cycles

### 3. Missing Error States

**Problem**: Not modeling error conditions as explicit states
```go
// Bad: Errors only in transition function
return nil, fmt.Errorf("payment failed")
```

**Solution**: Model error conditions as states when they need handling
```go
// Good: Explicit error state
type PaymentFailed struct {
    Reason string
    FailedAt time.Time
}
```

### 4. Ignoring Concurrency

**Problem**: Not considering concurrent command execution
```go
// Risky: No concurrency control
machine.Handle(ctx, cmd1) // From goroutine 1
machine.Handle(ctx, cmd2) // From goroutine 2 simultaneously
```

**Solution**: Use proper synchronization or event sourcing patterns (see [state storage](state_storage.md))

### 5. Overloading Transitions

**Problem**: Putting too much business logic in transition functions
```go
// Bad: Transition function doing too much
func Transition(...) (State, error) {
    // Send emails
    // Update inventory
    // Calculate prices
    // Log to external systems
    // ... 200 lines later
}
```

**Solution**: Keep transitions focused on state changes; delegate side effects to dependencies

## Advanced Patterns

### State Machine Composition

For complex systems, compose multiple state machines:

```go
// Order state machine
type OrderMachine struct {
    *machine.Machine[OrderDeps, OrderCommand, OrderState]
}

// Payment state machine  
type PaymentMachine struct {
    *machine.Machine[PaymentDeps, PaymentCommand, PaymentState]
}

// Composed e-commerce flow
type ECommerceMachine struct {
    Order   *OrderMachine
    Payment *PaymentMachine
}

func (e *ECommerceMachine) ProcessOrder(ctx context.Context, orderCmd OrderCommand) error {
    // Handle order state change
    if err := e.Order.Handle(ctx, orderCmd); err != nil {
        return err
    }
    
    // If order is confirmed, trigger payment
    if _, ok := e.Order.State().(*OrderConfirmed); ok {
        return e.Payment.Handle(ctx, &InitiatePaymentCMD{})
    }
    
    return nil
}
```

### Async Operations with Callbacks

Handle long-running operations without blocking:

```go
//go:tag mkunion:"AsyncState"
type (
    OperationPending struct {
        ID        string
        StartedAt time.Time
    }
    OperationComplete struct {
        ID       string
        Result   interface{}
        Duration time.Duration
    }
)

//go:tag mkunion:"AsyncCommand"
type (
    StartAsyncCMD struct {
        ID string
    }
    CompleteAsyncCMD struct {
        ID     string
        Result interface{}
    }
)

// Transition starts async operation
func Transition(ctx context.Context, deps AsyncDeps, cmd AsyncCommand, state AsyncState) (AsyncState, error) {
    return MatchAsyncCommandR2(cmd,
        func(c *StartAsyncCMD) (AsyncState, error) {
            // Start async operation
            go deps.AsyncWorker(c.ID, func(result interface{}, err error) {
                // Callback to complete
                completeCMD := &CompleteAsyncCMD{
                    ID:     c.ID,
                    Result: result,
                }
                deps.CommandQueue.Enqueue(completeCMD)
            })
            
            return &OperationPending{
                ID:        c.ID,
                StartedAt: time.Now(),
            }, nil
        },
        // ... handle completion
    )
}
```

### Time-Based Transitions

Implement timeouts and scheduled transitions:

```go
//go:tag mkunion:"TimerCommand"  
type (
    TimeoutCMD struct {
        Reason string
    }
)

// Set up timeout when entering a state
func SetupStateTimeouts(m *machine.Machine[Deps, Command, State], timeout time.Duration) {
    go func() {
        timer := time.NewTimer(timeout)
        defer timer.Stop()
        
        select {
        case <-timer.C:
            m.Handle(context.Background(), &TimeoutCMD{
                Reason: "operation timeout",
            })
        case <-m.Done():
            return
        }
    }()
}
```

## Debugging and Observability

### Structured Logging

Implement comprehensive logging for state transitions:

```go
type LoggingDependencies struct {
    Logger *slog.Logger
    // ... other deps
}

func Transition(ctx context.Context, deps LoggingDependencies, cmd Command, state State) (State, error) {
    // Log command received
    deps.Logger.Info("command received",
        "command_type", fmt.Sprintf("%T", cmd),
        "current_state", fmt.Sprintf("%T", state),
        "trace_id", ctx.Value("trace_id"),
    )
    
    startTime := time.Now()
    newState, err := performTransition(ctx, deps, cmd, state)
    duration := time.Since(startTime)
    
    if err != nil {
        deps.Logger.Error("transition failed",
            "error", err,
            "duration_ms", duration.Milliseconds(),
        )
        return nil, err
    }
    
    deps.Logger.Info("transition completed",
        "new_state", fmt.Sprintf("%T", newState),
        "duration_ms", duration.Milliseconds(),
    )
    
    return newState, nil
}
```

### State History Tracking

Keep a history of state transitions for debugging:

```go
type StateHistory struct {
    Transitions []TransitionRecord
    mu          sync.RWMutex
}

type TransitionRecord struct {
    From      string
    To        string
    Command   string
    Timestamp time.Time
    Error     error
}

func (h *StateHistory) Record(from, to State, cmd Command, err error) {
    h.mu.Lock()
    defer h.mu.Unlock()
    
    h.Transitions = append(h.Transitions, TransitionRecord{
        From:      fmt.Sprintf("%T", from),
        To:        fmt.Sprintf("%T", to),
        Command:   fmt.Sprintf("%T", cmd),
        Timestamp: time.Now(),
        Error:     err,
    })
}
```

### Metrics and Monitoring

Export metrics for monitoring:

```go
type MetricsDependencies struct {
    TransitionCounter   *prometheus.CounterVec
    TransitionDuration  *prometheus.HistogramVec
    StateGauge         *prometheus.GaugeVec
    // ... other deps
}

func instrumentedTransition(deps MetricsDependencies, transition TransitionFunc) TransitionFunc {
    return func(ctx context.Context, cmd Command, state State) (State, error) {
        timer := prometheus.NewTimer(deps.TransitionDuration.WithLabelValues(
            fmt.Sprintf("%T", cmd),
            fmt.Sprintf("%T", state),
        ))
        defer timer.ObserveDuration()
        
        newState, err := transition(ctx, cmd, state)
        
        labels := prometheus.Labels{
            "from_state": fmt.Sprintf("%T", state),
            "to_state":   fmt.Sprintf("%T", newState),
            "command":    fmt.Sprintf("%T", cmd),
            "status":     "success",
        }
        
        if err != nil {
            labels["status"] = "error"
        }
        
        deps.TransitionCounter.With(labels).Inc()
        
        return newState, err
    }
}
```

## Evolution and Versioning

### Backward Compatible Changes

When evolving state machines, maintain compatibility:

```go
// Version 1
//go:tag mkunion:"OrderState"
type (
    OrderCreated struct {
        ID    string
        Items []Item
    }
)

// Version 2 - Added field with default
//go:tag mkunion:"OrderState"
type (
    OrderCreated struct {
        ID       string
        Items    []Item
        Discount float64 `json:"discount,omitempty"` // New field
    }
)
```

### State Migration Strategies

Handle state structure changes:

```go
// Migration function
func MigrateOrderState(old json.RawMessage) (State, error) {
    // Try to unmarshal as current version
    var current OrderState
    if err := json.Unmarshal(old, &current); err == nil {
        return current, nil
    }
    
    // Try older version
    var v1 OrderStateV1
    if err := json.Unmarshal(old, &v1); err == nil {
        // Convert v1 to current
        return convertV1ToCurrent(v1), nil
    }
    
    return nil, fmt.Errorf("unknown state version")
}
```

### Deprecating States and Commands

Gracefully phase out old states:

```go
//go:tag mkunion:"OrderState"
type (
    // Deprecated: Use OrderPending instead
    OrderCreated struct {
        // ... fields
    }
    
    OrderPending struct {
        // New state structure
    }
)

func Transition(ctx context.Context, deps Dependencies, cmd Command, state State) (State, error) {
    // Handle deprecated state
    if old, ok := state.(*OrderCreated); ok {
        // Automatically migrate to new state
        state = &OrderPending{
            // Map old fields to new
        }
    }
    
    // Continue with normal processing
    // ...
}
```

## Performance Considerations

### Memory Optimization

1. **Reuse State Instances**: For states without data, use singletons
```go
var (
    pendingState = &Pending{}
    activeState  = &Active{}
)
```

2. **Lazy Loading**: Don't load unnecessary data in states
```go
type OrderDetails struct {
    ID       string
    // Don't embed full customer, just reference
    CustomerID string `json:"customer_id"`
}
```

### Persistence Strategies

1. **Event Sourcing**: Store commands instead of states for better performance
2. **Snapshotting**: Periodically save full state to avoid replaying all events
3. **Compression**: Compress state data before persistence

### Concurrent Processing

1. **Partition by ID**: Process different entities in parallel
```go
// Each order gets its own state machine instance
machines := make(map[string]*Machine)
var mu sync.RWMutex

func GetMachine(orderID string) *Machine {
    mu.RLock()
    if m, exists := machines[orderID]; exists {
        mu.RUnlock()
        return m
    }
    mu.RUnlock()
    
    // Create new machine for this order
    mu.Lock()
    defer mu.Unlock()
    
    if m, exists := machines[orderID]; exists {
        return m
    }
    
    m := NewMachine(deps, loadState(orderID))
    machines[orderID] = m
    return m
}
```

2. **Batch Processing**: Process multiple commands together
3. **Async Side Effects**: Don't block transitions on external calls

## Next steps

- **[Simple Examples](simple_state_machines.md)** - Start with basic state machines before tackling complex scenarios
- **[Persisting union in database](../examples/state_storage.md)** will help answer the question of how to persist state in a database and how to handle concurrency conflicts.
- **[Handling errors in state machines](../examples/state_storage.md)** will help answer the question of how to handle errors in state machines and how to build self-healing systems.



