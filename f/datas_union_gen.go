// Code generated by mkunion. DO NOT EDIT.
package f

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type EitherVisitor[A any, B any] interface {
	VisitLeft(v *Left[A, B]) any
	VisitRight(v *Right[A, B]) any
}

type Either[A any, B any] interface {
	AcceptEither(g EitherVisitor[A, B]) any
}

var (
	_ Either[any, any] = (*Left[any, any])(nil)
	_ Either[any, any] = (*Right[any, any])(nil)
)

func (r *Left[A, B]) AcceptEither(v EitherVisitor[A, B]) any  { return v.VisitLeft(r) }
func (r *Right[A, B]) AcceptEither(v EitherVisitor[A, B]) any { return v.VisitRight(r) }

func MatchEitherR3[A any, B any, T0, T1, T2 any](
	x Either[A, B],
	f1 func(x *Left[A, B]) (T0, T1, T2),
	f2 func(x *Right[A, B]) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Left[A, B]:
		return f1(v)
	case *Right[A, B]:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchEitherR2[A any, B any, T0, T1 any](
	x Either[A, B],
	f1 func(x *Left[A, B]) (T0, T1),
	f2 func(x *Right[A, B]) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Left[A, B]:
		return f1(v)
	case *Right[A, B]:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchEitherR1[A any, B any, T0 any](
	x Either[A, B],
	f1 func(x *Left[A, B]) T0,
	f2 func(x *Right[A, B]) T0,
) T0 {
	switch v := x.(type) {
	case *Left[A, B]:
		return f1(v)
	case *Right[A, B]:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchEitherR0[A any, B any](
	x Either[A, B],
	f1 func(x *Left[A, B]),
	f2 func(x *Right[A, B]),
) {
	switch v := x.(type) {
	case *Left[A, B]:
		f1(v)
	case *Right[A, B]:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Either[any,any]", EitherFromJSON[any, any], EitherToJSON[any, any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Left[any,any]", LeftFromJSON[any, any], LeftToJSON[any, any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Right[any,any]", RightFromJSON[any, any], RightToJSON[any, any])
}

type EitherUnionJSON[A any, B any] struct {
	Type  string          `json:"$type,omitempty"`
	Left  json.RawMessage `json:"f.Left,omitempty"`
	Right json.RawMessage `json:"f.Right,omitempty"`
}

func EitherFromJSON[A any, B any](x []byte) (Either[A, B], error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data EitherUnionJSON[A, B]
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("f.EitherFromJSON[A,B]: %w", err)
	}

	switch data.Type {
	case "f.Left":
		return LeftFromJSON[A, B](data.Left)
	case "f.Right":
		return RightFromJSON[A, B](data.Right)
	}

	if data.Left != nil {
		return LeftFromJSON[A, B](data.Left)
	} else if data.Right != nil {
		return RightFromJSON[A, B](data.Right)
	}
	return nil, fmt.Errorf("f.EitherFromJSON[A,B]: unknown type: %s", data.Type)
}

func EitherToJSON[A any, B any](x Either[A, B]) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchEitherR2(
		x,
		func(y *Left[A, B]) ([]byte, error) {
			body, err := LeftToJSON[A, B](y)
			if err != nil {
				return nil, fmt.Errorf("f.EitherToJSON[A,B]: %w", err)
			}
			return json.Marshal(EitherUnionJSON[A, B]{
				Type: "f.Left",
				Left: body,
			})
		},
		func(y *Right[A, B]) ([]byte, error) {
			body, err := RightToJSON[A, B](y)
			if err != nil {
				return nil, fmt.Errorf("f.EitherToJSON[A,B]: %w", err)
			}
			return json.Marshal(EitherUnionJSON[A, B]{
				Type:  "f.Right",
				Right: body,
			})
		},
	)
}

func LeftFromJSON[A any, B any](x []byte) (*Left[A, B], error) {
	result := new(Left[A, B])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("f.LeftFromJSON[A,B]: %w", err)
	}
	return result, nil
}

func LeftToJSON[A any, B any](x *Left[A, B]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Left[any, any])(nil)
	_ json.Marshaler   = (*Left[any, any])(nil)
)

func (r *Left[A, B]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONLeftLb_ACommaB_bL(*r)
}
func (r *Left[A, B]) _marshalJSONLeftLb_ACommaB_bL(x Left[A, B]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldValue []byte
	fieldValue, err = r._marshalJSONA(x.Value)
	if err != nil {
		return nil, fmt.Errorf("f: Left[A,B]._marshalJSONLeftLb_ACommaB_bL: field name Value; %w", err)
	}
	partial["Value"] = fieldValue
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("f: Left[A,B]._marshalJSONLeftLb_ACommaB_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Left[A, B]) _marshalJSONA(x A) ([]byte, error) {
	result, err := shared.JSONMarshal[A](x)
	if err != nil {
		return nil, fmt.Errorf("f: Left[A,B]._marshalJSONA:; %w", err)
	}
	return result, nil
}
func (r *Left[A, B]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONLeftLb_ACommaB_bL(data)
	if err != nil {
		return fmt.Errorf("f: Left[A,B].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Left[A, B]) _unmarshalJSONLeftLb_ACommaB_bL(data []byte) (Left[A, B], error) {
	result := Left[A, B]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("f: Left[A,B]._unmarshalJSONLeftLb_ACommaB_bL: native struct unwrap; %w", err)
	}
	if fieldValue, ok := partial["Value"]; ok {
		result.Value, err = r._unmarshalJSONA(fieldValue)
		if err != nil {
			return result, fmt.Errorf("f: Left[A,B]._unmarshalJSONLeftLb_ACommaB_bL: field Value; %w", err)
		}
	}
	return result, nil
}
func (r *Left[A, B]) _unmarshalJSONA(data []byte) (A, error) {
	result, err := shared.JSONUnmarshal[A](data)
	if err != nil {
		return result, fmt.Errorf("f: Left[A,B]._unmarshalJSONA: native ref unwrap; %w", err)
	}
	return result, nil
}

func RightFromJSON[A any, B any](x []byte) (*Right[A, B], error) {
	result := new(Right[A, B])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("f.RightFromJSON[A,B]: %w", err)
	}
	return result, nil
}

func RightToJSON[A any, B any](x *Right[A, B]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Right[any, any])(nil)
	_ json.Marshaler   = (*Right[any, any])(nil)
)

func (r *Right[A, B]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONRightLb_ACommaB_bL(*r)
}
func (r *Right[A, B]) _marshalJSONRightLb_ACommaB_bL(x Right[A, B]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldValue []byte
	fieldValue, err = r._marshalJSONB(x.Value)
	if err != nil {
		return nil, fmt.Errorf("f: Right[A,B]._marshalJSONRightLb_ACommaB_bL: field name Value; %w", err)
	}
	partial["Value"] = fieldValue
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("f: Right[A,B]._marshalJSONRightLb_ACommaB_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Right[A, B]) _marshalJSONB(x B) ([]byte, error) {
	result, err := shared.JSONMarshal[B](x)
	if err != nil {
		return nil, fmt.Errorf("f: Right[A,B]._marshalJSONB:; %w", err)
	}
	return result, nil
}
func (r *Right[A, B]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONRightLb_ACommaB_bL(data)
	if err != nil {
		return fmt.Errorf("f: Right[A,B].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Right[A, B]) _unmarshalJSONRightLb_ACommaB_bL(data []byte) (Right[A, B], error) {
	result := Right[A, B]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("f: Right[A,B]._unmarshalJSONRightLb_ACommaB_bL: native struct unwrap; %w", err)
	}
	if fieldValue, ok := partial["Value"]; ok {
		result.Value, err = r._unmarshalJSONB(fieldValue)
		if err != nil {
			return result, fmt.Errorf("f: Right[A,B]._unmarshalJSONRightLb_ACommaB_bL: field Value; %w", err)
		}
	}
	return result, nil
}
func (r *Right[A, B]) _unmarshalJSONB(data []byte) (B, error) {
	result, err := shared.JSONUnmarshal[B](data)
	if err != nil {
		return result, fmt.Errorf("f: Right[A,B]._unmarshalJSONB: native ref unwrap; %w", err)
	}
	return result, nil
}

type OptionVisitor[A any] interface {
	VisitNone(v *None[A]) any
	VisitSome(v *Some[A]) any
}

type Option[A any] interface {
	AcceptOption(g OptionVisitor[A]) any
}

var (
	_ Option[any] = (*None[any])(nil)
	_ Option[any] = (*Some[any])(nil)
)

func (r *None[A]) AcceptOption(v OptionVisitor[A]) any { return v.VisitNone(r) }
func (r *Some[A]) AcceptOption(v OptionVisitor[A]) any { return v.VisitSome(r) }

func MatchOptionR3[A any, T0, T1, T2 any](
	x Option[A],
	f1 func(x *None[A]) (T0, T1, T2),
	f2 func(x *Some[A]) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *None[A]:
		return f1(v)
	case *Some[A]:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchOptionR2[A any, T0, T1 any](
	x Option[A],
	f1 func(x *None[A]) (T0, T1),
	f2 func(x *Some[A]) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *None[A]:
		return f1(v)
	case *Some[A]:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchOptionR1[A any, T0 any](
	x Option[A],
	f1 func(x *None[A]) T0,
	f2 func(x *Some[A]) T0,
) T0 {
	switch v := x.(type) {
	case *None[A]:
		return f1(v)
	case *Some[A]:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchOptionR0[A any](
	x Option[A],
	f1 func(x *None[A]),
	f2 func(x *Some[A]),
) {
	switch v := x.(type) {
	case *None[A]:
		f1(v)
	case *Some[A]:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.None[any]", NoneFromJSON[any], NoneToJSON[any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Option[any]", OptionFromJSON[any], OptionToJSON[any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Some[any]", SomeFromJSON[any], SomeToJSON[any])
}

type OptionUnionJSON[A any] struct {
	Type string          `json:"$type,omitempty"`
	None json.RawMessage `json:"f.None,omitempty"`
	Some json.RawMessage `json:"f.Some,omitempty"`
}

func OptionFromJSON[A any](x []byte) (Option[A], error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data OptionUnionJSON[A]
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("f.OptionFromJSON[A]: %w", err)
	}

	switch data.Type {
	case "f.None":
		return NoneFromJSON[A](data.None)
	case "f.Some":
		return SomeFromJSON[A](data.Some)
	}

	if data.None != nil {
		return NoneFromJSON[A](data.None)
	} else if data.Some != nil {
		return SomeFromJSON[A](data.Some)
	}
	return nil, fmt.Errorf("f.OptionFromJSON[A]: unknown type: %s", data.Type)
}

func OptionToJSON[A any](x Option[A]) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchOptionR2(
		x,
		func(y *None[A]) ([]byte, error) {
			body, err := NoneToJSON[A](y)
			if err != nil {
				return nil, fmt.Errorf("f.OptionToJSON[A]: %w", err)
			}
			return json.Marshal(OptionUnionJSON[A]{
				Type: "f.None",
				None: body,
			})
		},
		func(y *Some[A]) ([]byte, error) {
			body, err := SomeToJSON[A](y)
			if err != nil {
				return nil, fmt.Errorf("f.OptionToJSON[A]: %w", err)
			}
			return json.Marshal(OptionUnionJSON[A]{
				Type: "f.Some",
				Some: body,
			})
		},
	)
}

func NoneFromJSON[A any](x []byte) (*None[A], error) {
	result := new(None[A])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("f.NoneFromJSON[A]: %w", err)
	}
	return result, nil
}

func NoneToJSON[A any](x *None[A]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*None[any])(nil)
	_ json.Marshaler   = (*None[any])(nil)
)

func (r *None[A]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONNoneLb_A_bL(*r)
}
func (r *None[A]) _marshalJSONNoneLb_A_bL(x None[A]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("f: None[A]._marshalJSONNoneLb_A_bL: struct; %w", err)
	}
	return result, nil
}
func (r *None[A]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONNoneLb_A_bL(data)
	if err != nil {
		return fmt.Errorf("f: None[A].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *None[A]) _unmarshalJSONNoneLb_A_bL(data []byte) (None[A], error) {
	result := None[A]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("f: None[A]._unmarshalJSONNoneLb_A_bL: native struct unwrap; %w", err)
	}
	return result, nil
}

func SomeFromJSON[A any](x []byte) (*Some[A], error) {
	result := new(Some[A])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("f.SomeFromJSON[A]: %w", err)
	}
	return result, nil
}

func SomeToJSON[A any](x *Some[A]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Some[any])(nil)
	_ json.Marshaler   = (*Some[any])(nil)
)

func (r *Some[A]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONSomeLb_A_bL(*r)
}
func (r *Some[A]) _marshalJSONSomeLb_A_bL(x Some[A]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldValue []byte
	fieldValue, err = r._marshalJSONA(x.Value)
	if err != nil {
		return nil, fmt.Errorf("f: Some[A]._marshalJSONSomeLb_A_bL: field name Value; %w", err)
	}
	partial["Value"] = fieldValue
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("f: Some[A]._marshalJSONSomeLb_A_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Some[A]) _marshalJSONA(x A) ([]byte, error) {
	result, err := shared.JSONMarshal[A](x)
	if err != nil {
		return nil, fmt.Errorf("f: Some[A]._marshalJSONA:; %w", err)
	}
	return result, nil
}
func (r *Some[A]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONSomeLb_A_bL(data)
	if err != nil {
		return fmt.Errorf("f: Some[A].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Some[A]) _unmarshalJSONSomeLb_A_bL(data []byte) (Some[A], error) {
	result := Some[A]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("f: Some[A]._unmarshalJSONSomeLb_A_bL: native struct unwrap; %w", err)
	}
	if fieldValue, ok := partial["Value"]; ok {
		result.Value, err = r._unmarshalJSONA(fieldValue)
		if err != nil {
			return result, fmt.Errorf("f: Some[A]._unmarshalJSONSomeLb_A_bL: field Value; %w", err)
		}
	}
	return result, nil
}
func (r *Some[A]) _unmarshalJSONA(data []byte) (A, error) {
	result, err := shared.JSONUnmarshal[A](data)
	if err != nil {
		return result, fmt.Errorf("f: Some[A]._unmarshalJSONA: native ref unwrap; %w", err)
	}
	return result, nil
}

type ResultVisitor[A any, E any] interface {
	VisitOk(v *Ok[A, E]) any
	VisitErr(v *Err[A, E]) any
}

type Result[A any, E any] interface {
	AcceptResult(g ResultVisitor[A, E]) any
}

var (
	_ Result[any, any] = (*Ok[any, any])(nil)
	_ Result[any, any] = (*Err[any, any])(nil)
)

func (r *Ok[A, E]) AcceptResult(v ResultVisitor[A, E]) any  { return v.VisitOk(r) }
func (r *Err[A, E]) AcceptResult(v ResultVisitor[A, E]) any { return v.VisitErr(r) }

func MatchResultR3[A any, E any, T0, T1, T2 any](
	x Result[A, E],
	f1 func(x *Ok[A, E]) (T0, T1, T2),
	f2 func(x *Err[A, E]) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Ok[A, E]:
		return f1(v)
	case *Err[A, E]:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchResultR2[A any, E any, T0, T1 any](
	x Result[A, E],
	f1 func(x *Ok[A, E]) (T0, T1),
	f2 func(x *Err[A, E]) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Ok[A, E]:
		return f1(v)
	case *Err[A, E]:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchResultR1[A any, E any, T0 any](
	x Result[A, E],
	f1 func(x *Ok[A, E]) T0,
	f2 func(x *Err[A, E]) T0,
) T0 {
	switch v := x.(type) {
	case *Ok[A, E]:
		return f1(v)
	case *Err[A, E]:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchResultR0[A any, E any](
	x Result[A, E],
	f1 func(x *Ok[A, E]),
	f2 func(x *Err[A, E]),
) {
	switch v := x.(type) {
	case *Ok[A, E]:
		f1(v)
	case *Err[A, E]:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Err[any,any]", ErrFromJSON[any, any], ErrToJSON[any, any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Ok[any,any]", OkFromJSON[any, any], OkToJSON[any, any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/f.Result[any,any]", ResultFromJSON[any, any], ResultToJSON[any, any])
}

type ResultUnionJSON[A any, E any] struct {
	Type string          `json:"$type,omitempty"`
	Ok   json.RawMessage `json:"f.Ok,omitempty"`
	Err  json.RawMessage `json:"f.Err,omitempty"`
}

func ResultFromJSON[A any, E any](x []byte) (Result[A, E], error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data ResultUnionJSON[A, E]
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("f.ResultFromJSON[A,E]: %w", err)
	}

	switch data.Type {
	case "f.Ok":
		return OkFromJSON[A, E](data.Ok)
	case "f.Err":
		return ErrFromJSON[A, E](data.Err)
	}

	if data.Ok != nil {
		return OkFromJSON[A, E](data.Ok)
	} else if data.Err != nil {
		return ErrFromJSON[A, E](data.Err)
	}
	return nil, fmt.Errorf("f.ResultFromJSON[A,E]: unknown type: %s", data.Type)
}

func ResultToJSON[A any, E any](x Result[A, E]) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchResultR2(
		x,
		func(y *Ok[A, E]) ([]byte, error) {
			body, err := OkToJSON[A, E](y)
			if err != nil {
				return nil, fmt.Errorf("f.ResultToJSON[A,E]: %w", err)
			}
			return json.Marshal(ResultUnionJSON[A, E]{
				Type: "f.Ok",
				Ok:   body,
			})
		},
		func(y *Err[A, E]) ([]byte, error) {
			body, err := ErrToJSON[A, E](y)
			if err != nil {
				return nil, fmt.Errorf("f.ResultToJSON[A,E]: %w", err)
			}
			return json.Marshal(ResultUnionJSON[A, E]{
				Type: "f.Err",
				Err:  body,
			})
		},
	)
}

func OkFromJSON[A any, E any](x []byte) (*Ok[A, E], error) {
	result := new(Ok[A, E])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("f.OkFromJSON[A,E]: %w", err)
	}
	return result, nil
}

func OkToJSON[A any, E any](x *Ok[A, E]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Ok[any, any])(nil)
	_ json.Marshaler   = (*Ok[any, any])(nil)
)

func (r *Ok[A, E]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONOkLb_ACommaE_bL(*r)
}
func (r *Ok[A, E]) _marshalJSONOkLb_ACommaE_bL(x Ok[A, E]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldValue []byte
	fieldValue, err = r._marshalJSONA(x.Value)
	if err != nil {
		return nil, fmt.Errorf("f: Ok[A,E]._marshalJSONOkLb_ACommaE_bL: field name Value; %w", err)
	}
	partial["Value"] = fieldValue
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("f: Ok[A,E]._marshalJSONOkLb_ACommaE_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Ok[A, E]) _marshalJSONA(x A) ([]byte, error) {
	result, err := shared.JSONMarshal[A](x)
	if err != nil {
		return nil, fmt.Errorf("f: Ok[A,E]._marshalJSONA:; %w", err)
	}
	return result, nil
}
func (r *Ok[A, E]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONOkLb_ACommaE_bL(data)
	if err != nil {
		return fmt.Errorf("f: Ok[A,E].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Ok[A, E]) _unmarshalJSONOkLb_ACommaE_bL(data []byte) (Ok[A, E], error) {
	result := Ok[A, E]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("f: Ok[A,E]._unmarshalJSONOkLb_ACommaE_bL: native struct unwrap; %w", err)
	}
	if fieldValue, ok := partial["Value"]; ok {
		result.Value, err = r._unmarshalJSONA(fieldValue)
		if err != nil {
			return result, fmt.Errorf("f: Ok[A,E]._unmarshalJSONOkLb_ACommaE_bL: field Value; %w", err)
		}
	}
	return result, nil
}
func (r *Ok[A, E]) _unmarshalJSONA(data []byte) (A, error) {
	result, err := shared.JSONUnmarshal[A](data)
	if err != nil {
		return result, fmt.Errorf("f: Ok[A,E]._unmarshalJSONA: native ref unwrap; %w", err)
	}
	return result, nil
}

func ErrFromJSON[A any, E any](x []byte) (*Err[A, E], error) {
	result := new(Err[A, E])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("f.ErrFromJSON[A,E]: %w", err)
	}
	return result, nil
}

func ErrToJSON[A any, E any](x *Err[A, E]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Err[any, any])(nil)
	_ json.Marshaler   = (*Err[any, any])(nil)
)

func (r *Err[A, E]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONErrLb_ACommaE_bL(*r)
}
func (r *Err[A, E]) _marshalJSONErrLb_ACommaE_bL(x Err[A, E]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldError []byte
	fieldError, err = r._marshalJSONE(x.Error)
	if err != nil {
		return nil, fmt.Errorf("f: Err[A,E]._marshalJSONErrLb_ACommaE_bL: field name Error; %w", err)
	}
	partial["Error"] = fieldError
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("f: Err[A,E]._marshalJSONErrLb_ACommaE_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Err[A, E]) _marshalJSONE(x E) ([]byte, error) {
	result, err := shared.JSONMarshal[E](x)
	if err != nil {
		return nil, fmt.Errorf("f: Err[A,E]._marshalJSONE:; %w", err)
	}
	return result, nil
}
func (r *Err[A, E]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONErrLb_ACommaE_bL(data)
	if err != nil {
		return fmt.Errorf("f: Err[A,E].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Err[A, E]) _unmarshalJSONErrLb_ACommaE_bL(data []byte) (Err[A, E], error) {
	result := Err[A, E]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("f: Err[A,E]._unmarshalJSONErrLb_ACommaE_bL: native struct unwrap; %w", err)
	}
	if fieldError, ok := partial["Error"]; ok {
		result.Error, err = r._unmarshalJSONE(fieldError)
		if err != nil {
			return result, fmt.Errorf("f: Err[A,E]._unmarshalJSONErrLb_ACommaE_bL: field Error; %w", err)
		}
	}
	return result, nil
}
func (r *Err[A, E]) _unmarshalJSONE(data []byte) (E, error) {
	result, err := shared.JSONUnmarshal[E](data)
	if err != nil {
		return result, fmt.Errorf("f: Err[A,E]._unmarshalJSONE: native ref unwrap; %w", err)
	}
	return result, nil
}
