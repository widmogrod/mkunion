{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkUnion","text":""},{"location":"#about","title":"About","text":"<p>Strongly typed union type in golang that supports generics*</p> <ul> <li>with exhaustive pattern matching support</li> <li>with json marshalling including generics</li> <li>and as a bonus, can generate compatible TypeScript types for end-to-end type safety in your application</li> </ul>"},{"location":"#why","title":"Why","text":"<p>Historically, in languages like Go that lack native union types, developers have resorted to workarounds such as the Visitor pattern or <code>iota</code> with <code>switch</code> statements.</p> <p>The Visitor pattern requires a lot of boilerplate code and manual crafting of the <code>Accept</code> method for each type in the union. Using <code>iota</code> and <code>switch</code> statements is not type-safe and can lead to runtime errors, especially when a new type is added and not all <code>case</code> statements are updated.</p> <p>On top of that, any data marshalling, like to/from JSON, requires additional, handcrafted code to make it work.</p> <p>MkUnion solves all of these problems by generating opinionated and strongly typed, meaningful code for you.</p>"},{"location":"#example","title":"Example","text":"example/shape.go<pre><code>//go:tag mkunion:\"Shape\"\ntype (\n    Circle struct {\n        Radius float64\n    }\n    Rectangle struct {\n        Width  float64\n        Height float64\n    }\n    Square struct {\n        Side float64\n    }\n)\n\n\nfunc CalculateArea(s Shape) float64 {\n    return MatchShapeR1(\n        s,\n        func(x *Circle) float64 {\n            return math.Pi * x.Radius * x.Radius\n        },\n        func(x *Rectangle) float64 {\n            return x.Width * x.Height\n        },\n        func(x *Square) float64 {\n            return x.Side * x.Side\n        },\n    )\n}\n\n\nfunc TestShapeJSON(t *testing.T) {\n    shape := &amp;Rectangle{\n        Width:  10,\n        Height: 20,\n    }\n    result, err := shared.JSONMarshal[Shape](shape)\n    if err != nil {\n        t.Fatal(err)\n    }\n    fmt.Println(string(result))\n    // Output: {\"$type\":\"example.Rectangle\",\"example.Rectangle\":{\"Width\":10,\"Height\":20}}\n\n    shape2, err := shared.JSONUnmarshal[Shape](result)\n    if err != nil {\n        t.Fatal(err)\n    }\n    fmt.Printf(\"%#v\", shape2)\n    // Output: &amp;example.Rectangle{Width:10, Height:20}\n}\n</code></pre> <p>Watch for changes in the file and generate code on the fly: <pre><code>mkunion watch ./...\n\n# or use -g flag to generate code without watching\nmkunion watch -g ./...\n</code></pre></p>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Read getting started to learn more.</li> <li>Learn more about value proposition</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#install-mkunion","title":"Install mkunion","text":"<p>Run in your terminal <pre><code>go install github.com/widmogrod/mkunion/cmd/mkunion@v1.26.1\n</code></pre></p>"},{"location":"getting_started/#define-your-first-union-type","title":"Define your first union type","text":"<p>Create your first union. In our simple example, we will represent different geometric shapes. But in a more complex example, you may want to represent different states of your application, model domain aggregates, or create your own DSL. example/shape.go<pre><code>//go:tag mkunion:\"Shape\"\ntype (\n    Circle struct {\n        Radius float64\n    }\n    Rectangle struct {\n        Width  float64\n        Height float64\n    }\n    Square struct {\n        Side float64\n    }\n)\n</code></pre></p> <p>In the above example, you can see a few important concepts:</p>"},{"location":"getting_started/#gotag-mkunionshape","title":"<code>//go:tag mkunion:\"Shape\"</code>","text":"<p>Tags are a powerful and flexible way to add metadata to your code. You may be familiar with tags when you work with JSON in Go:</p> <pre><code>type User struct {\n    Name string `json:\"name\"`\n}\n</code></pre> <p>Unfortunately, Go doesn't extend this feature to other parts of the language.</p> <p>MkUnion defines the <code>//go:tag</code> comment, following other idiomatic definitions like <code>go:generate</code> and <code>go:embed</code>, to allow adding metadata to struct types. And MkUnion uses it heavily to offer a way of adding new behavior to Go types.</p>"},{"location":"getting_started/#tags-supported-by-mkunion","title":"Tags supported by MkUnion","text":"<ul> <li><code>go:tag mkunion:\"Shape\"</code> - defines a union type. For generic unions, type parameters MUST be specified: <code>go:tag mkunion:\"Result[T, E]\"</code>.</li> <li><code>go:tag serde:\"json\"</code> - enables serialization type (currently only JSON is supported), enabled by default.</li> <li><code>go:tag shape:\"-\"</code> - disables shape generation for this type, useful in cases where an x/shared package cannot depend on other x packages, to avoid circular dependencies.</li> <li><code>go:tag mkunion:\",no-type-registry\"</code> - if you want to disable generation of the type registry in a package, define this tag in one of the Go files above the package declaration:   <pre><code>//go:tag mkunion:\",no-type-registry\"\npackage example\n</code></pre></li> <li><code>go:tag mkmatch</code> - generate custom pattern matching function from interface definition   example/shape.go<pre><code>//go:tag mkmatch\ntype MatchShapes[A, B Shape] interface {\n  MatchCircles(x, y *Circle)\n  MatchRectangleAny(x *Rectangle, y any)\n  Finally(x, y any)\n}\n</code></pre></li> </ul>"},{"location":"getting_started/#type-convention","title":"<code>type (...)</code> convention","text":"<p>A union type is defined as a set of types in a single type declaration. You can think of it as a \"one of\" type. To make it more readable, as a convention, I decided to use the <code>type (...)</code> declaration block instead of individual <code>type</code> declarations.</p>"},{"location":"getting_started/#generate-code-and-watch-for-changes","title":"Generate code and watch for changes","text":"<p>Run in your terminal to generate union types for your code and watch for changes: <pre><code>mkunion watch ./...\n</code></pre></p> <p>This command will:</p> <ol> <li>Generate union types and shapes from your code</li> <li>Automatically run <code>go generate ./...</code> to trigger any other code generators</li> <li>Continue watching for file changes and repeat the process</li> </ol> <p>To generate unions without watching for changes (one-time generation): <pre><code>mkunion watch -g ./...\n</code></pre></p> <p>Alternatively, you can run the <code>mkunion</code> command directly on specific files: <pre><code>mkunion -i example/shape.go\n</code></pre></p>"},{"location":"getting_started/#automatic-go-generate-execution","title":"Automatic <code>go generate</code> execution","text":"<p>As of the latest version, <code>mkunion watch</code> automatically runs <code>go generate ./...</code> after generating union types and shapes. This eliminates the need to run two separate commands.</p> <p>If you need to skip the automatic <code>go generate</code> step (for example, if you want to run it manually with specific flags), use the <code>--dont-run-go-generate</code> flag: <pre><code>mkunion watch --dont-run-go-generate ./...\n# or use the short form\nmkunion watch -G ./...\n</code></pre></p> <p>This automatic execution works well with extensions like moq that depend on union types being defined first.</p>"},{"location":"getting_started/#match-over-union-type","title":"Match over union type","text":"<p>When you run the <code>mkunion</code> command, it will generate a file alongside your original file with the <code>union_gen.go</code> suffix (example shape_union_gen.go).</p> <p>You can use these functions to do exhaustive matching on your union type.</p> <p>For example, you can calculate the area of different shapes with a function that looks like this: example/shape.go<pre><code>func CalculateArea(s Shape) float64 {\n    return MatchShapeR1(\n        s,\n        func(x *Circle) float64 {\n            return math.Pi * x.Radius * x.Radius\n        },\n        func(x *Rectangle) float64 {\n            return x.Width * x.Height\n        },\n        func(x *Square) float64 {\n            return x.Side * x.Side\n        },\n    )\n}\n</code></pre></p> <p>And as you can see, it leverages generics to make it easy to write. No need to cast, check types, or use <code>switch</code> statements.</p>"},{"location":"getting_started/#matching-functions-matchnamer1","title":"matching functions <code>Match{Name}R1</code>","text":"<p>Where <code>Name</code> is the name of your union type. Where <code>R0</code>, <code>R1</code>, <code>R2</code>, <code>R3</code> stand for the number of return values.</p> <p>Example of <code>MatchShapeR1</code> function signature: <pre><code>func MatchShapeR1[T0 any](\n    x Shape,\n    f1 func(x *Circle) T0,\n    f2 func(x *Rectangle) T0,\n    f3 func(x *Square) T0,\n) T0 {\n    /* ... */\n}\n</code></pre></p>"},{"location":"getting_started/#json-marshalling","title":"JSON marshalling","text":"<p>MkUnion also generates JSON marshalling functions for you. You just need to use the <code>shared.JSONMarshal</code> and <code>shared.JSONUnmarshal</code> functions to marshal and unmarshal your union type.</p> <p>Example:</p> example/shape_test.go<pre><code>func TestShapeJSON(t *testing.T) {\n    shape := &amp;Rectangle{\n        Width:  10,\n        Height: 20,\n    }\n    result, err := shared.JSONMarshal[Shape](shape)\n    if err != nil {\n        t.Fatal(err)\n    }\n    fmt.Println(string(result))\n    // Output: {\"$type\":\"example.Rectangle\",\"example.Rectangle\":{\"Width\":10,\"Height\":20}}\n\n    shape2, err := shared.JSONUnmarshal[Shape](result)\n    if err != nil {\n        t.Fatal(err)\n    }\n    fmt.Printf(\"%#v\", shape2)\n    // Output: &amp;example.Rectangle{Width:10, Height:20}\n}\n</code></pre> <p>You can notice that it has an opinionated way of marshalling and unmarshalling your union type. It uses the <code>$type</code> field to store type information, and then stores the actual data in a separate field with the corresponding name.</p> <p>You can read more about it in the Marshaling union in JSON section.</p>"},{"location":"getting_started/#next-steps","title":"Next steps","text":"<ul> <li>Union and generic types - Learn about generic unions</li> <li>Custom Pattern Matching - Learn about custom pattern matching</li> <li>Marshaling union in JSON - Learn about marshaling and unmarshalling of union types in JSON</li> </ul>"},{"location":"value_proposition/","title":"MkUnion Value Proposition","text":""},{"location":"value_proposition/#what-are-sum-types","title":"What Are Sum Types?","text":"<p>In type theory, data types can be composed in two fundamental ways:</p> <ul> <li>Product Types: Combine multiple values simultaneously (structs in Go, \"AND\" relationship)</li> <li>Sum Types: Represent a choice between variants (missing in Go, \"OR\" relationship)</li> </ul> <p>Sum types, also known as tagged unions or algebraic data types (ADTs), are a cornerstone of type-safe programming. They allow you to express \"this OR that\" relationships with compile-time guarantees that all possibilities are handled.</p>"},{"location":"value_proposition/#the-mathematical-inspiration","title":"The Mathematical Inspiration","text":"<p>MkUnion draws inspiration from category theory and algebraic data types found in functional programming languages. While Go's type system doesn't natively support true sum types, MkUnion provides a practical simulation that captures their most useful properties.</p>"},{"location":"value_proposition/#theoretical-background","title":"Theoretical Background","text":"<p>In languages with native sum types, these constructs are mathematical coproducts with specific properties:</p> <ul> <li>Sum Types: Represent \"either/or\" relationships between types</li> <li>Pattern Matching: Provides exhaustive case handling</li> <li>Type Safety: Compile-time guarantees about variant handling</li> </ul> <p>MkUnion emulates these properties through code generation, creating Go interfaces and structs that approximate this behavior</p>"},{"location":"value_proposition/#design-philosophy","title":"Design Philosophy","text":"<p>MkUnion's design is inspired by algebraic principles, but implemented within Go's constraints:</p> <p>Conceptual goals (not formal properties):</p> <ul> <li>Exhaustive handling: All variants must be handled</li> <li>Type safety: No runtime type assertions in generated code</li> <li>Zero-cost abstraction: Minimal runtime overhead</li> <li>Composability: Unions can be nested and combined</li> </ul> <p>What MkUnion provides:</p> <ul> <li>\u2713 Compile-time exhaustiveness checking (via function signatures)</li> <li>\u2713 Type-safe variant access (no manual casting)</li> <li>\u2713 Automatic JSON marshalling/unmarshalling</li> <li>\u2713 Generated helper functions</li> </ul> <p>What MkUnion doesn't provide:</p> <ul> <li>\u2717 True algebraic data types (Go lacks the type system)</li> <li>\u2717 Mathematical properties like semiring laws</li> <li>\u2717 Zero-overhead (interface dispatch has cost)</li> <li>\u2717 Language-level integration</li> </ul>"},{"location":"value_proposition/#practical-benefits","title":"Practical Benefits","text":"<p>MkUnion enables Go developers to use patterns inspired by functional programming:</p> <pre><code>// Result type - explicit error handling without exceptions\n//\n//go:tag mkunion:\"Result[A, E]\"\ntype (\n    Ok[A any, E any]  struct{ Value A }\n    Err[A any, E any] struct{ Error E }\n)\n\n\n// Option type - represent nullable values explicitly\n//\n//go:tag mkunion:\"Option[A]\"\ntype (\n    None[A any] struct{}\n    Some[A any] struct{ Value A }\n)\n\n\n// These provide compile-time safety through exhaustive matching,\n// though they're interface-based simulations, not true sum types\n</code></pre> <p>While languages like Haskell, Rust, and Swift have native sum types, MkUnion brings similar ergonomics to Go through code generation.</p>"},{"location":"value_proposition/#the-problem-union-types-in-go","title":"The Problem: Union Types in Go","text":"<p>Go is a powerful language, but it lacks native support for union types (also known as sum types or algebraic data types). This limitation leads developers to use workarounds that have significant drawbacks.</p>"},{"location":"value_proposition/#traditional-go-approaches","title":"Traditional Go Approaches","text":""},{"location":"value_proposition/#1-the-visitor-pattern","title":"1. The Visitor Pattern","text":"<pre><code>type ShapeVisitor interface {\n    VisitCircle(c *Circle)\n    VisitRectangle(r *Rectangle)\n    VisitTriangle(t *Triangle)\n}\n\ntype Shape interface {\n    Accept(v ShapeVisitor)\n}\n\ntype Circle struct{ Radius float64 }\nfunc (c *Circle) Accept(v ShapeVisitor) { v.VisitCircle(c) }\n\ntype Rectangle struct{ Width, Height float64 }\nfunc (r *Rectangle) Accept(v ShapeVisitor) { v.VisitRectangle(r) }\n\ntype Triangle struct{ Base, Height float64 }\nfunc (t *Triangle) Accept(v ShapeVisitor) { v.VisitTriangle(t) }\n</code></pre> <p>Characteristics:</p> <ul> <li>Pro: <ul> <li>Actually provides compile-time exhaustiveness - adding a new method to the interface requires all implementations to be updated</li> <li>Well-understood pattern in the software engineering community</li> <li>No external dependencies or code generation</li> </ul> </li> <li>Con:<ul> <li>Verbose with boilerplate Accept methods</li> <li>Handling return values requires additional interface methods</li> </ul> </li> </ul>"},{"location":"value_proposition/#2-iota-and-switch-statements","title":"2. Iota and Switch Statements","text":"example/iota.go<pre><code>type IotaShapeType int\n\nconst (\n    IotaCircleType IotaShapeType = iota\n    IotaRectangleType\n    IotaTriangleType\n)\n\ntype (\n    IotaCircle    struct{ Radius float64 }\n    IotaRectangle struct{ Width, Height float64 }\n    IotaTriangle  struct{ Base, Height float64 }\n)\n\ntype IotaShape struct {\n    Type     IotaShapeType\n    Circle   *IotaCircle\n    Rect     *IotaRectangle\n    Triangle *IotaTriangle\n}\n\nfunc CalculateIotaArea(s IotaShape) float64 {\n    switch s.Type {\n    case IotaCircleType:\n        if s.Circle != nil {\n            return math.Pi * s.Circle.Radius * s.Circle.Radius\n        }\n    case IotaRectangleType:\n        if s.Rect != nil {\n            return s.Rect.Width * s.Rect.Height\n        }\n        // Missing IotaTriangleType will not tell you that it's missing switch case\n        // you need to use tools like https://github.com/nishanths/exhaustive\n    }\n    return 0\n}\n</code></pre> <p>Characteristics:</p> <ul> <li>Pro: <ul> <li>Simple and straightforward</li> <li>Familiar to C programmers</li> </ul> </li> <li>Con: <ul> <li>No compile-time exhaustiveness checking</li> <li>Risk of nil pointer dereference if wrong field accessed</li> <li>Requires careful coordination between type field and data fields</li> <li>JSON marshalling requires custom implementation</li> </ul> </li> </ul> <p>Note</p> <p>Projects like exhaustive with golangci-lint can detect non exhaustive switch situation when configured</p>"},{"location":"value_proposition/#3-interface-with-type-assertions","title":"3. Interface with Type Assertions","text":"<pre><code>type Shape interface {\n    shape() // private method to seal interface\n}\n\ntype Circle struct{ Radius float64 }\nfunc (Circle) shape() {}\n\nfunc ProcessShape(s Shape) {\n    switch v := s.(type) {\n    case *Circle:\n        // Process circle\n    case *Rectangle:\n        // Process rectangle\n    default:\n        // Handle unknown types gracefully\n    }\n}\n</code></pre> <p>Characteristics:</p> <ul> <li>Pro: <ul> <li>Most idiomatic Go approach</li> <li>Clean and readable</li> <li>Works well with Go's interface philosophy</li> <li>Static analysis tools can check exhaustiveness</li> </ul> </li> <li>Con: <ul> <li>No compiler-enforced exhaustiveness</li> <li>Requires discipline to handle all cases</li> <li>Each type needs custom JSON marshalling</li> </ul> </li> </ul>"},{"location":"value_proposition/#how-other-languages-solve-this","title":"How Other Languages Solve This","text":"<p>Let's see how languages with native sum types handle the same problem:</p> <p>Rust: <pre><code>enum Shape {\n    Circle { radius: f64 },\n    Rectangle { width: f64, height: f64 },\n    Triangle { base: f64, height: f64 },\n}\n\nfn area(shape: &amp;Shape) -&gt; f64 {\n    match shape {\n        Shape::Circle { radius } =&gt; std::f64::consts::PI * radius * radius,\n        Shape::Rectangle { width, height } =&gt; width * height,\n        Shape::Triangle { base, height } =&gt; 0.5 * base * height,\n        // Compiler error if you miss a case!\n    }\n}\n</code></pre></p> <p>Haskell: <pre><code>data Shape = Circle Double\n           | Rectangle Double Double\n           | Triangle Double Double\n\narea :: Shape -&gt; Double\narea (Circle r) = pi * r * r\narea (Rectangle w h) = w * h\narea (Triangle b h) = 0.5 * b * h\n-- Compiler warns about non-exhaustive patterns\n</code></pre></p> <p>Swift: <pre><code>enum Shape {\n    case circle(radius: Double)\n    case rectangle(width: Double, height: Double)\n    case triangle(base: Double, height: Double)\n}\n\nfunc area(of shape: Shape) -&gt; Double {\n    switch shape {\n    case .circle(let radius):\n        return .pi * radius * radius\n    case .rectangle(let width, let height):\n        return width * height\n    case .triangle(let base, let height):\n        return 0.5 * base * height\n    // Compiler requires exhaustiveness\n    }\n}\n</code></pre></p> <p>TypeScript: <pre><code>type Shape = \n    | { kind: 'circle'; radius: number }\n    | { kind: 'rectangle'; width: number; height: number }\n    | { kind: 'triangle'; base: number; height: number };\n\nfunction area(shape: Shape): number {\n    switch (shape.kind) {\n        case 'circle':\n            return Math.PI * shape.radius * shape.radius;\n        case 'rectangle':\n            return shape.width * shape.height;\n        case 'triangle':\n            return 0.5 * shape.base * shape.height;\n        // TypeScript's exhaustiveness checking with strictNullChecks\n    }\n}\n</code></pre></p> <p>Notice the pattern? All these languages provide:</p> <ul> <li>Compile-time exhaustiveness checking</li> <li>Clean, readable syntax</li> <li>Type-safe variant access</li> <li>No runtime type assertions</li> </ul> <p>While Go's simplicity is admirable, the lack of sum types forces developers into error-prone patterns that these other languages avoid entirely.</p>"},{"location":"value_proposition/#the-mkunion-approach","title":"The MkUnion Approach","text":"<p>MkUnion generates strongly-typed union types with exhaustive pattern matching, addressing many of these challenges:</p> <pre><code>//go:tag mkunion:\"Shape\"\ntype (\n    Circle struct{ Radius float64 }\n    Rectangle struct{ Width, Height float64 }\n    Triangle struct{ Base, Height float64 }\n)\n\n// Generated code provides:\narea := MatchShapeR1(\n    shape,\n    func(c *Circle) float64 { return math.Pi * c.Radius * c.Radius },\n    func(r *Rectangle) float64 { return r.Width * r.Height },\n    func(t *Triangle) float64 { return 0.5 * t.Base * t.Height },\n)\n</code></pre>"},{"location":"value_proposition/#key-benefits","title":"Key Benefits","text":""},{"location":"value_proposition/#1-compile-time-exhaustiveness-checking","title":"1. Compile-Time Exhaustiveness Checking","text":"<p>The generated <code>Match</code> functions require you to handle every possible case through their function signature. Add a new type to the union? The compiler will force you to update all Match function calls.</p> <pre><code>// This won't compile if you miss a case!\nresult := MatchShapeR1(shape,\n    func(c *Circle) string { return \"circle\" },\n    func(r *Rectangle) string { return \"rectangle\" },\n    // Compile error: missing Triangle handler\n)\n</code></pre> <ul> <li>Read more about it Match over union type and advance topic Custom Pattern Matching</li> </ul>"},{"location":"value_proposition/#2-reduced-boilerplate","title":"2. Reduced Boilerplate","text":"<p>Tag your types and run the generator. MkUnion creates:</p> <ul> <li>Union interface with private discriminator</li> <li>Constructor functions</li> <li>Multiple match function variants (R0, R1, R2 for different return values)</li> <li>Visitor pattern implementation</li> <li>JSON marshalling/unmarshalling</li> </ul>"},{"location":"value_proposition/#3-automatic-json-marshalling","title":"3. Automatic JSON Marshalling","text":"<pre><code>shape := &amp;Circle{Radius: 10}\njson, _ := shared.JSONMarshal[Shape](shape)\n// {\"$type\":\"example.Circle\",\"example.Circle\":{\"Radius\":10}}\n\ndecoded, _ := shared.JSONUnmarshal[Shape](json)\n// Returns the correct concrete type\n</code></pre> <ul> <li>Read more about it Marshaling union as JSON</li> </ul>"},{"location":"value_proposition/#4-generic-support","title":"4. Generic Support","text":"<p>MkUnion fully supports Go generics:</p> <pre><code>// Result type - explicit error handling without exceptions\n//\n//go:tag mkunion:\"Result[A, E]\"\ntype (\n    Ok[A any, E any]  struct{ Value A }\n    Err[A any, E any] struct{ Error E }\n)\n\n\n// Use with any type\nvar result Result[string] = &amp;Ok[string]{Value: \"hello\"}\n</code></pre> <ul> <li>Read more about it Union and generic types</li> </ul>"},{"location":"value_proposition/#5-typescript-generation","title":"5. TypeScript Generation","text":"<p>Generate TypeScript types for end-to-end type safety:</p> <pre><code>mkunion shape-export --language typescript --output-dir ./ts\n</code></pre> <p>Creates matching TypeScript discriminated unions that work seamlessly with your Go API.</p> <ul> <li>Read more about it End-to-End types between Go and TypeScript</li> </ul>"},{"location":"value_proposition/#conclusion","title":"Conclusion","text":"<p>MkUnion provides a code generation approach to simulating algebraic data types in Go. It offers compile-time exhaustiveness checking and automatic JSON marshalling at the cost of added build complexity and deviation from idiomatic Go.</p> <p>Whether MkUnion is right for your project depends on your specific needs, team expertise, and tolerance for code generation.  For teams comfortable with these trade-offs who need exhaustive pattern matching, MkUnion can be a valuable tool.  For others, traditional Go patterns with modern linting tools may be more appropriate.</p>"},{"location":"development/development/","title":"Contributing and development","text":""},{"location":"development/development/#contributing","title":"Contributing","text":"<p>If you want to contribute to the <code>mkunion</code> project, please open an issue first to discuss your idea.</p> <p>I have opinions about how <code>mkunion</code> should work, how I want to evolve it, and I want to make sure that your idea fits into the project.</p>"},{"location":"development/development/#development","title":"Development","text":"<p>Checkout the repo and run: <pre><code>./dev/bootstrap.sh\n</code></pre></p> <p>This command starts a Docker container with all the necessary tools to develop and test the <code>mkunion</code> project.</p> <p>In a separate terminal, run: <pre><code>echo \"Build mkunion ...\"\ngo build -C cmd/mkunion .\n\necho \"Instal moq\"\ngo install github.com/matryer/moq@v0.6.0\n\necho \"Make moq available in PATH\"\nexport PATH=$PATH:$GOPATH/bin\n\necho \"Generate files ...\"\ncmd/mkunion/mkunion watch -g ./...\n\necho \"Add vaiables manualy...\"\nsource .envrc\n# or use:\n#  direnv allow .envrc\n\necho \"Run tests ...\"\ngo test ./...\n</code></pre></p> <p>This will generate code and run tests.</p> <p>Note: Some tests may be flaky (this is a known issue being addressed). If you encounter a failing test, please try running it again.</p>"},{"location":"development/development/#documentation","title":"Documentation","text":"<p>To preview the documentation, run: <pre><code>./dev/docs.sh run\n</code></pre></p>"},{"location":"development/roadmap/","title":"Roadmap","text":""},{"location":"development/roadmap/#learning-and-adoption","title":"Learning and adoption","text":"<ul> <li> docs: document simple state machine and how to use <code>mkunion</code> for it</li> <li> feature: <code>mkunion watch ./...</code> command that watches for changes in files and runs faster than <code>go generate ./...</code></li> <li> feature: <code>go:tag mkmatch</code> to generate pattern matching functions</li> <li> feature: <code>go:tag mkmatch</code> with better type parameters validation</li> <li> docs: document how to write custom pattern matching functions</li> <li> docs: document other packages in <code>x/</code> directory</li> <li> docs: document typescript types generation and end-to-end typs concepts (from backend to frontend)</li> <li> feature: expose functions to extract <code>go:tag</code> metadata</li> <li> docs: describe philosophy of \"data as resource\" and how it translates to some of library concepts</li> <li> feature: remove need to provide name for <code>//go:tag mkmatch:\"&lt;name&gt;\"</code> and allow to have only <code>//go:tag mkmatch</code></li> <li> feature: allow to specify type param name in <code>go:tag mkunion:\"Tree[A]\"</code> with validation of expected number and name of type parameters</li> <li> bug fix: prevent dot imports adding same type into registry but in different place and causing panic</li> <li> docs: describe that go:tag can be used on package level</li> <li> feature: <code>mkunion clean</code> removes all generated files to have clean state for generation</li> </ul>"},{"location":"development/roadmap/#long-tern-experiments-and-prototypes","title":"Long tern experiments and prototypes","text":"<ul> <li> experiment: generate other (de)serialization formats (e.g. grpc, sql, graphql)</li> <li> prototype: http &amp; gRPC client for end-to-end types.</li> <li> experiment: allow to derive behaviour for types, like derive(Map), would generated union type with Map() method</li> <li> experiment: consider adding explicit discriminator type names like <code>example.Branch[int]</code> instead of <code>example.Branch</code>. This may complicate TypeScript codegen but it could increase end-to-end type safety.</li> <li> refactor: <code>x/storage</code> instead of generic, leverage schema information to remove lookup of schemas (overhead), eventually generate storage code</li> </ul>"},{"location":"examples/custom_pattern_matching/","title":"Custom Pattern Matching","text":"<p>mkunion provides a powerful feature for creating custom pattern matching functions that can match on multiple union values simultaneously. This guide explains how to write and use custom pattern matching functions.</p>"},{"location":"examples/custom_pattern_matching/#overview","title":"Overview","text":"<p>While mkunion automatically generates pattern matching functions for individual union types (like <code>MatchTreeR1</code>, <code>MatchShapeR2</code>, etc.), you can also define custom pattern matching functions that work across multiple values or implement specialized matching logic.</p> <p>Custom pattern matching is useful when you need to: - Match on combinations of multiple union values - Implement domain-specific matching patterns - Create reusable matching logic for complex scenarios</p>"},{"location":"examples/custom_pattern_matching/#when-to-use-custom-pattern-matching","title":"When to Use Custom Pattern Matching","text":""},{"location":"examples/custom_pattern_matching/#matching-specific-combinations","title":"Matching Specific Combinations","text":"<p>Custom pattern matching is particularly valuable when you need to handle pairs of types but only care about certain combinations. If you need to match all possible combinations exhaustively, it's better to use nested <code>Match&lt;Type&gt;R&lt;N&gt;</code> functions.</p>"},{"location":"examples/custom_pattern_matching/#simplifying-complex-type-assertions","title":"Simplifying Complex Type Assertions","text":"<p>Without custom pattern matching, matching two union values requires nested type assertions:</p> <pre><code>// Without custom pattern matching - verbose and error-prone\nif a, ok := v1.(*Circle); ok {\n    if b, ok := v2.(*Rectangle); ok {\n        // handle Circle-Rectangle combination\n    } else if b, ok := v2.(*Square); ok {\n        // handle Circle-Square combination\n    }\n}\n// ... many more nested ifs\n</code></pre> <p>This approach has several disadvantages: - Difficult to maintain as the number of types grows - Easy to miss combinations - No compile-time exhaustiveness checking - Deeply nested code that's hard to read</p> <p>Custom pattern matching solves these issues elegantly:</p> <pre><code>// With custom pattern matching - clean and maintainable\nMatchShapesR1(v1, v2,\n    func(a *Circle, b *Circle) string { \n        return \"Two circles\" \n    },\n    func(a *Rectangle, b any) string { \n        return \"Rectangle meets another shape\" \n    },\n    func(a any, b any) string { \n        return \"Other combination\" \n    },\n)\n</code></pre>"},{"location":"examples/custom_pattern_matching/#basic-syntax","title":"Basic Syntax","text":"<p>To create a custom pattern matching function, use the <code>//go:tag mkmatch</code> annotation on an interface definition:</p> <pre><code>//go:tag mkmatch\ntype MatchShapes[A, B Shape] interface {\n    MatchCircles(x, y *Circle)\n    MatchRectangleAny(x *Rectangle, y any)\n    Finally(x, y any)\n}\n</code></pre> <p>This generates functions like <code>MatchShapesR0</code>, <code>MatchShapesR1</code>, <code>MatchShapesR2</code>, and <code>MatchShapesR3</code> with 0 to 3 return values respectively.</p>"},{"location":"examples/custom_pattern_matching/#custom-naming","title":"Custom Naming","text":"<p>You can also provide the function name in the tag, and mkunion will use that instead of interface name:</p> <pre><code>//go:tag mkmatch:\"MyShapeMatcher\"\ntype MatchShapes[A, B Shape] interface {\n    MatchCircles(x, y *Circle)\n    MatchRectangleAny(x *Rectangle, y any)\n    Finally(x, y any)\n}\n</code></pre> <p>This generates <code>MyShapeMatcherR0</code>, <code>MyShapeMatcherR1</code>, etc., </p>"},{"location":"examples/custom_pattern_matching/#interface-definition-rules","title":"Interface Definition Rules","text":"<p>When defining a match interface:</p> <ol> <li>Type Parameters: The interface can have type parameters that constrain the input types</li> <li>Method Names: Method names can be anything descriptive</li> <li>Method Parameters: Each method must have the same number of parameters as type parameters</li> <li>Parameter Types: Parameters can be:</li> <li>Concrete types from the union (e.g., <code>*Circle</code>, <code>*Rectangle</code>)</li> <li>The <code>any</code> type for wildcard matching</li> <li>Other specific types for specialized matching</li> </ol>"},{"location":"examples/custom_pattern_matching/#examples","title":"Examples","text":""},{"location":"examples/custom_pattern_matching/#example-1-matching-shape-pairs","title":"Example 1: Matching Shape Pairs","text":"example/shape.go<pre><code>//go:tag mkunion:\"Shape\"\ntype (\n    Circle struct {\n        Radius float64\n    }\n    Rectangle struct {\n        Width  float64\n        Height float64\n    }\n    Square struct {\n        Side float64\n    }\n)\n\n\n//go:tag mkmatch\ntype MatchShapes[A, B Shape] interface {\n    MatchCircles(x, y *Circle)\n    MatchRectangleAny(x *Rectangle, y any)\n    Finally(x, y any)\n}\n\n\nfunc CompareShapes(x, y Shape) string {\n    return MatchShapesR1(\n        x, y,\n        func(x0 *Circle, x1 *Circle) string {\n            return fmt.Sprintf(\"Two circles with radii %.2f and %.2f\", x0.Radius, x1.Radius)\n        },\n        func(x0 *Rectangle, x1 any) string {\n            return fmt.Sprintf(\"Rectangle (%.2fx%.2f) meets %T\", x0.Width, x0.Height, x1)\n        },\n        func(x0 any, x1 any) string {\n            return fmt.Sprintf(\"Finally: %T meets %T\", x0, x1)\n        },\n    )\n}\n</code></pre>"},{"location":"examples/custom_pattern_matching/#example-2-matching-tree-nodes","title":"Example 2: Matching Tree Nodes","text":"<p>Notice that CombineTreeValues function match against TreePair type parameters.</p> example/tree.go<pre><code>//go:tag mkunion:\"Tree[A]\"\ntype (\n    Branch[A any] struct{ L, R Tree[A] }\n    Leaf[A any]   struct{ Value A }\n)\n\n\n//go:tag mkmatch:\"TreePairMatch\"\ntype TreePair[T0, T1 any] interface {\n    MatchLeafs(*Leaf[int], *Leaf[int])\n    MatchBranches(*Branch[int], any)\n    MatchMixed(any, any)\n}\n\n\n// CombineTreeValues returns sum of tree nodes for int nodes, and for others returns 0\n// function is safe to use with any time, even if it's not a Tree\nfunc CombineTreeValues(a, b any) int {\n    return TreePairMatchR1(\n        a, b,\n        func(x0 *Leaf[int], x1 *Leaf[int]) int {\n            // Both are leaves - add their values\n            return x0.Value + x1.Value\n        },\n        func(x0 *Branch[int], x1 any) int {\n            // First is branch - return special value\n            return CombineTreeValues(x0.L, x0.R) + 1\n        },\n        func(x0 any, x1 any) int {\n            // Mixed types - return default\n            return 0\n        },\n    )\n}\n</code></pre>"},{"location":"examples/custom_pattern_matching/#example-3-state-machine-transitions","title":"Example 3: State Machine Transitions","text":"<p>Custom pattern matching is particularly useful for state machines:</p> example/transition.go<pre><code>var (\n    ErrAlreadyProcessing = errors.New(\"already processing\")\n    ErrInvalidTransition = errors.New(\"invalid transition\")\n)\n\n//go:tag mkmatch\ntype TransitionMatch[S State, C Command] interface {\n    ProcessingStart(*Processing, *StartCommand)\n    ProcessingComplete(*Processing, *CompleteCommand)\n    InitialStart(*Initial, *StartCommand)\n    Default(State, Command)\n}\n\n\nfunc Transition(state State, cmd Command) (State, error) {\n    return TransitionMatchR2(\n        state, cmd,\n        func(s *Processing, c *StartCommand) (State, error) {\n            return nil, ErrAlreadyProcessing\n        },\n        func(s *Processing, c *CompleteCommand) (State, error) {\n            return &amp;Complete{Result: c.Result}, nil\n        },\n        func(s *Initial, c *StartCommand) (State, error) {\n            return &amp;Processing{ID: c.ID}, nil\n        },\n        func(s State, c Command) (State, error) {\n            return nil, ErrInvalidTransition\n        },\n    )\n}\n</code></pre>"},{"location":"examples/custom_pattern_matching/#best-practices","title":"Best Practices","text":"<ol> <li>Order Matters: The generated function checks patterns in the order they appear in the interface. Put more specific patterns first.</li> <li>Use Wildcards Wisely: The <code>any</code> type acts as a wildcard. Use it for catch-all cases or when you need to handle any type.</li> <li>Exhaustiveness: Always include a catch-all pattern (typically with <code>any</code> parameters) to ensure all cases are handled.</li> <li>Naming Conventions:<ul> <li>Use descriptive names for match methods</li> <li>The interface name becomes the function prefix</li> <li>Consider the domain when naming</li> </ul> </li> <li>Type Safety: The generated functions are fully type-safe and will panic if the patterns are not exhaustive.</li> </ol>"},{"location":"examples/custom_pattern_matching/#limitations","title":"Limitations","text":"<ol> <li>Custom pattern matching functions are limited to matching on up to 3 return values (R0, R1, R2, R3).</li> <li>The interface methods must have parameters matching the type parameters in order.</li> <li>All methods in the interface must have the same number of parameters.</li> </ol>"},{"location":"examples/custom_pattern_matching/#summary","title":"Summary","text":"<p>Custom pattern matching in <code>mkunion</code> provides a powerful way to handle complex matching scenarios while maintaining type safety.  By defining interfaces with the <code>//go:tag mkmatch:\"\"</code> annotation, you can create specialized matching functions that work across multiple values and implement domain-specific logic.</p> <p>This feature is particularly useful for:</p> <ul> <li>State machine implementations</li> <li>Complex data transformations</li> <li>Multi-value comparisons</li> <li>Domain-specific pattern matching logic</li> </ul> <p>Combined with <code>mkunion</code>'s automatic union type generation and standard pattern matching, custom pattern matching completes a comprehensive toolkit for working with algebraic data types in Go.</p>"},{"location":"examples/custom_pattern_matching/#next-steps","title":"Next steps","text":"<ul> <li>Union and generic types - Learn about generic unions</li> <li>Marshaling union in JSON - Learn about marshaling and unmarshalling of union types in JSON</li> <li>State Machines and unions - Learn about modeling state machines and how union type helps</li> </ul>"},{"location":"examples/generic_union/","title":"Union and generic types","text":"<p>MkUnion will generate generic unions for you.</p> <p>For example, let's say you want to create a recursive tree data structure, that in its leaves will hold a value of <code>A</code> type.</p>"},{"location":"examples/generic_union/#declaration-and-generation","title":"Declaration and generation","text":"<p>You can use <code>mkunion</code> to create a union type for the tree:</p> example/tree.go<pre><code>//go:tag mkunion:\"Tree[A]\"\ntype (\n    Branch[A any] struct{ L, R Tree[A] }\n    Leaf[A any]   struct{ Value A }\n)\n</code></pre> <p>After you run generation (as described in getting started),  you have access to the same features as with non-generic unions.</p> <p>When defining generic unions, you must follow these requirements:</p> <ol> <li>Type parameters must be specified in the tag: The union tag must include all type parameters used by the variant types.</li> <li>Parameter names must match: Type parameter names in the tag must match those used in variant types both by name and position.</li> <li>Same number of parameters: Each variant type needs to have the same number of type parameters.</li> </ol>"},{"location":"examples/generic_union/#matching-function","title":"Matching function","text":"<p>Let's define a higher-order function <code>ReduceTree</code> that will traverse leaves in <code>Tree</code> and produce a single value.</p> <p>This function uses <code>MatchTreeR1</code> function that is generated automatically for you.</p> example/tree.go<pre><code>func ReduceTree[A, B any](x Tree[A], f func(A, B) B, init B) B {\n    return MatchTreeR1(\n        x,\n        func(x *Branch[A]) B {\n            return ReduceTree(x.R, f, ReduceTree(x.L, f, init))\n        }, func(x *Leaf[A]) B {\n            return f(x.Value, init)\n        },\n    )\n}\n</code></pre>"},{"location":"examples/generic_union/#example-usage","title":"Example usage","text":"<p>You can use such function to sum all values in the tree, assuming that tree is of type <code>Tree[int]</code>:</p> example/tree_test.go<pre><code>func Example_treeSumValues() {\n    tree := &amp;Branch[int]{\n        L: &amp;Leaf[int]{Value: 1},\n        R: &amp;Branch[int]{\n            L: &amp;Branch[int]{\n                L: &amp;Leaf[int]{Value: 2},\n                R: &amp;Leaf[int]{Value: 3},\n            },\n            R: &amp;Leaf[int]{Value: 4},\n        },\n    }\n\n    result := ReduceTree(tree, func(x int, agg int) int {\n        return agg + x\n    }, 0)\n\n    fmt.Println(result)\n    // Output: 10\n}\n</code></pre> <p>You can also reduce the tree to a complex structure, for example, to keep track of the order of values in the tree, along with the sum of all values in the tree.</p> example/tree_test.go<pre><code>type orderAgg struct {\n    Order  []int\n    Result int\n}\n\nfunc Example_treeCustomReduction() {\n    tree := &amp;Branch[int]{\n        L: &amp;Leaf[int]{Value: 1},\n        R: &amp;Branch[int]{\n            L: &amp;Branch[int]{\n                L: &amp;Leaf[int]{Value: 2},\n                R: &amp;Leaf[int]{Value: 3},\n            },\n            R: &amp;Leaf[int]{Value: 4},\n        },\n    }\n\n    result := ReduceTree(tree, func(x int, agg orderAgg) orderAgg {\n        return orderAgg{\n            Order:  append(agg.Order, x),\n            Result: agg.Result + x,\n        }\n    }, orderAgg{\n        Order:  []int{},\n        Result: 0,\n    })\n    fmt.Println(result.Order)\n    fmt.Println(result.Result)\n    // Output: [1 2 3 4]\n    // 10\n}\n</code></pre>"},{"location":"examples/generic_union/#next-steps","title":"Next steps","text":"<ul> <li>Composability and Type Safety - Learn how to compose <code>Option[T]</code> and <code>Result[T, E]</code> types (Advanced topic).</li> <li>Custom Pattern Matching - Learn about custom pattern matching</li> <li>Marshaling union in JSON - Learn about marshaling and unmarshalling of union types in JSON</li> <li>State Machines and unions - Learn about modeling state machines and how union type helps</li> </ul>"},{"location":"examples/json/","title":"Marshaling union as JSON","text":"<p>MkUnion provides you with utility functions that allow you to marshal and unmarshal union types to JSON,  reducing the burden of writing custom marshaling and unmarshaling functions for union types.</p> <ul> <li><code>shared.JSONMarshal[A any](in A) ([]byte, error)</code></li> <li><code>shared.JSONUnmarshal[A any](data []byte) (A, error)</code></li> </ul> <p>Below is an example of how to use these functions and how the output JSON looks like.</p> example/tree_json_test.go<pre><code>import (\n    \"github.com/widmogrod/mkunion/x/shared\"\n)\n\n\nfunc Example_treeJson() {\n    tree := &amp;Branch[int]{\n        L: &amp;Leaf[int]{Value: 1},\n        R: &amp;Branch[int]{\n            L: &amp;Branch[int]{\n                L: &amp;Leaf[int]{Value: 2},\n                R: &amp;Leaf[int]{Value: 3},\n            },\n            R: &amp;Leaf[int]{Value: 4},\n        },\n    }\n\n    json, _ := shared.JSONMarshal[Tree[int]](tree)\n    result, _ := shared.JSONUnmarshal[Tree[int]](json)\n\n    fmt.Println(string(json))\n    if diff := cmp.Diff(tree, result); diff != \"\" {\n        fmt.Println(\"expected tree and result to be equal, but got diff:\", diff)\n    }\n    //Output: {\"$type\":\"example.Branch\",\"example.Branch\":{\"L\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":1}},\"R\":{\"$type\":\"example.Branch\",\"example.Branch\":{\"L\":{\"$type\":\"example.Branch\",\"example.Branch\":{\"L\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":2}},\"R\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":3}}}},\"R\":{\"$type\":\"example.Leaf\",\"example.Leaf\":{\"Value\":4}}}}}}\n}\n</code></pre> <p>Formatted JSON output of the example above: <pre><code>{\n  \"$type\": \"example.Branch\",\n  \"example.Branch\": {\n    \"L\": {\n      \"$type\": \"example.Leaf\",\n      \"example.Leaf\": {\n        \"Value\": 1\n      }\n    },\n    \"R\": {\n      \"$type\": \"example.Branch\",\n      \"example.Branch\": {\n        \"L\": {\n          \"$type\": \"example.Branch\",\n          \"example.Branch\": {\n            \"L\": {\n              \"$type\": \"example.Leaf\",\n              \"example.Leaf\": {\n                \"Value\": 2\n              }\n            },\n            \"R\": {\n              \"$type\": \"example.Leaf\",\n              \"example.Leaf\": {\n                \"Value\": 3\n              }\n            }\n          }\n        },\n        \"R\": {\n          \"$type\": \"example.Leaf\",\n          \"example.Leaf\": {\n            \"Value\": 4\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre></p> <p>There are a few things that you can notice in this example:</p> <ul> <li> <p>Each union type has a discriminator field, <code>$type</code>, which holds the type name, and a corresponding key with the name of the type, which holds the value of the union variant.</p> <ul> <li>This is an opinionated approach, and the library doesn't allow it to be changed.   I was experimenting with making this behavior customizable, but it makes the code and API more complex, and I prefer to keep it simple, thereby increasing interoperability between different libraries and applications.</li> </ul> </li> <li> <p>Recursive union types are supported and are marshaled as nested JSON objects.</p> </li> <li> <p><code>$type</code> doesn't have to have the full package import name, nor type parameter,   mostly because in <code>shared.JSONUnmarshal[Tree[int]](json)</code> you hint that your code accepts <code>Tree[int]</code>.</p> <ul> <li>I'm considering adding explicit type discriminators like <code>example.Branch[int]</code> or <code>example.Leaf[int]</code>.   It could increase type strictness on the client side, but it makes generating TypeScript types more complex, and I'm not sure if it's worth it.</li> </ul> </li> <li> <p>It's not shown in this example, but you can also reference types and union types from other packages, and serialization will work as expected.</p> </li> </ul>"},{"location":"examples/json/#next-steps","title":"Next steps","text":"<ul> <li>Union and generic types - Learn about generic unions</li> <li>Custom Pattern Matching - Learn about custom pattern matching</li> <li>State Machines and unions - Learn about modeling state machines and how union type helps</li> </ul>"},{"location":"examples/state_machine/","title":"MkUnion and state machines in Go","text":"<p>This document will show how to use <code>mkunion</code> to manage application state using the example of an Order Service.  You will learn:</p> <ul> <li>how to model state machines in Go, and find similarities to \"clean architecture\"</li> <li>How to test state machines (with fuzzing), and as a bonus, you will get mermaid diagrams for free</li> <li>How to persist state in a database and how optimistic concurrency helps resolve concurrency conflicts</li> <li>How to handle errors in state machines and build foundations for self-healing systems</li> </ul>"},{"location":"examples/state_machine/#working-example","title":"Working example","text":"<p>As a driving example, we will use an e-commerce inspired Order Service that can be in one of the following states:</p> <ul> <li><code>Pending</code> - The order is created and is waiting for someone to process it.</li> <li><code>Processing</code> - The order is being processed; a human is going to pick up items from the warehouse and pack them.</li> <li><code>Cancelled</code> - The order was cancelled. There can be many reasons, one of them being that the warehouse is out of stock.</li> <li><code>Completed</code> - The order is completed and can be shipped to the customer.</li> </ul> <p>Such states have rules that govern transitions; for example, an order cannot be cancelled if it's already completed, and so on.</p> <p>We need to have a way to trigger changes in state, like creating an order that is pending for processing, or cancelling an order. We will call these triggers commands.</p> <p>Some of these rules could change in the future, and we want to be able to change them without rewriting the whole application. This also informs us that our design should be open for extension.</p> <p>Side note: if you want to go straight to the final code product, then go into the example/state/ directory and have fun exploring.</p>"},{"location":"examples/state_machine/#modeling-commands-and-states","title":"Modeling commands and states","text":"<p>Our example can be represented as a state machine that looks like this: simple_machine_test.go.state_diagram.mmd <pre><code>stateDiagram\n    state_OrderCancelled: *state.OrderCancelled\n    state_OrderCompleted: *state.OrderCompleted\n    state_OrderError: *state.OrderError\n    state_OrderPending: *state.OrderPending\n    state_OrderProcessing: *state.OrderProcessing\n\n    state_OrderProcessing --&gt; state_OrderCancelled: *state.CancelOrderCMD\n    [*] --&gt; state_OrderPending: *state.CreateOrderCMD\n    state_OrderPending --&gt; state_OrderProcessing: *state.MarkAsProcessingCMD\n    state_OrderProcessing --&gt; state_OrderCompleted: *state.MarkOrderCompleteCMD\n    state_OrderProcessing --&gt; state_OrderError: *state.MarkOrderCompleteCMD\n    state_OrderError --&gt; state_OrderCompleted: *state.TryRecoverErrorCMD\n</code></pre></p> <p>In this diagram, we can see that we have 5 states and 6 commands that can trigger transitions between states, shown as arrows.</p> <p>Because this diagram is generated from code, it has names that represent types in Go that we use in the implementation. </p> <p>For example, <code>*state.CreateOrderCMD</code>:</p> <ul> <li><code>state</code> is the package name.</li> <li><code>CreateOrderCMD</code> is a struct name in that package.</li> <li>The <code>CMD</code> suffix is a naming convention that is optional, but I find it makes the code more readable and easier to distinguish commands from states.</li> </ul> <p>Below is a code snippet that demonstrates a complete model of the state and commands of the Order Service that we discussed.</p> <p>Notice that we use <code>mkunion</code> to group commands and states. (Look for <code>//go:tag mkunion:\"Command\"</code>)</p> <p>This is one example of how union types can be used in Go.  Historically in Go, it would be very hard to achieve such a thing, and it would require a lot of boilerplate code. Here, the interface that groups these types is generated automatically. You can focus on modeling your domain.</p> example/state/model.go<pre><code>package state\n\nimport \"time\"\n\n//\n//go:tag mkunion:\"Command\"\ntype (\n    CreateOrderCMD struct {\n        OrderID OrderID\n        Attr    OrderAttr\n    }\n    MarkAsProcessingCMD struct {\n        OrderID  OrderID\n        WorkerID WorkerID\n    }\n    CancelOrderCMD struct {\n        OrderID OrderID\n        Reason  string\n    }\n    MarkOrderCompleteCMD struct {\n        OrderID  OrderID\n        WorkerID WorkerID\n    }\n    // TryRecoverErrorCMD is a special command that can be used to recover from error state\n    // you can have different \"self-healing\" rules based on the error code or even return to previous healthy state\n    TryRecoverErrorCMD struct {\n        OrderID OrderID\n    }\n)\n\n\n//\n//go:tag mkunion:\"State\"\ntype (\n    OrderPending struct {\n        Order Order\n    }\n    OrderProcessing struct {\n        Order Order\n    }\n    OrderCompleted struct {\n        Order Order\n    }\n    OrderCancelled struct {\n        Order Order\n    }\n    // OrderError is a special state that represent an error\n    // during order processing, you can have different \"self-healing jobs\" based on the error code\n    // like retrying the order, cancel the order, etc.\n    //\n    // This pattern enables:\n    // 1. Perfect reproduction of the failure\n    // 2. Automatic retry with the same command\n    // 3. Debugging with full context\n    // 4. Recovery to previous valid state\n    OrderError struct {\n        // error information\n        Retried   int\n        RetriedAt *time.Time\n\n        ProblemCode ProblemCode\n\n        ProblemCommand Command\n        ProblemState   State\n    }\n)\n\n\ntype (\n    // OrderID Price, Quantity are placeholders for value objects, to ensure better data semantic and type safety\n    OrderID  = string\n    Price    = float64\n    Quantity = int\n\n    OrderAttr struct {\n        // placeholder for order attributes\n        // like customer name, address, etc.\n        // like product name, price, etc.\n        // for simplicity we only have Price and Quantity\n        Price    Price\n        Quantity Quantity\n    }\n\n    // WorkerID represent human that process the order\n    WorkerID = string\n\n    // Order everything we know about order\n    Order struct {\n        ID               OrderID\n        OrderAttr        OrderAttr\n        WorkerID         WorkerID\n        StockRemovedAt   *time.Time\n        PaymentChargedAt *time.Time\n        DeliveredAt      *time.Time\n        CancelledAt      *time.Time\n        CancelledReason  string\n    }\n)\n\ntype ProblemCode int\n\nconst (\n    ProblemWarehouseAPIUnreachable ProblemCode = iota\n    ProblemPaymentAPIUnreachable\n)\n</code></pre>"},{"location":"examples/state_machine/#modeling-transitions","title":"Modeling transitions","text":"<p>One thing that is missing is the implementation of transitions between states.  There are a few ways to do it. I will show you how to do it using a functional approach (think <code>reduce</code> or <code>map</code> function).</p> <p>Let's name the function that we will build <code>Transition</code> and define it as:</p> <pre><code>func Transition(ctx context.Context, dep Dependencies, cmd Command, state State) (State, error)\n</code></pre> <p>Our function has a few arguments; let's break them down:</p> <ul> <li><code>ctx</code> is the standard Go context, which is used to pass deadlines, cancellation signals, etc.</li> <li><code>dep</code> encapsulates dependencies like API clients, database connections, configuration, context, etc.    \u2014 everything that is needed for a complete production implementation.</li> <li><code>cmd</code> is a command that we want to apply to the state,     and it has the <code>Command</code> interface, which was generated by <code>mkunion</code> when it was used to group commands.</li> <li><code>state</code> is a state that we want to apply our command to and change,     and it has the <code>State</code> interface, which was generated similarly to the <code>Command</code> interface.</li> </ul> <p>Our function must return either a new state or an error if something went wrong during the transition, like a network error or a validation error.</p> <p>Below is a snippet of the implementation of the <code>Transition</code> function for our Order Service:</p> example/state/machine.go<pre><code>        func(x *CreateOrderCMD) (State, error) {\n            // 1. Structural validation as simple checks and explicit error type\n            if x.OrderID == \"\" {\n                return nil, ErrOrderIDRequired\n            }\n\n            switch state.(type) {\n            case nil:\n                o := Order{\n                    ID:        x.OrderID,\n                    OrderAttr: x.Attr,\n                }\n                return &amp;OrderPending{\n                    Order: o,\n                }, nil\n            }\n\n            return nil, ErrOrderAlreadyExist\n        },\n// ...\n// rest removed for brevity \n// ...\n</code></pre> <p>You can notice a few patterns in this snippet:</p> <ul> <li>The <code>Dependency</code> interface helps us to keep dependencies well-defined, which greatly helps in testability and readability of the code. </li> <li>The use of the generated function <code>MatchCommandR2</code> to exhaustively match all commands.    This is powerful; when a new command is added, you can be sure that you will get a compile-time error if you don't handle it.</li> <li>Validation of commands is done in the transition function. The current implementation is simple, but you can use go-validate to make it more robust, or refactor the code and introduce domain helper functions or methods to the types.</li> <li>Each command checks the state to which it is being applied using a <code>switch</code> statement; it ignores states that it doesn't care about.    This means as an implementer, you have to focus only on a small part of the picture and not worry about the rest of the states.    This is also an example where non-exhaustive use of the <code>switch</code> statement is welcome.</li> </ul> <p>Simple, isn't it? Simplicity also comes from the fact that we don't have to worry about marshalling/unmarshalling data or working with the database; those are things that will be done in other parts of the application, keeping this part clean and focused on business logic.</p> <p>Note: The implementation for educational purposes is kept in one big function,  but for large projects, it may be better to split it into smaller functions,  or define an <code>OrderService</code> struct that conforms to the visitor pattern interface, which was also generated for you:</p> example/state/model_union_gen.go<pre><code>type CommandVisitor interface {\n    VisitCreateOrderCMD(v *CreateOrderCMD) any\n    VisitMarkAsProcessingCMD(v *MarkAsProcessingCMD) any\n    VisitCancelOrderCMD(v *CancelOrderCMD) any\n    VisitMarkOrderCompleteCMD(v *MarkOrderCompleteCMD) any\n    VisitTryRecoverErrorCMD(v *TryRecoverErrorCMD) any\n}\n</code></pre>"},{"location":"examples/state_machine/#testing-state-machines-self-documenting","title":"Testing state machines &amp; self-documenting","text":"<p>Before we go further, let's talk about testing our implementation.</p> <p>Testing will not only help us ensure that our implementation is correct but also help us document our state machine  and discover transitions that we didn't think about, that should or shouldn't be possible.</p> <p>Here is how you can test a state machine in a declarative way, using the <code>mkunion/x/machine</code> package:</p> <p>example/state/machine_test.go<pre><code>func TestSuite(t *testing.T) {\n    now := time.Now()\n    var di Dependency = &amp;DependencyMock{\n        TimeNowFunc: func() *time.Time {\n            return &amp;now\n        },\n    }\n    suite := machine.NewTestSuite(di, NewMachine)\n    suite.Case(t, \"happy path of order state transition\",\n        func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n            c.\n                GivenCommand(&amp;CreateOrderCMD{OrderID: \"123\", Attr: order}).\n                ThenState(t, &amp;OrderPending{\n                    Order: Order{\n                        ID:        \"123\",\n                        OrderAttr: order,\n                    },\n                }).\n                ForkCase(t, \"start processing order\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                    c.\n                        GivenCommand(&amp;MarkAsProcessingCMD{\n                            OrderID:  \"123\",\n                            WorkerID: \"worker-1\",\n                        }).\n                        ThenState(t, &amp;OrderProcessing{\n                            Order: Order{\n                                ID:        \"123\",\n                                OrderAttr: order,\n                                WorkerID:  \"worker-1\",\n                            },\n                        }).\n                        ForkCase(t, \"mark order as completed\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                            c.\n                                GivenCommand(&amp;MarkOrderCompleteCMD{\n                                    OrderID:  \"123\",\n                                    WorkerID: \"worker-2\",\n                                }).\n                                ThenState(t, &amp;OrderCompleted{\n                                    Order: Order{\n                                        ID:               \"123\",\n                                        OrderAttr:        order,\n                                        WorkerID:         \"worker-1\",\n                                        DeliveredAt:      &amp;now,\n                                        StockRemovedAt:   &amp;now,\n                                        PaymentChargedAt: &amp;now,\n                                    },\n                                })\n                        }).\n</code></pre> A few things to notice in this test:</p> <ul> <li>We use standard Go testing.</li> <li>We use <code>machine.NewTestSuite</code> as a standard way to test state machines.</li> <li>We start with describing the happy path and use <code>suite.Case</code> to define a test case.</li> <li>But most importantly, we define test cases using <code>GivenCommand</code> and <code>ThenState</code> functions, which help make the test more readable and hopefully self-documenting.</li> <li>You can see the use of the <code>ForkCase</code> command, which allows you to take the definition of a state declared in the <code>ThenState</code> command, apply a new command to it, and expect a new state.</li> <li>Less visible is the use of <code>moq</code> to generate <code>DependencyMock</code> for dependencies, but it's still important for writing more concise code.</li> </ul> <p>I know it's subjective, but I find it very readable and easy to understand, even for non-programmers.</p> <p>Important Design Principle: The test suite enforces that all states must be created through command sequences rather than direct instantiation. This ensures tests only work with reachable states and self-document valid state transitions. See Testing Philosophy in the best practices guide for details.</p>"},{"location":"examples/state_machine/#generating-state-diagram-from-tests","title":"Generating state diagram from tests","text":"<p>The last bit is this line at the bottom of the test file:</p> example/state/machine_test.go<pre><code>    if suite.AssertSelfDocumentStateDiagram(t, \"machine_test.go\") {\n        suite.SelfDocumentStateDiagram(t, \"machine_test.go\")\n    }\n</code></pre> <p>This code takes all inputs provided in the test suite and fuzzes them, applies commands to random states, and records the results of those transitions.</p> <ul> <li><code>SelfDocumentStateDiagram</code> - produces two <code>mermaid</code> diagrams that show all possible transitions that are possible in our state machine.</li> <li><code>AssertSelfDocumentStateDiagram</code> can be used to compare newly generated diagrams to diagrams committed to the repository and fail the test if they are different.    You don't have to use it, but it's good practice to ensure that your state machine is well-tested and doesn't regress without you noticing.</li> </ul> <p>There are two diagrams that are generated.</p> <p>One is a diagram of ONLY successful transitions that you saw at the beginning of this post.</p> <pre><code>stateDiagram\n    state_OrderCancelled: *state.OrderCancelled\n    state_OrderCompleted: *state.OrderCompleted\n    state_OrderError: *state.OrderError\n    state_OrderPending: *state.OrderPending\n    state_OrderProcessing: *state.OrderProcessing\n\n    state_OrderProcessing --&gt; state_OrderCancelled: *state.CancelOrderCMD\n    [*] --&gt; state_OrderPending: *state.CreateOrderCMD\n    state_OrderPending --&gt; state_OrderProcessing: *state.MarkAsProcessingCMD\n    state_OrderProcessing --&gt; state_OrderCompleted: *state.MarkOrderCompleteCMD\n    state_OrderProcessing --&gt; state_OrderError: *state.MarkOrderCompleteCMD\n    state_OrderError --&gt; state_OrderCompleted: *state.TryRecoverErrorCMD\n</code></pre> <p>Second is a diagram that includes commands that resulted in errors: <pre><code>stateDiagram\n    state_OrderCancelled: *state.OrderCancelled\n    state_OrderCompleted: *state.OrderCompleted\n    state_OrderError: *state.OrderError\n    state_OrderPending: *state.OrderPending\n    state_OrderProcessing: *state.OrderProcessing\n\n    %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    state_OrderCancelled --&gt; state_OrderCancelled: \u274c*state.CancelOrderCMD\n    %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    state_OrderCompleted --&gt; state_OrderCompleted: \u274c*state.CancelOrderCMD\n    %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    state_OrderError --&gt; state_OrderError: \u274c*state.CancelOrderCMD\n    %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    state_OrderPending --&gt; state_OrderPending: \u274c*state.CancelOrderCMD\n    state_OrderProcessing --&gt; state_OrderCancelled: *state.CancelOrderCMD\n    %% error=cannot cancel order, order must be processing to cancel it; invalid transition \n    [*] --&gt; [*]: \u274c*state.CancelOrderCMD\n    %% error=cannot attemp order creation, order exists: invalid transition \n    state_OrderCancelled --&gt; state_OrderCancelled: \u274c*state.CreateOrderCMD\n    %% error=cannot attemp order creation, order exists: invalid transition \n    state_OrderCompleted --&gt; state_OrderCompleted: \u274c*state.CreateOrderCMD\n    %% error=cannot attemp order creation, order exists: invalid transition \n    state_OrderError --&gt; state_OrderError: \u274c*state.CreateOrderCMD\n    %% error=cannot attemp order creation, order exists: invalid transition \n    state_OrderPending --&gt; state_OrderPending: \u274c*state.CreateOrderCMD\n    %% error=cannot attemp order creation, order exists: invalid transition \n    state_OrderProcessing --&gt; state_OrderProcessing: \u274c*state.CreateOrderCMD\n    [*] --&gt; state_OrderPending: *state.CreateOrderCMD\n    %% error=invalid transition \n    state_OrderCancelled --&gt; state_OrderCancelled: \u274c*state.MarkAsProcessingCMD\n    %% error=invalid transition \n    state_OrderCompleted --&gt; state_OrderCompleted: \u274c*state.MarkAsProcessingCMD\n    %% error=invalid transition \n    state_OrderError --&gt; state_OrderError: \u274c*state.MarkAsProcessingCMD\n    state_OrderPending --&gt; state_OrderProcessing: *state.MarkAsProcessingCMD\n    %% error=invalid transition \n    state_OrderProcessing --&gt; state_OrderProcessing: \u274c*state.MarkAsProcessingCMD\n    %% error=invalid transition \n    [*] --&gt; [*]: \u274c*state.MarkAsProcessingCMD\n    %% error=cannot mark order as complete, order is not being process; invalid transition \n    state_OrderCancelled --&gt; state_OrderCancelled: \u274c*state.MarkOrderCompleteCMD\n    %% error=cannot mark order as complete, order is not being process; invalid transition \n    state_OrderCompleted --&gt; state_OrderCompleted: \u274c*state.MarkOrderCompleteCMD\n    %% error=cannot mark order as complete, order is not being process; invalid transition \n    state_OrderError --&gt; state_OrderError: \u274c*state.MarkOrderCompleteCMD\n    %% error=cannot mark order as complete, order is not being process; invalid transition \n    state_OrderPending --&gt; state_OrderPending: \u274c*state.MarkOrderCompleteCMD\n    state_OrderProcessing --&gt; state_OrderCompleted: *state.MarkOrderCompleteCMD\n    state_OrderProcessing --&gt; state_OrderError: *state.MarkOrderCompleteCMD\n    %% error=cannot self approve order; validation failed \n    state_OrderProcessing --&gt; state_OrderProcessing: \u274c*state.MarkOrderCompleteCMD\n    %% error=cannot mark order as complete, order is not being process; invalid transition \n    [*] --&gt; [*]: \u274c*state.MarkOrderCompleteCMD\n    %% error=cannot recover from non error state; invalid transition \n    state_OrderCancelled --&gt; state_OrderCancelled: \u274c*state.TryRecoverErrorCMD\n    %% error=cannot recover from non error state; invalid transition \n    state_OrderCompleted --&gt; state_OrderCompleted: \u274c*state.TryRecoverErrorCMD\n    state_OrderError --&gt; state_OrderCompleted: *state.TryRecoverErrorCMD\n    %% error=cannot recover from non error state; invalid transition \n    state_OrderPending --&gt; state_OrderPending: \u274c*state.TryRecoverErrorCMD\n    %% error=cannot recover from non error state; invalid transition \n    state_OrderProcessing --&gt; state_OrderProcessing: \u274c*state.TryRecoverErrorCMD\n    %% error=cannot recover from non error state; invalid transition \n    [*] --&gt; [*]: \u274c*state.TryRecoverErrorCMD\n</code></pre></p> <p>Those diagrams are stored in the same directory as the test file and are prefixed with the name used in the <code>AssertSelfDocumentStateDiagram</code> function. <pre><code>machine_test.go.state_diagram.mmd\nmachine_test.go.state_diagram_with_errors.mmd\n</code></pre></p>"},{"location":"examples/state_machine/#state-machines-builder","title":"State machines builder","text":"<p>MkUnion provides a <code>*machine.Machine[Dependency, Command, State]</code> struct that wires the Transition, dependencies, and state together. It provides methods like:</p> <ul> <li><code>Handle(ctx context.Context, cmd C) error</code> that applies a command to the state and returns an error if something went wrong during the transition.</li> <li><code>State() S</code> that returns the current state of the machine.</li> <li><code>Dep() D</code> that returns the dependencies the machine was built with.</li> </ul> <p>This standard helps build on top of it; for example, the testing library we use in Testing state machines &amp; self-documenting leverages it.</p> <p>Another good practice is that every package that defines a state machine in the way described here  should provide a <code>NewMachine</code> function that will return a bootstrapped machine with package types, like so:</p> example/state/machine.go<pre><code>func NewMachine(di Dependency, init State) *machine.Machine[Dependency, Command, State] {\n    return machine.NewMachine(di, Transition, init)\n}\n</code></pre>"},{"location":"examples/state_machine/#conclusion","title":"Conclusion","text":"<p>Now we have all the pieces in place, and we can start building our application.</p> <ul> <li>We have a <code>NewMachine</code> constructor that will give us an object to use in our application.</li> <li>We have tests that will ensure that our state machine is correct; fuzzy tests help discover edge cases, and lastly, we get diagrams showing which paths we tested and covered.</li> <li>We saw how this approach focuses on business logic and keeps it separate from other concerns like the database or API clients. This is one of the principles of clean architecture.</li> </ul> <p>For a comprehensive guide on best practices, patterns, and advanced techniques, see our State Machine Best Practices guide.</p>"},{"location":"examples/state_machine/#next-steps","title":"Next steps","text":"<ul> <li>State Machine Best Practices - Learn about file organization, naming conventions, testing strategies, and advanced patterns</li> <li>Persisting union in database - Learn how to persist state in a database and handle concurrency conflicts</li> <li>Handling errors in state machines - Build self-healing systems by treating errors as states</li> <li>Composability and Type Safety - Learn about composability of types</li> </ul>"},{"location":"examples/state_machine_best_practices/","title":"State Machine Best Practices","text":"<p>This guide covers best practices, patterns, and techniques for building robust state machines with mkunion. Whether you're building simple state machines or complex distributed systems, these practices will help you create maintainable and scalable solutions.</p>"},{"location":"examples/state_machine_best_practices/#best-practices","title":"Best Practices","text":"<p>When building state machines with mkunion, following these practices will help you create maintainable and robust systems:</p>"},{"location":"examples/state_machine_best_practices/#file-organization","title":"File Organization","text":"<p>Organize your state machine code across files for better maintainability:</p> <ol> <li> <p><code>model.go</code>: State and command definitions with other model types like value objects, etc.    example/state/model.go<pre><code>//\n//go:tag mkunion:\"Command\"\ntype (\n CreateOrderCMD struct {\n     OrderID OrderID\n     Attr    OrderAttr\n }\n MarkAsProcessingCMD struct {\n     OrderID  OrderID\n     WorkerID WorkerID\n }\n CancelOrderCMD struct {\n     OrderID OrderID\n     Reason  string\n }\n MarkOrderCompleteCMD struct {\n     OrderID  OrderID\n     WorkerID WorkerID\n }\n // TryRecoverErrorCMD is a special command that can be used to recover from error state\n // you can have different \"self-healing\" rules based on the error code or even return to previous healthy state\n TryRecoverErrorCMD struct {\n     OrderID OrderID\n }\n)\n\n//\n//go:tag mkunion:\"State\"\ntype (\n OrderPending struct {\n     Order Order\n }\n OrderProcessing struct {\n     Order Order\n }\n OrderCompleted struct {\n     Order Order\n }\n OrderCancelled struct {\n     Order Order\n }\n // OrderError is a special state that represent an error\n // during order processing, you can have different \"self-healing jobs\" based on the error code\n // like retrying the order, cancel the order, etc.\n //\n // This pattern enables:\n // 1. Perfect reproduction of the failure\n // 2. Automatic retry with the same command\n // 3. Debugging with full context\n // 4. Recovery to previous valid state\n OrderError struct {\n     // error information\n     Retried   int\n     RetriedAt *time.Time\n\n     ProblemCode ProblemCode\n\n     ProblemCommand Command\n     ProblemState   State\n }\n)\n\ntype (\n // OrderID Price, Quantity are placeholders for value objects, to ensure better data semantic and type safety\n OrderID  = string\n Price    = float64\n Quantity = int\n\n OrderAttr struct {\n     // placeholder for order attributes\n     // like customer name, address, etc.\n     // like product name, price, etc.\n     // for simplicity we only have Price and Quantity\n     Price    Price\n     Quantity Quantity\n }\n\n // WorkerID represent human that process the order\n WorkerID = string\n\n // Order everything we know about order\n Order struct {\n     ID               OrderID\n     OrderAttr        OrderAttr\n     WorkerID         WorkerID\n     StockRemovedAt   *time.Time\n     PaymentChargedAt *time.Time\n     DeliveredAt      *time.Time\n     CancelledAt      *time.Time\n     CancelledReason  string\n }\n)\n\ntype ProblemCode int\n\nconst (\n ProblemWarehouseAPIUnreachable ProblemCode = iota\n ProblemPaymentAPIUnreachable\n)\n</code></pre></p> </li> <li> <p><code>machine.go</code>: Core state machine initialization, and most importantly transition logic:    example/state/machine.go<pre><code>//go:generate moq -with-resets -stub -out machine_mock.go . Dependency\ntype Dependency interface {\n TimeNow() *time.Time\n WarehouseRemoveStock(ctx context.Context, quantity Quantity) error\n PaymentCharge(ctx context.Context, price Price) error\n}\n\nfunc NewMachine(di Dependency, init State) *machine.Machine[Dependency, Command, State] {\n return machine.NewMachine(di, Transition, init)\n}\n\n\nfunc Transition(ctx context.Context, di Dependency, cmd Command, state State) (State, error) {\n return MatchCommandR2(\n     cmd,\n     func(x *CreateOrderCMD) (State, error) {\n         // 1. Structural validation as simple checks and explicit error type\n         if x.OrderID == \"\" {\n             return nil, ErrOrderIDRequired\n         }\n\n         switch state.(type) {\n         case nil:\n             o := Order{\n                 ID:        x.OrderID,\n                 OrderAttr: x.Attr,\n             }\n             return &amp;OrderPending{\n                 Order: o,\n             }, nil\n         }\n\n         return nil, ErrOrderAlreadyExist\n     },\n// ... and so on\n</code></pre></p> </li> </ol>"},{"location":"examples/state_machine_best_practices/#naming-conventions","title":"Naming Conventions","text":"<ol> <li>States: Use descriptive nouns that clearly indicate the state (e.g., <code>OrderPending</code>, <code>PaymentProcessing</code>)</li> <li>Commands: Suffix with <code>CMD</code> for clarity (e.g., <code>CreateOrderCMD</code>, <code>CancelOrderCMD</code>)</li> <li>Packages: Keep state machines in dedicated packages named after the domain (e.g., <code>order</code>, <code>payment</code>)</li> </ol>"},{"location":"examples/state_machine_best_practices/#state-design","title":"State Design","text":"<ol> <li>Keep States Focused: Each state should represent one clear condition</li> <li>Immutable Data: States should contain immutable data; create new states instead of modifying</li> <li>Minimal State Data: Only store data that's essential for the state's identity</li> <li>Use Zero Values: Design states so Go's zero values are meaningful defaults</li> </ol>"},{"location":"examples/state_machine_best_practices/#command-validation","title":"Command Validation","text":"<p>Centralizing validation in the Transition function provides significant benefits:</p> <ol> <li>Single source of truth: All business rules and validation logic live in one place</li> <li>Atomic validation: Commands are validated together with state checks, preventing invalid transitions</li> <li>Testability: Easy to test all validation rules through the state machine tests</li> <li>Maintainability: When rules change, you only update one location</li> </ol>"},{"location":"examples/state_machine_best_practices/#basic-validation","title":"Basic Validation","text":"example/state/machine.go<pre><code>        func(x *CreateOrderCMD) (State, error) {\n            // 1. Structural validation as simple checks and explicit error type\n            if x.OrderID == \"\" {\n                return nil, ErrOrderIDRequired\n            }\n\n            switch state.(type) {\n            case nil:\n                o := Order{\n                    ID:        x.OrderID,\n                    OrderAttr: x.Attr,\n                }\n                return &amp;OrderPending{\n                    Order: o,\n                }, nil\n            }\n\n            return nil, ErrOrderAlreadyExist\n        },\n</code></pre>"},{"location":"examples/state_machine_best_practices/#advanced-validation-with-go-validate","title":"Advanced Validation with go-validate","text":"<p>For complex validation requirements demonstrate</p> <ul> <li>Structural validation is declarative (struct tags)</li> <li>Business rules are explicit and testable</li> <li>External validations are isolated in dependencies</li> <li>State validations ensure valid transitions</li> <li>All validation happens before any state change:</li> </ul> example/state/machine.go<pre><code>        func(x *MarkOrderCompleteCMD) (State, error) {\n            //  1. Structural validation of commands (you could use go-validate library):\n            //\n            //     if err := di.Validator().Struct(x); err != nil {\n            //        return nil, fmt.Errorf(\"validation failed: %w. %s\", err, ErrValidationFailed)\n            //     }\n            //\n            //    or do it manually like in this example:\n            if x.OrderID == \"\" {\n                return nil, ErrOrderIDRequired\n            }\n            if x.WorkerID == \"\" {\n                return nil, ErrWorkerIDRequired\n            }\n\n            // 2. Ensure valid transitions\n            s, ok := state.(*OrderProcessing)\n            if !ok {\n                return nil, ErrCannotCompleteNonProcessingOrder\n            }\n\n            // 3. Business rule validation:\n            //    Worker cannot approve it's own order\n            if s.Order.WorkerID == x.WorkerID {\n                return nil, ErrWorkerSelfApprove\n            }\n\n            // 4. External validation or mutations:\n            if s.Order.StockRemovedAt == nil {\n                // We need to remove stock first\n                // We can retry this operation (assuming warehouse is idempotent, see TryRecoverErrorCMD)\n                // OrderID could be used to deduplicate operation\n                // it's not required in this example\n                err := di.WarehouseRemoveStock(ctx, s.Order.OrderAttr.Quantity)\n                if err != nil {\n                    return &amp;OrderError{\n                        ProblemCode:    ProblemWarehouseAPIUnreachable,\n                        ProblemCommand: x,\n                        ProblemState:   s,\n                    }, nil\n                }\n\n                s.Order.StockRemovedAt = di.TimeNow()\n            }\n\n            if s.Order.PaymentChargedAt == nil {\n                // We need to charge payment first\n                // We can retry this operation (assuming payment gateway is idempotent, see TryRecoverErrorCMD))\n                // OrderID could be used to deduplicate operation\n                // it's not required in this example\n                err := di.PaymentCharge(ctx, s.Order.OrderAttr.Price)\n                if err != nil {\n                    return &amp;OrderError{\n                        ProblemCode:    ProblemPaymentAPIUnreachable,\n                        ProblemCommand: x,\n                        ProblemState:   s,\n                    }, nil\n                }\n\n                s.Order.PaymentChargedAt = di.TimeNow()\n            }\n\n            s.Order.DeliveredAt = di.TimeNow()\n\n            return &amp;OrderCompleted{\n                Order: s.Order,\n            }, nil\n        },\n</code></pre> <p>This approach scales well because of the separation of state from IO and business logic.</p>"},{"location":"examples/state_machine_best_practices/#dependency-management","title":"Dependency Management","text":"<ol> <li>Define Clear Interfaces: Dependencies should be interfaces, not concrete types</li> <li>Keep Dependencies Minimal: Only inject what's absolutely necessary</li> <li>Generate Mocks with moq: Use <code>//go:generate moq</code> to automatically generate mocks</li> </ol> example/state/machine.go<pre><code>//go:generate moq -with-resets -stub -out machine_mock.go . Dependency\ntype Dependency interface {\n    TimeNow() *time.Time\n    WarehouseRemoveStock(ctx context.Context, quantity Quantity) error\n    PaymentCharge(ctx context.Context, price Price) error\n}\n</code></pre> <p>Running <code>mkunion watch -g ./...</code> creates <code>machine_mock.go</code> with a <code>DependencyMock</code> type. This mock can then be used in tests:</p> example/state/machine_test.go<pre><code>func TestSuite(t *testing.T) {\n    now := time.Now()\n    var di Dependency = &amp;DependencyMock{\n        TimeNowFunc: func() *time.Time {\n            return &amp;now\n        },\n    }\n\n// ... and some time later in assertion functions\n                                ForkCase(t, \"successfully recover\", func(t *testing.T, c *machine.Case[Dependency, Command, State]) {\n                                    c.\n                                        GivenCommand(&amp;TryRecoverErrorCMD{OrderID: \"123\"}).\n                                        BeforeCommand(func(t testing.TB, di Dependency) {\n                                            di.(*DependencyMock).ResetCalls()\n                                        }).\n                                        AfterCommand(func(t testing.TB, di Dependency) {\n                                            dep := di.(*DependencyMock)\n                                            if assert.Len(t, dep.WarehouseRemoveStockCalls(), 1) {\n                                                assert.Equal(t, order.Quantity, dep.WarehouseRemoveStockCalls()[0].Quantity)\n                                            }\n                                            if assert.Len(t, dep.PaymentChargeCalls(), 1) {\n                                                assert.Equal(t, order.Price, dep.PaymentChargeCalls()[0].Price)\n                                            }\n                                        }).\n                                        ThenState(t, &amp;OrderCompleted{\n                                            Order: Order{\n                                                ID:               \"123\",\n                                                OrderAttr:        order,\n                                                WorkerID:         \"worker-1\",\n                                                DeliveredAt:      &amp;now,\n                                                StockRemovedAt:   &amp;now,\n                                                PaymentChargedAt: &amp;now,\n                                            },\n                                        })\n                                })\n</code></pre> <p>Benefits of generating mocks:</p> <ul> <li>Reduces boilerplate: No need to manually write mock implementations</li> <li>Type safety: Generated mocks always match the interface</li> <li>Easy maintenance: Mocks automatically update when interface changes</li> <li>Better test readability: Focus on behavior, not mock implementation</li> </ul>"},{"location":"examples/state_machine_best_practices/#testing-philosophy","title":"Testing Philosophy","text":"<p>When testing state machines, mkunion's test suite enforces an important principle: states can only be created through command sequences. This design philosophy ensures:</p> <ol> <li>Reachability Verification: Every state used in tests is provably reachable through valid command sequences</li> <li>Self-Documentation: Tests document exactly how to reach each state, serving as executable documentation</li> <li>Invariant Preservation: Prevents testing impossible states that violate business rules</li> <li>Realistic Testing: Tests mirror real-world usage patterns</li> </ol>"},{"location":"examples/state_machine_best_practices/#command-only-state-creation","title":"Command-Only State Creation","text":"<p>Instead of allowing direct state instantiation in tests: <pre><code>// \u274c Not supported - direct state creation\nc.InitState = &amp;OrderProcessing{ID: \"123\", Items: []Item{...}}\n</code></pre></p> <p>Tests must build states through command sequences: <pre><code>// \u2705 Correct - states created through commands\nsuite.Case(t, \"order lifecycle\", func(t *testing.T, c *Case[...]) {\n    c.GivenCommand(&amp;CreateOrderCMD{...}).\n      ThenState(t, &amp;OrderPending{...}).\n      ForkCase(t, \"process order\", func(t *testing.T, c *Case[...]) {\n          c.GivenCommand(&amp;ProcessOrderCMD{...}).\n            ThenState(t, &amp;OrderProcessing{...})\n          // Now we have OrderProcessing state created through valid commands\n      })\n})\n</code></pre></p> <p>This constraint is intentional and powerful - if you cannot reach a state through commands, it likely shouldn't exist or indicates a missing command in your domain model.</p>"},{"location":"examples/state_machine_best_practices/#testing-error-states","title":"Testing Error States","text":"<p>Error states require special consideration. If an error state seems unreachable through normal commands, consider: - Is this error state actually possible in production? - Should this be modeled as an explicit error state rather than just an error return?</p>"},{"location":"examples/state_machine_best_practices/#benefits-of-this-approach","title":"Benefits of This Approach","text":"<ol> <li>Prevents Invalid Test Scenarios: You can't accidentally test states that are impossible to reach in production</li> <li>Forces Complete Command Design: If you need to test a state, you must provide a way to reach it</li> <li>Living Documentation: Test cases become a guide for how to use the state machine</li> <li>Catches Design Issues Early: Unreachable states are identified during test writing</li> </ol>"},{"location":"examples/state_machine_best_practices/#state-machine-composition","title":"State Machine Composition","text":"<p>For complex systems, compose multiple state machines as a service layer:</p> <pre><code>type OrderService struct {\n    repo schemaless.Repository[State]\n    deps Dependency\n}\n</code></pre> <pre><code>type ECommerceService struct {\n    orderService   *OrderService\n    paymentService *PaymentService\n}\n\nfunc NewECommerceService(orderSvc *OrderService, paymentSvc *PaymentService) *ECommerceService {\n    return &amp;ECommerceService{\n        orderService:   orderSvc,\n        paymentService: paymentSvc,\n    }\n}\n\nfunc (s *ECommerceService) ProcessOrder(ctx context.Context, orderCmd Command) error {\n    // 1. Handle order command through order service\n    newOrderState, err := s.orderService.HandleCommand(ctx, orderCmd)\n    if err != nil {\n        return fmt.Errorf(\"order processing failed: %w\", err)\n    }\n\n    // 2. If order is confirmed, trigger payment through payment service\n    if processing, ok := newOrderState.(*OrderProcessing); ok {\n        paymentCmd := &amp;InitiatePaymentCMD{\n            OrderID: processing.Order.ID,\n            Amount:  processing.Order.OrderAttr.Price,\n        }\n        _, err := s.paymentService.HandleCommand(ctx, paymentCmd)\n        if err != nil {\n            return fmt.Errorf(\"payment initiation failed: %w\", err)\n        }\n    }\n\n    return nil\n}\n</code></pre> <p>Key principles:</p> <ul> <li>Domain services: Each domain encapsulates its repository, dependencies, and machine logic</li> <li>Schemaless repositories: Use <code>schemaless.Repository[StateType]</code> for type-safe state storage</li> <li>Service composition: Compose domain services, avoiding direct repository/machine access</li> <li>Single responsibility: Each service handles one domain's state machine lifecycle</li> <li>Optimistic concurrency: Built-in through <code>schemaless.Repository</code> version handling</li> <li>No duplication: State loading, machine creation, and saving logic exists once per domain</li> </ul>"},{"location":"examples/state_machine_best_practices/#common-pitfalls","title":"Common Pitfalls","text":"<p>Avoid these common mistakes when implementing state machines:</p>"},{"location":"examples/state_machine_best_practices/#1-state-explosion","title":"1. State Explosion","text":"<p>Problem: Creating too many states for every minor variation <pre><code>// Bad: Too granular\ntype (\n    OrderPendingWithOneItem struct{}\n    OrderPendingWithTwoItems struct{}\n    OrderPendingWithThreeItems struct{}\n    // ... and so on\n)\n</code></pre></p> <p>Solution: Use state data instead <pre><code>// Good: Single state with data\ntype OrderPending struct {\n    Items []OrderItem\n}\n</code></pre></p>"},{"location":"examples/state_machine_best_practices/#2-circular-dependencies","title":"2. Circular Dependencies","text":"<p>Problem: States that can transition in circles without progress <pre><code>// Problematic: A -&gt; B -&gt; C -&gt; A without any business value\n</code></pre></p> <p>Solution: Ensure each transition represents meaningful progress or explicitly document allowed cycles</p>"},{"location":"examples/state_machine_best_practices/#3-missing-error-states","title":"3. Missing Error States","text":"<p>Problem: Not modeling error conditions as explicit states <pre><code>// Bad: Errors only in transition function\nreturn nil, fmt.Errorf(\"payment failed\")\n</code></pre></p> <p>Solution: Model error conditions as states when they need handling. Crucially, store both the command that failed and the previous valid state to enable recovery or debugging:</p> example/state/model.go<pre><code>//\n//go:tag mkunion:\"State\"\ntype (\n    OrderPending struct {\n        Order Order\n    }\n    OrderProcessing struct {\n        Order Order\n    }\n    OrderCompleted struct {\n        Order Order\n    }\n    OrderCancelled struct {\n        Order Order\n    }\n    // OrderError is a special state that represent an error\n    // during order processing, you can have different \"self-healing jobs\" based on the error code\n    // like retrying the order, cancel the order, etc.\n    //\n    // This pattern enables:\n    // 1. Perfect reproduction of the failure\n    // 2. Automatic retry with the same command\n    // 3. Debugging with full context\n    // 4. Recovery to previous valid state\n    OrderError struct {\n        // error information\n        Retried   int\n        RetriedAt *time.Time\n\n        ProblemCode ProblemCode\n\n        ProblemCommand Command\n        ProblemState   State\n    }\n)\n</code></pre> <p>The error state pattern enables recovery:</p> example/state/machine.go<pre><code>        func(x *TryRecoverErrorCMD) (State, error) {\n            if x.OrderID == \"\" {\n                return nil, ErrOrderIDRequired\n            }\n\n            switch s := state.(type) {\n            case *OrderError:\n                s.Retried += 1\n                s.RetriedAt = di.TimeNow()\n\n                switch s.ProblemCode {\n                case ProblemWarehouseAPIUnreachable,\n                    ProblemPaymentAPIUnreachable:\n                    // we can retry this operation\n                    newState, err := Transition(ctx, di, s.ProblemCommand, s.ProblemState)\n                    if err != nil {\n                        return s, err\n                    }\n\n                    // make sure that error retries are preserved\n                    if es, ok := newState.(*OrderError); ok {\n                        es.Retried = s.Retried\n                        es.RetriedAt = s.RetriedAt\n                        return es, nil\n                    }\n\n                    return newState, nil\n\n                default:\n                    // we don't know what to do, return to previous state\n                    return s, nil\n                }\n            }\n\n            return nil, ErrCannotRecoverNonErrorState\n        },\n</code></pre> <p>This approach preserves critical information needed for recovery  without losing the context of what failed (look at <code>Transition(ctx, di, s.ProblemCommand, s.ProblemState)</code>)</p>"},{"location":"examples/state_machine_best_practices/#4-ignoring-concurrency","title":"4. Ignoring Concurrency","text":"<p>Problem: Misunderstanding the state machine concurrency model <pre><code>// Wrong: Sharing a machine instance across goroutines\nsharedMachine := NewMachine(deps, currentState)\ngo sharedMachine.Handle(ctx, cmd1) // Goroutine 1\ngo sharedMachine.Handle(ctx, cmd2) // Goroutine 2 - DON'T DO THIS!\n</code></pre></p> <p>Solution: For handling concurrent updates to the same entity, see the Optimistic Concurrency Control section below.</p>"},{"location":"examples/state_machine_best_practices/#5-overloading-transitions","title":"5. Overloading Transitions","text":"<p>Problem: Putting too much business logic in transition functions <pre><code>// Bad: Transition function doing too much\nfunc Transition(...) (State, error) {\n    // Send emails\n    // Update inventory\n    // Calculate prices\n    // Log to external systems\n    // ... 200 lines later\n}\n</code></pre></p> <p>Solution: Keep transitions focused on state changes; delegate side effects to dependencies</p>"},{"location":"examples/state_machine_best_practices/#debugging-and-observability","title":"Debugging and Observability","text":""},{"location":"examples/state_machine_best_practices/#state-history-tracking","title":"State History Tracking","text":"<p>The mkunion state machine pattern leverages Change Data Capture (CDC) for automatic state history tracking. Since every state transition is persisted with versioning through optimistic concurrency control, you get a complete audit trail without modifying your state machine logic.</p> <p>The <code>schemaless.Repository</code> creates an append log of all state changes with version numbers, providing ordering guarantees and enabling powerful history tracking capabilities. CDC processors consume this stream asynchronously to build history aggregates, analytics, and debugging tools - all without impacting state machine performance. The system automatically handles failures through persistent, replayable streams that survive crashes and allow processors to resume from their last position.</p> <p>This approach integrates seamlessly with other mkunion patterns like retry processors and timeout handlers, creating a unified system where every state change is tracked, queryable, and analyzable.</p> <p>Real Implementation</p> <p>The example app demonstrates CDC integration with <code>taskRetry.RunCDC(ctx)</code> and <code>store.AppendLog()</code>. Detailed examples of building history processors, analytics pipelines, and debugging tools will be added in future updates.</p>"},{"location":"examples/state_machine_best_practices/#metrics-and-monitoring","title":"Metrics and Monitoring","text":"<p>Currently, metrics collection is the responsibility of the user. If you need Prometheus metrics or other monitoring, include them in your dependency interface and use them within your <code>Transition</code> function:</p> <pre><code>type Dependencies interface {\n    // Your business dependencies\n    StockService() StockService\n\n    // Metrics dependencies - user's responsibility to provide\n    Metrics() *prometheus.Registry\n    TransitionCounter() prometheus.Counter\n}\n\nfunc Transition(ctx context.Context, deps Dependencies, cmd Command, state State) (State, error) {\n    // Manual metrics collection\n    startTime := time.Now()\n    defer func() {\n        deps.TransitionCounter().Inc()\n        // Record duration, state types, etc.\n    }()\n\n    // Your transition logic here\n}\n</code></pre> <p>There's no automatic metrics injection - you must explicitly add metrics to your dependencies and instrument your transitions manually.</p> <p>Future Enhancement</p> <p>Automatic metrics collection would be a valuable addition to <code>machine.Machine</code>. This could include built-in counters for transitions, error rates, and timing histograms without requiring manual instrumentation.</p>"},{"location":"examples/state_machine_best_practices/#evolution-and-versioning","title":"Evolution and Versioning","text":""},{"location":"examples/state_machine_best_practices/#backward-compatible-changes","title":"Backward Compatible Changes","text":"<p>When evolving state machines, maintain compatibility:</p> <pre><code>// Version 1\n//go:tag mkunion:\"OrderState\"\ntype (\n    OrderCreated struct {\n        ID    string\n        Items []Item\n    }\n)\n\n// Version 2 - Added field with default\n//go:tag mkunion:\"OrderState\"\ntype (\n    OrderCreated struct {\n        ID       string\n        Items    []Item\n        Discount float64 `json:\"discount,omitempty\"` // New field\n    }\n)\n</code></pre>"},{"location":"examples/state_machine_best_practices/#state-migration-strategies","title":"State Migration Strategies","text":"<p>Handle state structure changes:</p> <pre><code>// Migration function\nfunc MigrateOrderState(old []byte) (State, error) {\n    // Try to unmarshal as current version\n    current, err := shared.JSONUnmarshal[OrderState](old)\n    if err == nil {\n        return current, nil\n    }\n\n    // Try older version\n    v1, err := shared.JSONUnmarshal[OrderStateV1](old)\n    if err == nil {\n        // Convert v1 to current\n        return convertV1ToCurrent(v1), nil\n    }\n\n    return nil, fmt.Errorf(\"unknown state version\")\n}\n</code></pre>"},{"location":"examples/state_machine_best_practices/#deprecating-states-and-commands","title":"Deprecating States and Commands","text":"<p>Gracefully phase out old states:</p> <pre><code>//go:tag mkunion:\"OrderState\"\ntype (\n    // Deprecated: Use OrderPending instead\n    OrderCreated struct {\n        // ... fields\n    }\n\n    OrderPending struct {\n        // New state structure\n    }\n)\n\nfunc Transition(ctx context.Context, deps Dependencies, cmd Command, state State) (State, error) {\n    // Handle deprecated state\n    if old, ok := state.(*OrderCreated); ok {\n        // Automatically migrate to new state\n        state = &amp;OrderPending{\n            // Map old fields to new\n        }\n    }\n\n    // Continue with normal processing\n    // ...\n}\n</code></pre>"},{"location":"examples/state_machine_best_practices/#performance-considerations","title":"Performance Considerations","text":""},{"location":"examples/state_machine_best_practices/#memory-optimization","title":"Memory Optimization","text":"<ol> <li> <p>Reuse State Instances: For states without data, use singletons <pre><code>var (\n    pendingState = &amp;Pending{}\n    activeState  = &amp;Active{}\n)\n</code></pre></p> </li> <li> <p>Lazy Loading: Don't load unnecessary data in states <pre><code>type OrderDetails struct {\n    ID       string\n    // Don't embed full customer, just reference\n    CustomerID string `json:\"customer_id\"`\n}\n</code></pre></p> </li> </ol>"},{"location":"examples/state_machine_best_practices/#optimistic-concurrency-control","title":"Optimistic Concurrency Control","text":"<p>The <code>x/storage/schemaless</code> package provides built-in optimistic concurrency control using version fields. This ensures data consistency when multiple processes work with the same state.</p> example/state/machine_test.go<pre><code>    storage := schemaless.NewInMemoryRepository[State]()\n\n    // 1. Load current state from storage\n    records, err := storage.FindingRecords(schemaless.FindingRecords[schemaless.Record[State]]{\n        RecordType: recordType,\n        Where: predicate.MustWhere(\"ID = :id\", predicate.ParamBinds{\n            \":id\": schema.MkString(orderId),\n        }, nil),\n        Limit: 1,\n    })\n    assert.NoError(t, err)\n    assert.Len(t, records.Items, 0)\n\n    // 2. Create a fresh machine instance with the current state\n    var state State\n    m := NewMachine(dep, state)\n\n    // 3. Handle the command\n    cmd := &amp;CreateOrderCMD{OrderID: \"123\", Attr: OrderAttr{Price: 100, Quantity: 3}}\n    err = m.Handle(ctx, cmd)\n    assert.NoError(t, err)\n\n    // 4. Save the new state (with optimistic concurrency control)\n    result, err := storage.UpdateRecords(schemaless.Save(schemaless.Record[State]{\n        ID:   orderId,\n        Type: recordType,\n        Data: m.State(),\n    }))\n    assert.NoError(t, err)\n    assert.Len(t, result.Saved, 1)\n\n    if errors.Is(err, schemaless.ErrVersionConflict) {\n        // handle error conflicts, usually retry from step 1.\n    }\n\n    assert.Equal(t,\n        &amp;OrderPending{\n            Order: Order{\n                ID:        \"123\",\n                OrderAttr: OrderAttr{Price: 100, Quantity: 3},\n            },\n        }, m.State(),\n    )\n</code></pre> <p>How It Works:</p> <ol> <li>Each record has a <code>Version</code> field that increments on updates</li> <li>Updates specify the expected version in the record</li> <li>If versions don't match, <code>ErrVersionConflict</code> is returned</li> <li>Applications retry with the latest version</li> </ol>"},{"location":"examples/state_storage/","title":"Persisting union in database","text":""},{"location":"examples/state_storage/#persisting-state-in-database","title":"Persisting state in database","text":"<p>At this point, we have implemented and tested the Order Service state machine.</p> <p>The next thing that we need to address on our road to production is to persist state in a database.</p> <p>MkUnion aims to support you in this task by providing you with the <code>x/storage/schemaless</code> package that will take care of:</p> <ul> <li>mapping Go structs to database representation and back from the database to a struct.</li> <li>leveraging optimistic concurrency control to resolve conflicts</li> <li>providing you with a simple API to work with the database</li> <li>and more</li> </ul> <p>Below is a test case that demonstrates a complete example of initializing a database, building a state using <code>NewMachine</code>, and saving and loading state from the database.</p> example/state/machine_database_test.go<pre><code>\n</code></pre> <pre><code>sequenceDiagram\n    participant R as Request\n    participant Store as Store\n\n    activate R\n    R-&gt;&gt;R: Validate(request) -&gt; error\n\n    R-&gt;&gt;Store: Load state from database by request.ObjectId\n    activate Store\n    Store-&gt;&gt;R: Ok(State)\n    deactivate Store\n\n    R-&gt;&gt;R: Create machine with state\n    R-&gt;&gt;R: Apply command to state\n\n    R-&gt;&gt;Store: Save state in database under request.ObjectId\n    activate Store\n    Store-&gt;&gt;R: Ok()\n    deactivate Store\n\n    deactivate R</code></pre> <p>Example implementation of such a sequence diagram:</p> <pre><code>func Handle(rq Request, response Response) { // Assuming Resopnse was a typo for Response\n    ctx := rq.Context()\n\n    // extract `objectId` and `command` from the request and perform some validation\n    id := rq.ObjectId\n    command := rq.Command\n\n    // Load the state from the store\n    state, err := store.Find(ctx, id)\n    if err != nil { /*handle error*/ }\n\n    machine := NewSimpleMachineWithState(Transition, state)\n    newState, err := machine.Apply(command, state) // cmd was used before, assuming command\n    if err != nil { /*handle error*/ }\n\n    err = store.Save(ctx, newState) // Assuming missing =\n    if err != nil { /*handle error*/ }\n\n    // serialize the response\n    response.Write(newState)\n}\n</code></pre>"},{"location":"examples/state_storage/#error-as-state-self-healing-systems","title":"Error as state. Self-healing systems.","text":"<p>In a request-response situation, handling errors is easy, but what if something goes wrong in some long-lived process? How should errors be handled in such a situation? Without making what we've learned about state machines useless or hard to use?</p> <p>One solution is to treat errors as state. In such a case, our state machines will never return an error, but instead will return a new state that will represent an error.</p> <p>When we introduce an explicit command responsible for correcting <code>RecoverableError</code>, we can create self-healing systems. Thanks to that, even in situations where errors are unknown, we can retroactively introduce self-healing logic that corrects states.</p> <p>Since there is always only one error state, it makes such state machines easy to reason about.</p> <pre><code>//go:generate mkunion -name State\ntype (\n    // ...\n    RecoverableError struct {\n        ErrCode int\n        PrevState State\n        RetryCount int\n    }\n)\n\n//go:generate mkunion -name Command\ntype (\n    // ...\n    CorrectStateCMD struct {}\n)\n</code></pre> <p>Now, we have to implement the recoverable logic in our state machine. The example above shows how to do it in the <code>Transition</code> function.</p> <p>Here is an example implementation of such a transition function:</p> <pre><code>func Transition(cmd Command, state State) (State, error) {\nreturn MustMatchCommandR2(\n    cmd,\n    /* ... */\n    func(cmd *CorrectStateCMD) (State, error) {\n        switch state := state.(type) {\n        case *RecoverableError:\n            state.RetryCount = state.RetryCount + 1\n\n            // here we can do some self-healing logic\n            if state.ErrCode == DuplicateServiceUnavailable { // Assuming DuplicateServiceUnavailable is a defined error code\n                newState, err := Transition(&amp;MarkAsDuplicateCMD{}, state.PrevState) // Assuming MarkAsDuplicateCMD is a defined command\n                 if err != nil {\n                    // we failed to correct the error, so we return an error state \n                     return &amp;RecoverableError{\n                        ErrCode:    0, // Consider setting a more specific error code from 'err'\n                        PrevState:  state.PrevState,\n                        RetryCount: state.RetryCount,\n                    }, nil\n                }\n\n                 // we managed to fix the state, so we return new state\n                 return newState, nil\n             } else {\n                 // log information that we have a new error code that we don't know how to handle\n             }\n\n            // try to correct the error in the next iteration\n            return state, nil\n        }\n        return state, nil // Added default return for the switch\n    },\n) // Assuming MustMatchCommandR2 is a function that requires this closing parenthesis\n}\n</code></pre> <p>Now, to correct states, we have to select all states that are in an error state from the database. It can be used in many ways; the example below uses an abstraction called <code>TaskQueue</code> that is responsible for running tasks in the background.</p> <p>This abstraction guarantees that all records (historical and new ones) will be processed. You can think of it as a queue that is populated by records from the database that meet SQL query criteria.</p> <p>You can use a CRON job and poll the database.</p> <pre><code>//go:generate mms deployyml -type=TaskQueue -name=CorrectMSPErrors -autoscale=1,10 -memory=128Mi -cpu=100m -timeout=10s -schedule=\"0 0 * * *\"\nfunc main()\n    sql := \"SELECT * FROM ObjectState WHERE RecoverableError.RetryCount &lt; 3\" // Assuming ObjectState is the table\n    store := datalayer.DefaultStore() // Assuming datalayer.DefaultStore() is available\n    queue := TaskQueueFrom(\"correct-msp-errors\", sql, store) // Assuming TaskQueueFrom is available\n    queue.OnTask(func (ctx context.Context, task Task) error { // Assuming Task type is defined\n        state := task.State()\n        cmd := &amp;CorrectStateCMD{}\n        machine := NewSimpleMachineWithState(Transition, state)\n        newState, err := machine.Apply(cmd, state) // machine.Apply might need context\n        if err != nil {\n            return err\n        }\n        return task.Save(ctx, newState) // Assuming task.Save is available\n    })\n    err := queue.Run(ctx) // Assuming ctx is defined\n    if err != nil {\n        log.Panic(err)\n    }\n}\n</code></pre>"},{"location":"examples/state_storage/#state-machines-and-command-queues-and-workflows","title":"State machines and command queues and workflows","text":"<p>What if a command would initiate a state \"to process\" and save it in the database? What if a task queue would take such a state and process it? Wouldn't this be something like a command queue?</p> <p>Under what conditions should background processes be used to transition these states?</p>"},{"location":"examples/state_storage/#processors-per-state","title":"Processors per state","text":"<p>It's like micromanaging the TaskQueue, where each state has its own logic and knows what command to apply to a given state. This could be a good starting point when there isn't a lot of good tooling.</p>"},{"location":"examples/state_storage/#processor-for-state-machine","title":"Processor for state machine","text":"<p>With good tooling, the transition of states can be declared in one place, and deployment to the task queue could be done automatically.</p> <p>Note that only some of the transitions need to happen in the background; others can be done in a request-response manner.</p>"},{"location":"examples/state_storage/#processor-for-state-machine-with-workflow","title":"Processor for state machine with workflow","text":"<p>A state machine could be generalized to a workflow. We can think about it as a set of generic Commands and States (like a Turing machine).</p> <p>States like <code>Pending</code>, <code>Completed</code>, <code>Failed</code>. Commands like <code>Process</code>, <code>Retry</code>, <code>Cancel</code>.</p> <p>And a workflow DSL with commands like: <code>Invoke</code>, <code>Choose</code>, <code>Assign</code>. Where a function is some ID string, and functions need to be either pulled from a registry or called remotely (<code>InvokeRemote</code>). Some operations would require a callback (<code>InvokeAndAwait</code>).</p> <p>Then a background processor would be responsible for executing such a workflow (using a task queue). The program would be responsible for defining the workflow and registering functions.</p> <p>Such programs could also be optimized for deployment, if some function would be better to run on the same machine that makes an RPC call, like a function making an RPC call to a database and caching the result in memory or in a cache cluster dedicated to a specific BFF.</p>"},{"location":"examples/type_script/","title":"End-to-End types between Go and TypeScript","text":"<p>MkUnion enables the generation of TypeScript definitions directly from your Go union types. This facilitates end-to-end type safety when building applications with a Go backend and a TypeScript frontend.</p> <p>By using the <code>mkunion</code> tool, you can ensure that the data structures exchanged between your Go server and TypeScript client are consistent, reducing the likelihood of integration errors and improving developer experience.</p> <p>The following snippet shows an example of Go code from which TypeScript definitions can be generated:</p> example/my-app/server.go<pre><code>// this command make sure that all types that are imported will have generated typescript mapping\n//go:generate ../../cmd/mkunion/mkunion shape-export --language=typescript -o ./src/workflow\n\n// this lines defines all types that should have typescript mapping generated by above command\ntype (\n    Workflow       = workflow.Workflow\n    State          = workflow.State\n    Command        = workflow.Command\n    Expr           = workflow.Expr\n    Predicate      = workflow.Predicate\n    Reshaper       = workflow.Reshaper\n    Schema         = schema.Schema\n    UpdateRecords  = schemaless.UpdateRecords[schemaless.Record[any]]\n    FindRecords    = schemaless.FindingRecords[schemaless.Record[any]]\n    PageResult     = schemaless.PageResult[schemaless.Record[any]]\n    FunctionOutput = workflow.FunctionOutput\n    FunctionInput  = workflow.FunctionInput\n)\n</code></pre> <p>This generated TypeScript code can then be imported into your frontend project, providing compile-time checks and autocompletion for your API responses and requests.</p>"},{"location":"examples/union_composability/","title":"Composability and Type Safety","text":"<p>Union types in mkunion are designed to be highly composable, allowing you to build sophisticated type-safe abstractions. </p> <p>This guide explores how to create and compose fundamental union types like <code>Option</code> and <code>Result</code>, demonstrating patterns that eliminate null pointer exceptions and provide exhaustive error handling.</p>"},{"location":"examples/union_composability/#core-union-types-option-and-result","title":"Core Union Types: Option and Result","text":"<p>Let's start by implementing two of the most popular union types from functional programming:</p> <ul> <li>Option[T]: Represents a value that may or may not be present, eliminating null references</li> <li>Result[T, E]: Represents either a success value (Ok) or an error value (Err), providing type-safe error handling</li> </ul>"},{"location":"examples/union_composability/#basic-implementation","title":"Basic Implementation","text":"f/datas.go<pre><code>// package \"github.com/widmogrod/mkunion/f\"\n\n\n// Result type - explicit error handling without exceptions\n//\n//go:tag mkunion:\"Result[A, E]\"\ntype (\n    Ok[A any, E any]  struct{ Value A }\n    Err[A any, E any] struct{ Error E }\n)\n\n\n// Option type - represent nullable values explicitly\n//\n//go:tag mkunion:\"Option[A]\"\ntype (\n    None[A any] struct{}\n    Some[A any] struct{ Value A }\n)\n</code></pre> example/datas.go<pre><code>import (\n    \"fmt\"\n    . \"github.com/widmogrod/mkunion/f\"\n)\n\ntype User struct{ Name string }\n\ntype APIError struct {\n    Code    int\n    Message string\n}\n\n\n// FetchResult combine unions for rich error handling\ntype FetchResult = Result[Option[User], APIError]\n\n\n// handleFetch uses nested pattern matching to handle result\nfunc handleFetch(result FetchResult) string {\n    return MatchResultR1(result,\n        func(ok *Ok[Option[User], APIError]) string {\n            return MatchOptionR1(ok.Value,\n                func(*None[User]) string { return \"User not found\" },\n                func(some *Some[User]) string {\n                    return fmt.Sprintf(\"Found user: %s\", some.Value.Name)\n                },\n            )\n        },\n        func(err *Err[Option[User], APIError]) string {\n            return fmt.Sprintf(\"API error: %v\", err.Error)\n        },\n    )\n}\n</code></pre> <p>The example shows a common pattern: an API fetch that might fail (Result) and might return no data (Option):</p> example/datas.go<pre><code>// FetchResult combine unions for rich error handling\ntype FetchResult = Result[Option[User], APIError]\n</code></pre> <p>This type precisely captures three states:</p> <ol> <li>Success with data: <code>Ok[Some[User]]</code></li> <li>Success with no data: <code>Ok[None[User]]</code></li> <li>API failure: <code>Err[APIError]</code></li> </ol>"},{"location":"examples/union_composability/#handling-nested-unions","title":"Handling Nested Unions","text":"example/datas.go<pre><code>// handleFetch uses nested pattern matching to handle result\nfunc handleFetch(result FetchResult) string {\n    return MatchResultR1(result,\n        func(ok *Ok[Option[User], APIError]) string {\n            return MatchOptionR1(ok.Value,\n                func(*None[User]) string { return \"User not found\" },\n                func(some *Some[User]) string {\n                    return fmt.Sprintf(\"Found user: %s\", some.Value.Name)\n                },\n            )\n        },\n        func(err *Err[Option[User], APIError]) string {\n            return fmt.Sprintf(\"API error: %v\", err.Error)\n        },\n    )\n}\n</code></pre>"},{"location":"examples/union_composability/#creating-composed-values","title":"Creating Composed Values","text":"example/datas_test.go<pre><code>func TestCreatingUnions(t *testing.T) {\n    // Success with user\n    fetchSuccess := MkOk[APIError](MkSome(User{Name: \"Alice\"}))\n\n    // Success but user not found\n    fetchNotFound := MkOk[APIError](MkNone[User]())\n\n    // API error\n    fetchError := MkErr[Option[User]](APIError{\n        Code:    500,\n        Message: \"Internal Server Error\",\n    })\n\n    assert.Equal(t, \"Found user: Alice\", handleFetch(fetchSuccess))\n    assert.Equal(t, \"User not found\", handleFetch(fetchNotFound))\n    assert.Equal(t, \"API error: {500 Internal Server Error}\", handleFetch(fetchError))\n}\n</code></pre>"},{"location":"examples/union_composability/#summary","title":"Summary","text":"<p>Union type composition in mkunion provides:</p> <ul> <li>Type Safety: Impossible states are unrepresentable</li> <li>Exhaustiveness: The compiler ensures all cases are handled</li> <li>Composability: Simple types combine into sophisticated abstractions</li> <li>Clarity: Error paths and edge cases are explicit in types</li> </ul> <p>By mastering Option and Result composition, you can build robust applications that handle errors gracefully and eliminate entire classes of runtime failures.  The key is to start simple, build a library of helper functions, and gradually compose more sophisticated types as your domain requires.</p>"},{"location":"examples/union_composability/#next-steps","title":"Next steps","text":"<ul> <li>Phantom Types - Learn benefits of phantom types</li> </ul>"},{"location":"examples/union_phanthom_types/","title":"Phantom Types","text":"<p>Leverage Go's type system for compile-time guarantees.</p>"},{"location":"examples/union_phanthom_types/#measurements-as-phantom-types","title":"Measurements as phantom types","text":"<p>Phantom types for units COULD help prevents catastrophic bugs like the Mars Climate Orbiter ($327M loss due to metric/imperial confusion). The type system won't let you mix incompatible units.</p> example/units.go<pre><code>// \n\n//go:tag mkunion:\"Measurement[Unit]\"\ntype (\n    Distance[Unit any] struct{ value float64 }\n    Speed[Unit any]    struct{ value float64 }\n)\n\n//go:tag mkunion:\"Time[Unit]\"\ntype (\n    AnyTime[Unit any]      struct{ value float64 }\n    PositiveTime[Unit any] struct{ value float64 }\n)\n\ntype Meters struct{}\ntype Feet struct{}\ntype Seconds struct{}\ntype Hours struct{}\ntype MetersPerSecond struct{}\ntype MilesPerHour struct{}\n\nfunc NewDistance(value float64) *Distance[Meters] {\n    return &amp;Distance[Meters]{value: value}\n}\n\n// ToFeet Type-safe unit conversions\nfunc (d *Distance[Meters]) ToFeet() *Distance[Feet] {\n    return &amp;Distance[Feet]{value: d.value * 3.28084}\n}\n\nfunc (t *PositiveTime[Seconds]) ToHours() *PositiveTime[Hours] {\n    return &amp;PositiveTime[Hours]{value: t.value / 3600}\n}\n\nfunc NewTime(value float64) Time[Seconds] {\n    if value &lt;= 0 {\n        return &amp;AnyTime[Seconds]{value: value}\n    }\n    return &amp;PositiveTime[Seconds]{value: value}\n}\n\n// CalculateSpeed only compatible units can be combined\nfunc CalculateSpeed(distance *Distance[Meters], time *PositiveTime[Seconds]) *Speed[MetersPerSecond] {\n    return &amp;Speed[MetersPerSecond]{value: distance.value / time.value}\n}\n</code></pre>"},{"location":"examples/union_phanthom_types/#state-tracking-and-phantom-types","title":"State tracking and phantom types","text":"example/connection.go<pre><code>//go:tag mkunion:\"Connection[State]\"\ntype (\n    Disconnected[State any] struct{}\n    Connecting[State any]   struct{ Addr string }\n    Connected[State any]    struct{ Conn net.Conn }\n)\n\n// Type-safe state machine with phantom types\ntype Unopened struct{}\ntype Open struct{}\ntype Closed struct{}\n\n// Only allow certain operations in specific states\nfunc (c *Connected[Open]) Send(data []byte) error {\n    // Can only send on open connections\n    _, err := c.Conn.Write(data)\n    return err\n}\n\nfunc (c *Connected[Open]) Close() Connection[Closed] {\n    c.Conn.Close()\n    return &amp;Disconnected[Closed]{}\n}\n\n// Compile error: cannot call Send on closed connection!\n// func (c *Connected[Closed]) Send(data []byte) error { ... }\n</code></pre>"}]}