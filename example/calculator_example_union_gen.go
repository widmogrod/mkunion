// Code generated by mkunion. DO NOT EDIT.
package example

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type CalcVisitor interface {
	VisitLit(v *Lit) any
	VisitSum(v *Sum) any
	VisitMul(v *Mul) any
}

type Calc interface {
	AcceptCalc(g CalcVisitor) any
}

var (
	_ Calc = (*Lit)(nil)
	_ Calc = (*Sum)(nil)
	_ Calc = (*Mul)(nil)
)

func (r *Lit) AcceptCalc(v CalcVisitor) any { return v.VisitLit(r) }
func (r *Sum) AcceptCalc(v CalcVisitor) any { return v.VisitSum(r) }
func (r *Mul) AcceptCalc(v CalcVisitor) any { return v.VisitMul(r) }

func MatchCalcR3[T0, T1, T2 any](
	x Calc,
	f1 func(x *Lit) (T0, T1, T2),
	f2 func(x *Sum) (T0, T1, T2),
	f3 func(x *Mul) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Lit:
		return f1(v)
	case *Sum:
		return f2(v)
	case *Mul:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchCalcR2[T0, T1 any](
	x Calc,
	f1 func(x *Lit) (T0, T1),
	f2 func(x *Sum) (T0, T1),
	f3 func(x *Mul) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Lit:
		return f1(v)
	case *Sum:
		return f2(v)
	case *Mul:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchCalcR1[T0 any](
	x Calc,
	f1 func(x *Lit) T0,
	f2 func(x *Sum) T0,
	f3 func(x *Mul) T0,
) T0 {
	switch v := x.(type) {
	case *Lit:
		return f1(v)
	case *Sum:
		return f2(v)
	case *Mul:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchCalcR0(
	x Calc,
	f1 func(x *Lit),
	f2 func(x *Sum),
	f3 func(x *Mul),
) {
	switch v := x.(type) {
	case *Lit:
		f1(v)
	case *Sum:
		f2(v)
	case *Mul:
		f3(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Calc", CalcFromJSON, CalcToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Lit", LitFromJSON, LitToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Mul", MulFromJSON, MulToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Sum", SumFromJSON, SumToJSON)
}

type CalcUnionJSON struct {
	Type string          `json:"$type,omitempty"`
	Lit  json.RawMessage `json:"example.Lit,omitempty"`
	Sum  json.RawMessage `json:"example.Sum,omitempty"`
	Mul  json.RawMessage `json:"example.Mul,omitempty"`
}

func CalcFromJSON(x []byte) (Calc, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data CalcUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("example.CalcFromJSON: %w", err)
	}

	switch data.Type {
	case "example.Lit":
		return LitFromJSON(data.Lit)
	case "example.Sum":
		return SumFromJSON(data.Sum)
	case "example.Mul":
		return MulFromJSON(data.Mul)
	}

	if data.Lit != nil {
		return LitFromJSON(data.Lit)
	} else if data.Sum != nil {
		return SumFromJSON(data.Sum)
	} else if data.Mul != nil {
		return MulFromJSON(data.Mul)
	}
	return nil, fmt.Errorf("example.CalcFromJSON: unknown type: %s", data.Type)
}

func CalcToJSON(x Calc) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchCalcR2(
		x,
		func(y *Lit) ([]byte, error) {
			body, err := LitToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("example.CalcToJSON: %w", err)
			}
			return json.Marshal(CalcUnionJSON{
				Type: "example.Lit",
				Lit:  body,
			})
		},
		func(y *Sum) ([]byte, error) {
			body, err := SumToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("example.CalcToJSON: %w", err)
			}
			return json.Marshal(CalcUnionJSON{
				Type: "example.Sum",
				Sum:  body,
			})
		},
		func(y *Mul) ([]byte, error) {
			body, err := MulToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("example.CalcToJSON: %w", err)
			}
			return json.Marshal(CalcUnionJSON{
				Type: "example.Mul",
				Mul:  body,
			})
		},
	)
}

func LitFromJSON(x []byte) (*Lit, error) {
	result := new(Lit)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("example.LitFromJSON: %w", err)
	}
	return result, nil
}

func LitToJSON(x *Lit) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Lit)(nil)
	_ json.Marshaler   = (*Lit)(nil)
)

func (r *Lit) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONLit(*r)
}
func (r *Lit) _marshalJSONLit(x Lit) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldV []byte
	fieldV, err = r._marshalJSONint(x.V)
	if err != nil {
		return nil, fmt.Errorf("example: Lit._marshalJSONLit: field name V; %w", err)
	}
	partial["V"] = fieldV
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("example: Lit._marshalJSONLit: struct; %w", err)
	}
	return result, nil
}
func (r *Lit) _marshalJSONint(x int) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("example: Lit._marshalJSONint:; %w", err)
	}
	return result, nil
}
func (r *Lit) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONLit(data)
	if err != nil {
		return fmt.Errorf("example: Lit.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Lit) _unmarshalJSONLit(data []byte) (Lit, error) {
	result := Lit{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("example: Lit._unmarshalJSONLit: native struct unwrap; %w", err)
	}
	if fieldV, ok := partial["V"]; ok {
		result.V, err = r._unmarshalJSONint(fieldV)
		if err != nil {
			return result, fmt.Errorf("example: Lit._unmarshalJSONLit: field V; %w", err)
		}
	}
	return result, nil
}
func (r *Lit) _unmarshalJSONint(data []byte) (int, error) {
	var result int
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("example: Lit._unmarshalJSONint: native primitive unwrap; %w", err)
	}
	return result, nil
}

func SumFromJSON(x []byte) (*Sum, error) {
	result := new(Sum)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("example.SumFromJSON: %w", err)
	}
	return result, nil
}

func SumToJSON(x *Sum) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Sum)(nil)
	_ json.Marshaler   = (*Sum)(nil)
)

func (r *Sum) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONSum(*r)
}
func (r *Sum) _marshalJSONSum(x Sum) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldLeft []byte
	fieldLeft, err = r._marshalJSONCalc(x.Left)
	if err != nil {
		return nil, fmt.Errorf("example: Sum._marshalJSONSum: field name Left; %w", err)
	}
	partial["Left"] = fieldLeft
	var fieldRight []byte
	fieldRight, err = r._marshalJSONCalc(x.Right)
	if err != nil {
		return nil, fmt.Errorf("example: Sum._marshalJSONSum: field name Right; %w", err)
	}
	partial["Right"] = fieldRight
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("example: Sum._marshalJSONSum: struct; %w", err)
	}
	return result, nil
}
func (r *Sum) _marshalJSONCalc(x Calc) ([]byte, error) {
	result, err := shared.JSONMarshal[Calc](x)
	if err != nil {
		return nil, fmt.Errorf("example: Sum._marshalJSONCalc:; %w", err)
	}
	return result, nil
}
func (r *Sum) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONSum(data)
	if err != nil {
		return fmt.Errorf("example: Sum.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Sum) _unmarshalJSONSum(data []byte) (Sum, error) {
	result := Sum{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("example: Sum._unmarshalJSONSum: native struct unwrap; %w", err)
	}
	if fieldLeft, ok := partial["Left"]; ok {
		result.Left, err = r._unmarshalJSONCalc(fieldLeft)
		if err != nil {
			return result, fmt.Errorf("example: Sum._unmarshalJSONSum: field Left; %w", err)
		}
	}
	if fieldRight, ok := partial["Right"]; ok {
		result.Right, err = r._unmarshalJSONCalc(fieldRight)
		if err != nil {
			return result, fmt.Errorf("example: Sum._unmarshalJSONSum: field Right; %w", err)
		}
	}
	return result, nil
}
func (r *Sum) _unmarshalJSONCalc(data []byte) (Calc, error) {
	result, err := shared.JSONUnmarshal[Calc](data)
	if err != nil {
		return result, fmt.Errorf("example: Sum._unmarshalJSONCalc: native ref unwrap; %w", err)
	}
	return result, nil
}

func MulFromJSON(x []byte) (*Mul, error) {
	result := new(Mul)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("example.MulFromJSON: %w", err)
	}
	return result, nil
}

func MulToJSON(x *Mul) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Mul)(nil)
	_ json.Marshaler   = (*Mul)(nil)
)

func (r *Mul) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONMul(*r)
}
func (r *Mul) _marshalJSONMul(x Mul) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldLeft []byte
	fieldLeft, err = r._marshalJSONCalc(x.Left)
	if err != nil {
		return nil, fmt.Errorf("example: Mul._marshalJSONMul: field name Left; %w", err)
	}
	partial["Left"] = fieldLeft
	var fieldRight []byte
	fieldRight, err = r._marshalJSONCalc(x.Right)
	if err != nil {
		return nil, fmt.Errorf("example: Mul._marshalJSONMul: field name Right; %w", err)
	}
	partial["Right"] = fieldRight
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("example: Mul._marshalJSONMul: struct; %w", err)
	}
	return result, nil
}
func (r *Mul) _marshalJSONCalc(x Calc) ([]byte, error) {
	result, err := shared.JSONMarshal[Calc](x)
	if err != nil {
		return nil, fmt.Errorf("example: Mul._marshalJSONCalc:; %w", err)
	}
	return result, nil
}
func (r *Mul) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONMul(data)
	if err != nil {
		return fmt.Errorf("example: Mul.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Mul) _unmarshalJSONMul(data []byte) (Mul, error) {
	result := Mul{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("example: Mul._unmarshalJSONMul: native struct unwrap; %w", err)
	}
	if fieldLeft, ok := partial["Left"]; ok {
		result.Left, err = r._unmarshalJSONCalc(fieldLeft)
		if err != nil {
			return result, fmt.Errorf("example: Mul._unmarshalJSONMul: field Left; %w", err)
		}
	}
	if fieldRight, ok := partial["Right"]; ok {
		result.Right, err = r._unmarshalJSONCalc(fieldRight)
		if err != nil {
			return result, fmt.Errorf("example: Mul._unmarshalJSONMul: field Right; %w", err)
		}
	}
	return result, nil
}
func (r *Mul) _unmarshalJSONCalc(data []byte) (Calc, error) {
	result, err := shared.JSONUnmarshal[Calc](data)
	if err != nil {
		return result, fmt.Errorf("example: Mul._unmarshalJSONCalc: native ref unwrap; %w", err)
	}
	return result, nil
}
