package example

// --8<-- [start:tree-def]

//go:tag mkunion:"Tree[A]"
type (
	Branch[A any] struct{ L, R Tree[A] }
	Leaf[A any]   struct{ Value A }
)

// --8<-- [end:tree-def]

// --8<-- [start:reduce-tree]

func ReduceTree[A, B any](x Tree[A], f func(A, B) B, init B) B {
	return MatchTreeR1(
		x,
		func(x *Branch[A]) B {
			return ReduceTree(x.R, f, ReduceTree(x.L, f, init))
		}, func(x *Leaf[A]) B {
			return f(x.Value, init)
		},
	)
}

// --8<-- [end:reduce-tree]

// Example of using Visitor pattern and interface, that was generated by mkunion.
var _ TreeVisitor[int] = (*sumVisitor)(nil)

type sumVisitor struct{}

func (s sumVisitor) VisitBranch(v *Branch[int]) any {
	return v.L.AcceptTree(s).(int) + v.R.AcceptTree(s).(int)
}

func (s sumVisitor) VisitLeaf(v *Leaf[int]) any {
	return v.Value
}

// --8<-- [start:match-def]

//go:tag mkmatch:"TreePairMatch"
type TreePair[T0, T1 any] interface {
	MatchLeafs(*Leaf[int], *Leaf[int])
	MatchBranches(*Branch[int], any)
	MatchMixed(any, any)
}

// --8<-- [end:match-def]

// --8<-- [start:match-use]

// CombineTreeValues returns sum of tree nodes for int nodes, and for others returns 0
// function is safe to use with any time, even if it's not a Tree
func CombineTreeValues(a, b any) int {
	return TreePairMatchR1(
		a, b,
		func(x0 *Leaf[int], x1 *Leaf[int]) int {
			// Both are leaves - add their values
			return x0.Value + x1.Value
		},
		func(x0 *Branch[int], x1 any) int {
			// First is branch - return special value
			return CombineTreeValues(x0.L, x0.R) + 1
		},
		func(x0 any, x1 any) int {
			// Mixed types - return default
			return 0
		},
	)
}

// --8<-- [end:match-use]
