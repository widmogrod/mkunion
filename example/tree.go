package example

// --8<-- [start:tree-def]

//go:tag mkunion:"Tree"
type (
	Branch[A any] struct{ L, R Tree[A] }
	Leaf[A any]   struct{ Value A }
)

// --8<-- [end:tree-def]

// --8<-- [start:reduce-tree]

func ReduceTree[A, B any](x Tree[A], f func(A, B) B, init B) B {
	return MatchTreeR1(
		x,
		func(x *Branch[A]) B {
			return ReduceTree(x.R, f, ReduceTree(x.L, f, init))
		}, func(x *Leaf[A]) B {
			return f(x.Value, init)
		},
	)
}

// --8<-- [end:reduce-tree]

// Example of using Visitor pattern and interface, that was generated by mkunion.
var _ TreeVisitor[int] = (*sumVisitor)(nil)

type sumVisitor struct{}

func (s sumVisitor) VisitBranch(v *Branch[int]) any {
	return v.L.AcceptTree(s).(int) + v.R.AcceptTree(s).(int)
}

func (s sumVisitor) VisitLeaf(v *Leaf[int]) any {
	return v.Value
}

//go:tag mkmatch:"MyName"
type MyTriesMatch[T0, T1 Tree[any]] interface {
	MatchLeafs(*Leaf[any], *Leaf[any])
	MatchBranches(*Branch[any], any)
	MatchMixed(any, any)
}

func treeDoNumbers(a, b Tree[any]) int {
	return MyNameR1(
		a, b,
		func(x0 *Leaf[any], x1 *Leaf[any]) int {
			return x0.Value.(int) + x1.Value.(int)
		},
		func(x0 *Branch[any], x1 any) int {
			return -1
		},
		func(x0 any, x1 any) int {
			return -10
		},
	)
}
