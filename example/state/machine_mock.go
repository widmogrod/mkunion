// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package state

import (
	"context"
	"sync"
	"time"
)

// Ensure, that DependencyMock does implement Dependency.
// If this is not the case, regenerate this file with moq.
var _ Dependency = &DependencyMock{}

// DependencyMock is a mock implementation of Dependency.
//
//	func TestSomethingThatUsesDependency(t *testing.T) {
//
//		// make and configure a mocked Dependency
//		mockedDependency := &DependencyMock{
//			PaymentChargeFunc: func(ctx context.Context, price Price) error {
//				panic("mock out the PaymentCharge method")
//			},
//			TimeNowFunc: func() *time.Time {
//				panic("mock out the TimeNow method")
//			},
//			WarehouseRemoveStockFunc: func(ctx context.Context, quantity Quantity) error {
//				panic("mock out the WarehouseRemoveStock method")
//			},
//		}
//
//		// use mockedDependency in code that requires Dependency
//		// and then make assertions.
//
//	}
type DependencyMock struct {
	// PaymentChargeFunc mocks the PaymentCharge method.
	PaymentChargeFunc func(ctx context.Context, price Price) error

	// TimeNowFunc mocks the TimeNow method.
	TimeNowFunc func() *time.Time

	// WarehouseRemoveStockFunc mocks the WarehouseRemoveStock method.
	WarehouseRemoveStockFunc func(ctx context.Context, quantity Quantity) error

	// calls tracks calls to the methods.
	calls struct {
		// PaymentCharge holds details about calls to the PaymentCharge method.
		PaymentCharge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Price is the price argument value.
			Price Price
		}
		// TimeNow holds details about calls to the TimeNow method.
		TimeNow []struct {
		}
		// WarehouseRemoveStock holds details about calls to the WarehouseRemoveStock method.
		WarehouseRemoveStock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Quantity is the quantity argument value.
			Quantity Quantity
		}
	}
	lockPaymentCharge        sync.RWMutex
	lockTimeNow              sync.RWMutex
	lockWarehouseRemoveStock sync.RWMutex
}

// PaymentCharge calls PaymentChargeFunc.
func (mock *DependencyMock) PaymentCharge(ctx context.Context, price Price) error {
	callInfo := struct {
		Ctx   context.Context
		Price Price
	}{
		Ctx:   ctx,
		Price: price,
	}
	mock.lockPaymentCharge.Lock()
	mock.calls.PaymentCharge = append(mock.calls.PaymentCharge, callInfo)
	mock.lockPaymentCharge.Unlock()
	if mock.PaymentChargeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PaymentChargeFunc(ctx, price)
}

// PaymentChargeCalls gets all the calls that were made to PaymentCharge.
// Check the length with:
//
//	len(mockedDependency.PaymentChargeCalls())
func (mock *DependencyMock) PaymentChargeCalls() []struct {
	Ctx   context.Context
	Price Price
} {
	var calls []struct {
		Ctx   context.Context
		Price Price
	}
	mock.lockPaymentCharge.RLock()
	calls = mock.calls.PaymentCharge
	mock.lockPaymentCharge.RUnlock()
	return calls
}

// ResetPaymentChargeCalls reset all the calls that were made to PaymentCharge.
func (mock *DependencyMock) ResetPaymentChargeCalls() {
	mock.lockPaymentCharge.Lock()
	mock.calls.PaymentCharge = nil
	mock.lockPaymentCharge.Unlock()
}

// TimeNow calls TimeNowFunc.
func (mock *DependencyMock) TimeNow() *time.Time {
	callInfo := struct {
	}{}
	mock.lockTimeNow.Lock()
	mock.calls.TimeNow = append(mock.calls.TimeNow, callInfo)
	mock.lockTimeNow.Unlock()
	if mock.TimeNowFunc == nil {
		var (
			timeOut *time.Time
		)
		return timeOut
	}
	return mock.TimeNowFunc()
}

// TimeNowCalls gets all the calls that were made to TimeNow.
// Check the length with:
//
//	len(mockedDependency.TimeNowCalls())
func (mock *DependencyMock) TimeNowCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTimeNow.RLock()
	calls = mock.calls.TimeNow
	mock.lockTimeNow.RUnlock()
	return calls
}

// ResetTimeNowCalls reset all the calls that were made to TimeNow.
func (mock *DependencyMock) ResetTimeNowCalls() {
	mock.lockTimeNow.Lock()
	mock.calls.TimeNow = nil
	mock.lockTimeNow.Unlock()
}

// WarehouseRemoveStock calls WarehouseRemoveStockFunc.
func (mock *DependencyMock) WarehouseRemoveStock(ctx context.Context, quantity Quantity) error {
	callInfo := struct {
		Ctx      context.Context
		Quantity Quantity
	}{
		Ctx:      ctx,
		Quantity: quantity,
	}
	mock.lockWarehouseRemoveStock.Lock()
	mock.calls.WarehouseRemoveStock = append(mock.calls.WarehouseRemoveStock, callInfo)
	mock.lockWarehouseRemoveStock.Unlock()
	if mock.WarehouseRemoveStockFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.WarehouseRemoveStockFunc(ctx, quantity)
}

// WarehouseRemoveStockCalls gets all the calls that were made to WarehouseRemoveStock.
// Check the length with:
//
//	len(mockedDependency.WarehouseRemoveStockCalls())
func (mock *DependencyMock) WarehouseRemoveStockCalls() []struct {
	Ctx      context.Context
	Quantity Quantity
} {
	var calls []struct {
		Ctx      context.Context
		Quantity Quantity
	}
	mock.lockWarehouseRemoveStock.RLock()
	calls = mock.calls.WarehouseRemoveStock
	mock.lockWarehouseRemoveStock.RUnlock()
	return calls
}

// ResetWarehouseRemoveStockCalls reset all the calls that were made to WarehouseRemoveStock.
func (mock *DependencyMock) ResetWarehouseRemoveStockCalls() {
	mock.lockWarehouseRemoveStock.Lock()
	mock.calls.WarehouseRemoveStock = nil
	mock.lockWarehouseRemoveStock.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *DependencyMock) ResetCalls() {
	mock.lockPaymentCharge.Lock()
	mock.calls.PaymentCharge = nil
	mock.lockPaymentCharge.Unlock()

	mock.lockTimeNow.Lock()
	mock.calls.TimeNow = nil
	mock.lockTimeNow.Unlock()

	mock.lockWarehouseRemoveStock.Lock()
	mock.calls.WarehouseRemoveStock = nil
	mock.lockWarehouseRemoveStock.Unlock()
}
