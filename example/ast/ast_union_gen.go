// Code generated by mkunion. DO NOT EDIT.
package ast

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type OperatorVisitor interface {
	VisitEq(v *Eq) any
	VisitGt(v *Gt) any
	VisitAnd(v *And) any
	VisitOr(v *Or) any
	VisitNot(v *Not) any
}

type Operator interface {
	AcceptOperator(g OperatorVisitor) any
}

var (
	_ Operator = (*Eq)(nil)
	_ Operator = (*Gt)(nil)
	_ Operator = (*And)(nil)
	_ Operator = (*Or)(nil)
	_ Operator = (*Not)(nil)
)

func (r *Eq) AcceptOperator(v OperatorVisitor) any  { return v.VisitEq(r) }
func (r *Gt) AcceptOperator(v OperatorVisitor) any  { return v.VisitGt(r) }
func (r *And) AcceptOperator(v OperatorVisitor) any { return v.VisitAnd(r) }
func (r *Or) AcceptOperator(v OperatorVisitor) any  { return v.VisitOr(r) }
func (r *Not) AcceptOperator(v OperatorVisitor) any { return v.VisitNot(r) }

func MatchOperatorR3[T0, T1, T2 any](
	x Operator,
	f1 func(x *Eq) (T0, T1, T2),
	f2 func(x *Gt) (T0, T1, T2),
	f3 func(x *And) (T0, T1, T2),
	f4 func(x *Or) (T0, T1, T2),
	f5 func(x *Not) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Eq:
		return f1(v)
	case *Gt:
		return f2(v)
	case *And:
		return f3(v)
	case *Or:
		return f4(v)
	case *Not:
		return f5(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchOperatorR2[T0, T1 any](
	x Operator,
	f1 func(x *Eq) (T0, T1),
	f2 func(x *Gt) (T0, T1),
	f3 func(x *And) (T0, T1),
	f4 func(x *Or) (T0, T1),
	f5 func(x *Not) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Eq:
		return f1(v)
	case *Gt:
		return f2(v)
	case *And:
		return f3(v)
	case *Or:
		return f4(v)
	case *Not:
		return f5(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchOperatorR1[T0 any](
	x Operator,
	f1 func(x *Eq) T0,
	f2 func(x *Gt) T0,
	f3 func(x *And) T0,
	f4 func(x *Or) T0,
	f5 func(x *Not) T0,
) T0 {
	switch v := x.(type) {
	case *Eq:
		return f1(v)
	case *Gt:
		return f2(v)
	case *And:
		return f3(v)
	case *Or:
		return f4(v)
	case *Not:
		return f5(v)
	}
	var result1 T0
	return result1
}

func MatchOperatorR0(
	x Operator,
	f1 func(x *Eq),
	f2 func(x *Gt),
	f3 func(x *And),
	f4 func(x *Or),
	f5 func(x *Not),
) {
	switch v := x.(type) {
	case *Eq:
		f1(v)
	case *Gt:
		f2(v)
	case *And:
		f3(v)
	case *Or:
		f4(v)
	case *Not:
		f5(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.And", AndFromJSON, AndToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Eq", EqFromJSON, EqToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Gt", GtFromJSON, GtToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Not", NotFromJSON, NotToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Operator", OperatorFromJSON, OperatorToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Or", OrFromJSON, OrToJSON)
}

type OperatorUnionJSON struct {
	Type string          `json:"$type,omitempty"`
	Eq   json.RawMessage `json:"ast.Eq,omitempty"`
	Gt   json.RawMessage `json:"ast.Gt,omitempty"`
	And  json.RawMessage `json:"ast.And,omitempty"`
	Or   json.RawMessage `json:"ast.Or,omitempty"`
	Not  json.RawMessage `json:"ast.Not,omitempty"`
}

func OperatorFromJSON(x []byte) (Operator, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data OperatorUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("ast.OperatorFromJSON: %w", err)
	}

	switch data.Type {
	case "ast.Eq":
		return EqFromJSON(data.Eq)
	case "ast.Gt":
		return GtFromJSON(data.Gt)
	case "ast.And":
		return AndFromJSON(data.And)
	case "ast.Or":
		return OrFromJSON(data.Or)
	case "ast.Not":
		return NotFromJSON(data.Not)
	}

	if data.Eq != nil {
		return EqFromJSON(data.Eq)
	} else if data.Gt != nil {
		return GtFromJSON(data.Gt)
	} else if data.And != nil {
		return AndFromJSON(data.And)
	} else if data.Or != nil {
		return OrFromJSON(data.Or)
	} else if data.Not != nil {
		return NotFromJSON(data.Not)
	}
	return nil, fmt.Errorf("ast.OperatorFromJSON: unknown type: %s", data.Type)
}

func OperatorToJSON(x Operator) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchOperatorR2(
		x,
		func(y *Eq) ([]byte, error) {
			body, err := EqToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.OperatorToJSON: %w", err)
			}
			return json.Marshal(OperatorUnionJSON{
				Type: "ast.Eq",
				Eq:   body,
			})
		},
		func(y *Gt) ([]byte, error) {
			body, err := GtToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.OperatorToJSON: %w", err)
			}
			return json.Marshal(OperatorUnionJSON{
				Type: "ast.Gt",
				Gt:   body,
			})
		},
		func(y *And) ([]byte, error) {
			body, err := AndToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.OperatorToJSON: %w", err)
			}
			return json.Marshal(OperatorUnionJSON{
				Type: "ast.And",
				And:  body,
			})
		},
		func(y *Or) ([]byte, error) {
			body, err := OrToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.OperatorToJSON: %w", err)
			}
			return json.Marshal(OperatorUnionJSON{
				Type: "ast.Or",
				Or:   body,
			})
		},
		func(y *Not) ([]byte, error) {
			body, err := NotToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.OperatorToJSON: %w", err)
			}
			return json.Marshal(OperatorUnionJSON{
				Type: "ast.Not",
				Not:  body,
			})
		},
	)
}

func EqFromJSON(x []byte) (*Eq, error) {
	result := new(Eq)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.EqFromJSON: %w", err)
	}
	return result, nil
}

func EqToJSON(x *Eq) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Eq)(nil)
	_ json.Marshaler   = (*Eq)(nil)
)

func (r *Eq) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONEq(*r)
}
func (r *Eq) _marshalJSONEq(x Eq) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldL []byte
	fieldL, err = r._marshalJSONValue(x.L)
	if err != nil {
		return nil, fmt.Errorf("ast: Eq._marshalJSONEq: field name L; %w", err)
	}
	partial["L"] = fieldL
	var fieldR []byte
	fieldR, err = r._marshalJSONValue(x.R)
	if err != nil {
		return nil, fmt.Errorf("ast: Eq._marshalJSONEq: field name R; %w", err)
	}
	partial["R"] = fieldR
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Eq._marshalJSONEq: struct; %w", err)
	}
	return result, nil
}
func (r *Eq) _marshalJSONValue(x Value) ([]byte, error) {
	result, err := shared.JSONMarshal[Value](x)
	if err != nil {
		return nil, fmt.Errorf("ast: Eq._marshalJSONValue:; %w", err)
	}
	return result, nil
}
func (r *Eq) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONEq(data)
	if err != nil {
		return fmt.Errorf("ast: Eq.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Eq) _unmarshalJSONEq(data []byte) (Eq, error) {
	result := Eq{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Eq._unmarshalJSONEq: native struct unwrap; %w", err)
	}
	if fieldL, ok := partial["L"]; ok {
		result.L, err = r._unmarshalJSONValue(fieldL)
		if err != nil {
			return result, fmt.Errorf("ast: Eq._unmarshalJSONEq: field L; %w", err)
		}
	}
	if fieldR, ok := partial["R"]; ok {
		result.R, err = r._unmarshalJSONValue(fieldR)
		if err != nil {
			return result, fmt.Errorf("ast: Eq._unmarshalJSONEq: field R; %w", err)
		}
	}
	return result, nil
}
func (r *Eq) _unmarshalJSONValue(data []byte) (Value, error) {
	result, err := shared.JSONUnmarshal[Value](data)
	if err != nil {
		return result, fmt.Errorf("ast: Eq._unmarshalJSONValue: native ref unwrap; %w", err)
	}
	return result, nil
}

func GtFromJSON(x []byte) (*Gt, error) {
	result := new(Gt)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.GtFromJSON: %w", err)
	}
	return result, nil
}

func GtToJSON(x *Gt) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Gt)(nil)
	_ json.Marshaler   = (*Gt)(nil)
)

func (r *Gt) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONGt(*r)
}
func (r *Gt) _marshalJSONGt(x Gt) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldL []byte
	fieldL, err = r._marshalJSONValue(x.L)
	if err != nil {
		return nil, fmt.Errorf("ast: Gt._marshalJSONGt: field name L; %w", err)
	}
	partial["L"] = fieldL
	var fieldR []byte
	fieldR, err = r._marshalJSONValue(x.R)
	if err != nil {
		return nil, fmt.Errorf("ast: Gt._marshalJSONGt: field name R; %w", err)
	}
	partial["R"] = fieldR
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Gt._marshalJSONGt: struct; %w", err)
	}
	return result, nil
}
func (r *Gt) _marshalJSONValue(x Value) ([]byte, error) {
	result, err := shared.JSONMarshal[Value](x)
	if err != nil {
		return nil, fmt.Errorf("ast: Gt._marshalJSONValue:; %w", err)
	}
	return result, nil
}
func (r *Gt) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONGt(data)
	if err != nil {
		return fmt.Errorf("ast: Gt.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Gt) _unmarshalJSONGt(data []byte) (Gt, error) {
	result := Gt{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Gt._unmarshalJSONGt: native struct unwrap; %w", err)
	}
	if fieldL, ok := partial["L"]; ok {
		result.L, err = r._unmarshalJSONValue(fieldL)
		if err != nil {
			return result, fmt.Errorf("ast: Gt._unmarshalJSONGt: field L; %w", err)
		}
	}
	if fieldR, ok := partial["R"]; ok {
		result.R, err = r._unmarshalJSONValue(fieldR)
		if err != nil {
			return result, fmt.Errorf("ast: Gt._unmarshalJSONGt: field R; %w", err)
		}
	}
	return result, nil
}
func (r *Gt) _unmarshalJSONValue(data []byte) (Value, error) {
	result, err := shared.JSONUnmarshal[Value](data)
	if err != nil {
		return result, fmt.Errorf("ast: Gt._unmarshalJSONValue: native ref unwrap; %w", err)
	}
	return result, nil
}

func AndFromJSON(x []byte) (*And, error) {
	result := new(And)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.AndFromJSON: %w", err)
	}
	return result, nil
}

func AndToJSON(x *And) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*And)(nil)
	_ json.Marshaler   = (*And)(nil)
)

func (r *And) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAnd(*r)
}
func (r *And) _marshalJSONAnd(x And) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldList []byte
	fieldList, err = r._marshalJSONSliceOperator(x.List)
	if err != nil {
		return nil, fmt.Errorf("ast: And._marshalJSONAnd: field name List; %w", err)
	}
	partial["List"] = fieldList
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: And._marshalJSONAnd: struct; %w", err)
	}
	return result, nil
}
func (r *And) _marshalJSONSliceOperator(x []Operator) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONOperator(v)
		if err != nil {
			return nil, fmt.Errorf("ast: And._marshalJSONSliceOperator: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: And._marshalJSONSliceOperator:; %w", err)
	}
	return result, nil
}
func (r *And) _marshalJSONOperator(x Operator) ([]byte, error) {
	result, err := shared.JSONMarshal[Operator](x)
	if err != nil {
		return nil, fmt.Errorf("ast: And._marshalJSONOperator:; %w", err)
	}
	return result, nil
}
func (r *And) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAnd(data)
	if err != nil {
		return fmt.Errorf("ast: And.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *And) _unmarshalJSONAnd(data []byte) (And, error) {
	result := And{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: And._unmarshalJSONAnd: native struct unwrap; %w", err)
	}
	if fieldList, ok := partial["List"]; ok {
		result.List, err = r._unmarshalJSONSliceOperator(fieldList)
		if err != nil {
			return result, fmt.Errorf("ast: And._unmarshalJSONAnd: field List; %w", err)
		}
	}
	return result, nil
}
func (r *And) _unmarshalJSONSliceOperator(data []byte) ([]Operator, error) {
	result := make([]Operator, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: And._unmarshalJSONSliceOperator: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONOperator(v)
		if err != nil {
			return result, fmt.Errorf("ast: And._unmarshalJSONSliceOperator: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *And) _unmarshalJSONOperator(data []byte) (Operator, error) {
	result, err := shared.JSONUnmarshal[Operator](data)
	if err != nil {
		return result, fmt.Errorf("ast: And._unmarshalJSONOperator: native ref unwrap; %w", err)
	}
	return result, nil
}

func OrFromJSON(x []byte) (*Or, error) {
	result := new(Or)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.OrFromJSON: %w", err)
	}
	return result, nil
}

func OrToJSON(x *Or) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Or)(nil)
	_ json.Marshaler   = (*Or)(nil)
)

func (r *Or) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONOr(*r)
}
func (r *Or) _marshalJSONOr(x Or) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldList []byte
	fieldList, err = r._marshalJSONSliceOperator(x.List)
	if err != nil {
		return nil, fmt.Errorf("ast: Or._marshalJSONOr: field name List; %w", err)
	}
	partial["List"] = fieldList
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Or._marshalJSONOr: struct; %w", err)
	}
	return result, nil
}
func (r *Or) _marshalJSONSliceOperator(x []Operator) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONOperator(v)
		if err != nil {
			return nil, fmt.Errorf("ast: Or._marshalJSONSliceOperator: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Or._marshalJSONSliceOperator:; %w", err)
	}
	return result, nil
}
func (r *Or) _marshalJSONOperator(x Operator) ([]byte, error) {
	result, err := shared.JSONMarshal[Operator](x)
	if err != nil {
		return nil, fmt.Errorf("ast: Or._marshalJSONOperator:; %w", err)
	}
	return result, nil
}
func (r *Or) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONOr(data)
	if err != nil {
		return fmt.Errorf("ast: Or.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Or) _unmarshalJSONOr(data []byte) (Or, error) {
	result := Or{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Or._unmarshalJSONOr: native struct unwrap; %w", err)
	}
	if fieldList, ok := partial["List"]; ok {
		result.List, err = r._unmarshalJSONSliceOperator(fieldList)
		if err != nil {
			return result, fmt.Errorf("ast: Or._unmarshalJSONOr: field List; %w", err)
		}
	}
	return result, nil
}
func (r *Or) _unmarshalJSONSliceOperator(data []byte) ([]Operator, error) {
	result := make([]Operator, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Or._unmarshalJSONSliceOperator: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONOperator(v)
		if err != nil {
			return result, fmt.Errorf("ast: Or._unmarshalJSONSliceOperator: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Or) _unmarshalJSONOperator(data []byte) (Operator, error) {
	result, err := shared.JSONUnmarshal[Operator](data)
	if err != nil {
		return result, fmt.Errorf("ast: Or._unmarshalJSONOperator: native ref unwrap; %w", err)
	}
	return result, nil
}

func NotFromJSON(x []byte) (*Not, error) {
	result := new(Not)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.NotFromJSON: %w", err)
	}
	return result, nil
}

func NotToJSON(x *Not) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Not)(nil)
	_ json.Marshaler   = (*Not)(nil)
)

func (r *Not) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONNot(*r)
}
func (r *Not) _marshalJSONNot(x Not) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldOperator []byte
	fieldOperator, err = r._marshalJSONOperator(x.Operator)
	if err != nil {
		return nil, fmt.Errorf("ast: Not._marshalJSONNot: field name Operator; %w", err)
	}
	partial["Operator"] = fieldOperator
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Not._marshalJSONNot: struct; %w", err)
	}
	return result, nil
}
func (r *Not) _marshalJSONOperator(x Operator) ([]byte, error) {
	result, err := shared.JSONMarshal[Operator](x)
	if err != nil {
		return nil, fmt.Errorf("ast: Not._marshalJSONOperator:; %w", err)
	}
	return result, nil
}
func (r *Not) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONNot(data)
	if err != nil {
		return fmt.Errorf("ast: Not.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Not) _unmarshalJSONNot(data []byte) (Not, error) {
	result := Not{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Not._unmarshalJSONNot: native struct unwrap; %w", err)
	}
	if fieldOperator, ok := partial["Operator"]; ok {
		result.Operator, err = r._unmarshalJSONOperator(fieldOperator)
		if err != nil {
			return result, fmt.Errorf("ast: Not._unmarshalJSONNot: field Operator; %w", err)
		}
	}
	return result, nil
}
func (r *Not) _unmarshalJSONOperator(data []byte) (Operator, error) {
	result, err := shared.JSONUnmarshal[Operator](data)
	if err != nil {
		return result, fmt.Errorf("ast: Not._unmarshalJSONOperator: native ref unwrap; %w", err)
	}
	return result, nil
}

type ValueVisitor interface {
	VisitLit(v *Lit) any
	VisitAccessor(v *Accessor) any
}

type Value interface {
	AcceptValue(g ValueVisitor) any
}

var (
	_ Value = (*Lit)(nil)
	_ Value = (*Accessor)(nil)
)

func (r *Lit) AcceptValue(v ValueVisitor) any      { return v.VisitLit(r) }
func (r *Accessor) AcceptValue(v ValueVisitor) any { return v.VisitAccessor(r) }

func MatchValueR3[T0, T1, T2 any](
	x Value,
	f1 func(x *Lit) (T0, T1, T2),
	f2 func(x *Accessor) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Lit:
		return f1(v)
	case *Accessor:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchValueR2[T0, T1 any](
	x Value,
	f1 func(x *Lit) (T0, T1),
	f2 func(x *Accessor) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Lit:
		return f1(v)
	case *Accessor:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchValueR1[T0 any](
	x Value,
	f1 func(x *Lit) T0,
	f2 func(x *Accessor) T0,
) T0 {
	switch v := x.(type) {
	case *Lit:
		return f1(v)
	case *Accessor:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchValueR0(
	x Value,
	f1 func(x *Lit),
	f2 func(x *Accessor),
) {
	switch v := x.(type) {
	case *Lit:
		f1(v)
	case *Accessor:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Accessor", AccessorFromJSON, AccessorToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Lit", LitFromJSON, LitToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.Value", ValueFromJSON, ValueToJSON)
}

type ValueUnionJSON struct {
	Type     string          `json:"$type,omitempty"`
	Lit      json.RawMessage `json:"ast.Lit,omitempty"`
	Accessor json.RawMessage `json:"ast.Accessor,omitempty"`
}

func ValueFromJSON(x []byte) (Value, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data ValueUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("ast.ValueFromJSON: %w", err)
	}

	switch data.Type {
	case "ast.Lit":
		return LitFromJSON(data.Lit)
	case "ast.Accessor":
		return AccessorFromJSON(data.Accessor)
	}

	if data.Lit != nil {
		return LitFromJSON(data.Lit)
	} else if data.Accessor != nil {
		return AccessorFromJSON(data.Accessor)
	}
	return nil, fmt.Errorf("ast.ValueFromJSON: unknown type: %s", data.Type)
}

func ValueToJSON(x Value) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchValueR2(
		x,
		func(y *Lit) ([]byte, error) {
			body, err := LitToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.ValueToJSON: %w", err)
			}
			return json.Marshal(ValueUnionJSON{
				Type: "ast.Lit",
				Lit:  body,
			})
		},
		func(y *Accessor) ([]byte, error) {
			body, err := AccessorToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.ValueToJSON: %w", err)
			}
			return json.Marshal(ValueUnionJSON{
				Type:     "ast.Accessor",
				Accessor: body,
			})
		},
	)
}

func LitFromJSON(x []byte) (*Lit, error) {
	result := new(Lit)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.LitFromJSON: %w", err)
	}
	return result, nil
}

func LitToJSON(x *Lit) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Lit)(nil)
	_ json.Marshaler   = (*Lit)(nil)
)

func (r *Lit) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONLit(*r)
}
func (r *Lit) _marshalJSONLit(x Lit) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldValue []byte
	fieldValue, err = r._marshalJSONany(x.Value)
	if err != nil {
		return nil, fmt.Errorf("ast: Lit._marshalJSONLit: field name Value; %w", err)
	}
	partial["Value"] = fieldValue
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Lit._marshalJSONLit: struct; %w", err)
	}
	return result, nil
}
func (r *Lit) _marshalJSONany(x any) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("ast: Lit._marshalJSONany:; %w", err)
	}
	return result, nil
}
func (r *Lit) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONLit(data)
	if err != nil {
		return fmt.Errorf("ast: Lit.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Lit) _unmarshalJSONLit(data []byte) (Lit, error) {
	result := Lit{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Lit._unmarshalJSONLit: native struct unwrap; %w", err)
	}
	if fieldValue, ok := partial["Value"]; ok {
		result.Value, err = r._unmarshalJSONany(fieldValue)
		if err != nil {
			return result, fmt.Errorf("ast: Lit._unmarshalJSONLit: field Value; %w", err)
		}
	}
	return result, nil
}
func (r *Lit) _unmarshalJSONany(data []byte) (any, error) {
	var result any
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("ast: Lit._unmarshalJSONany: native any unwrap; %w", err)
	}
	return result, nil
}

func AccessorFromJSON(x []byte) (*Accessor, error) {
	result := new(Accessor)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.AccessorFromJSON: %w", err)
	}
	return result, nil
}

func AccessorToJSON(x *Accessor) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Accessor)(nil)
	_ json.Marshaler   = (*Accessor)(nil)
)

func (r *Accessor) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONAccessor(*r)
}
func (r *Accessor) _marshalJSONAccessor(x Accessor) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldPath []byte
	fieldPath, err = r._marshalJSONSlicestring(x.Path)
	if err != nil {
		return nil, fmt.Errorf("ast: Accessor._marshalJSONAccessor: field name Path; %w", err)
	}
	partial["Path"] = fieldPath
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Accessor._marshalJSONAccessor: struct; %w", err)
	}
	return result, nil
}
func (r *Accessor) _marshalJSONSlicestring(x []string) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONstring(v)
		if err != nil {
			return nil, fmt.Errorf("ast: Accessor._marshalJSONSlicestring: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: Accessor._marshalJSONSlicestring:; %w", err)
	}
	return result, nil
}
func (r *Accessor) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("ast: Accessor._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Accessor) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONAccessor(data)
	if err != nil {
		return fmt.Errorf("ast: Accessor.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Accessor) _unmarshalJSONAccessor(data []byte) (Accessor, error) {
	result := Accessor{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Accessor._unmarshalJSONAccessor: native struct unwrap; %w", err)
	}
	if fieldPath, ok := partial["Path"]; ok {
		result.Path, err = r._unmarshalJSONSlicestring(fieldPath)
		if err != nil {
			return result, fmt.Errorf("ast: Accessor._unmarshalJSONAccessor: field Path; %w", err)
		}
	}
	return result, nil
}
func (r *Accessor) _unmarshalJSONSlicestring(data []byte) ([]string, error) {
	result := make([]string, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: Accessor._unmarshalJSONSlicestring: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONstring(v)
		if err != nil {
			return result, fmt.Errorf("ast: Accessor._unmarshalJSONSlicestring: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *Accessor) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("ast: Accessor._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
