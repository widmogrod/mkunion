// Code generated by mkunion. DO NOT EDIT.
package ast

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type SyntaxSugarVisitor interface {
	VisitEqTo(v *EqTo) any
	VisitGrThan(v *GrThan) any
	VisitOrFields(v *OrFields) any
}

type SyntaxSugar interface {
	AcceptSyntaxSugar(g SyntaxSugarVisitor) any
}

var (
	_ SyntaxSugar = (*EqTo)(nil)
	_ SyntaxSugar = (*GrThan)(nil)
	_ SyntaxSugar = (*OrFields)(nil)
)

func (r *EqTo) AcceptSyntaxSugar(v SyntaxSugarVisitor) any     { return v.VisitEqTo(r) }
func (r *GrThan) AcceptSyntaxSugar(v SyntaxSugarVisitor) any   { return v.VisitGrThan(r) }
func (r *OrFields) AcceptSyntaxSugar(v SyntaxSugarVisitor) any { return v.VisitOrFields(r) }

func MatchSyntaxSugarR3[T0, T1, T2 any](
	x SyntaxSugar,
	f1 func(x *EqTo) (T0, T1, T2),
	f2 func(x *GrThan) (T0, T1, T2),
	f3 func(x *OrFields) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *EqTo:
		return f1(v)
	case *GrThan:
		return f2(v)
	case *OrFields:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchSyntaxSugarR2[T0, T1 any](
	x SyntaxSugar,
	f1 func(x *EqTo) (T0, T1),
	f2 func(x *GrThan) (T0, T1),
	f3 func(x *OrFields) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *EqTo:
		return f1(v)
	case *GrThan:
		return f2(v)
	case *OrFields:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchSyntaxSugarR1[T0 any](
	x SyntaxSugar,
	f1 func(x *EqTo) T0,
	f2 func(x *GrThan) T0,
	f3 func(x *OrFields) T0,
) T0 {
	switch v := x.(type) {
	case *EqTo:
		return f1(v)
	case *GrThan:
		return f2(v)
	case *OrFields:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchSyntaxSugarR0(
	x SyntaxSugar,
	f1 func(x *EqTo),
	f2 func(x *GrThan),
	f3 func(x *OrFields),
) {
	switch v := x.(type) {
	case *EqTo:
		f1(v)
	case *GrThan:
		f2(v)
	case *OrFields:
		f3(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.EqTo", EqToFromJSON, EqToToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.GrThan", GrThanFromJSON, GrThanToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.OrFields", OrFieldsFromJSON, OrFieldsToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/ast.SyntaxSugar", SyntaxSugarFromJSON, SyntaxSugarToJSON)
}

type SyntaxSugarUnionJSON struct {
	Type     string          `json:"$type,omitempty"`
	EqTo     json.RawMessage `json:"ast.EqTo,omitempty"`
	GrThan   json.RawMessage `json:"ast.GrThan,omitempty"`
	OrFields json.RawMessage `json:"ast.OrFields,omitempty"`
}

func SyntaxSugarFromJSON(x []byte) (SyntaxSugar, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data SyntaxSugarUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("ast.SyntaxSugarFromJSON: %w", err)
	}

	switch data.Type {
	case "ast.EqTo":
		return EqToFromJSON(data.EqTo)
	case "ast.GrThan":
		return GrThanFromJSON(data.GrThan)
	case "ast.OrFields":
		return OrFieldsFromJSON(data.OrFields)
	}

	if data.EqTo != nil {
		return EqToFromJSON(data.EqTo)
	} else if data.GrThan != nil {
		return GrThanFromJSON(data.GrThan)
	} else if data.OrFields != nil {
		return OrFieldsFromJSON(data.OrFields)
	}
	return nil, fmt.Errorf("ast.SyntaxSugarFromJSON: unknown type: %s", data.Type)
}

func SyntaxSugarToJSON(x SyntaxSugar) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchSyntaxSugarR2(
		x,
		func(y *EqTo) ([]byte, error) {
			body, err := EqToToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.SyntaxSugarToJSON: %w", err)
			}
			return json.Marshal(SyntaxSugarUnionJSON{
				Type: "ast.EqTo",
				EqTo: body,
			})
		},
		func(y *GrThan) ([]byte, error) {
			body, err := GrThanToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.SyntaxSugarToJSON: %w", err)
			}
			return json.Marshal(SyntaxSugarUnionJSON{
				Type:   "ast.GrThan",
				GrThan: body,
			})
		},
		func(y *OrFields) ([]byte, error) {
			body, err := OrFieldsToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("ast.SyntaxSugarToJSON: %w", err)
			}
			return json.Marshal(SyntaxSugarUnionJSON{
				Type:     "ast.OrFields",
				OrFields: body,
			})
		},
	)
}

func EqToFromJSON(x []byte) (*EqTo, error) {
	result := new(EqTo)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.EqToFromJSON: %w", err)
	}
	return result, nil
}

func EqToToJSON(x *EqTo) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*EqTo)(nil)
	_ json.Marshaler   = (*EqTo)(nil)
)

func (r *EqTo) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONEqTo(*r)
}
func (r *EqTo) _marshalJSONEqTo(x EqTo) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldV []byte
	fieldV, err = r._marshalJSONany(x.V)
	if err != nil {
		return nil, fmt.Errorf("ast: EqTo._marshalJSONEqTo: field name V; %w", err)
	}
	partial["V"] = fieldV
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: EqTo._marshalJSONEqTo: struct; %w", err)
	}
	return result, nil
}
func (r *EqTo) _marshalJSONany(x any) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("ast: EqTo._marshalJSONany:; %w", err)
	}
	return result, nil
}
func (r *EqTo) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONEqTo(data)
	if err != nil {
		return fmt.Errorf("ast: EqTo.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *EqTo) _unmarshalJSONEqTo(data []byte) (EqTo, error) {
	result := EqTo{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: EqTo._unmarshalJSONEqTo: native struct unwrap; %w", err)
	}
	if fieldV, ok := partial["V"]; ok {
		result.V, err = r._unmarshalJSONany(fieldV)
		if err != nil {
			return result, fmt.Errorf("ast: EqTo._unmarshalJSONEqTo: field V; %w", err)
		}
	}
	return result, nil
}
func (r *EqTo) _unmarshalJSONany(data []byte) (any, error) {
	var result any
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("ast: EqTo._unmarshalJSONany: native any unwrap; %w", err)
	}
	return result, nil
}

func GrThanFromJSON(x []byte) (*GrThan, error) {
	result := new(GrThan)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.GrThanFromJSON: %w", err)
	}
	return result, nil
}

func GrThanToJSON(x *GrThan) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*GrThan)(nil)
	_ json.Marshaler   = (*GrThan)(nil)
)

func (r *GrThan) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONGrThan(*r)
}
func (r *GrThan) _marshalJSONGrThan(x GrThan) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldV []byte
	fieldV, err = r._marshalJSONany(x.V)
	if err != nil {
		return nil, fmt.Errorf("ast: GrThan._marshalJSONGrThan: field name V; %w", err)
	}
	partial["V"] = fieldV
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: GrThan._marshalJSONGrThan: struct; %w", err)
	}
	return result, nil
}
func (r *GrThan) _marshalJSONany(x any) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("ast: GrThan._marshalJSONany:; %w", err)
	}
	return result, nil
}
func (r *GrThan) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONGrThan(data)
	if err != nil {
		return fmt.Errorf("ast: GrThan.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *GrThan) _unmarshalJSONGrThan(data []byte) (GrThan, error) {
	result := GrThan{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: GrThan._unmarshalJSONGrThan: native struct unwrap; %w", err)
	}
	if fieldV, ok := partial["V"]; ok {
		result.V, err = r._unmarshalJSONany(fieldV)
		if err != nil {
			return result, fmt.Errorf("ast: GrThan._unmarshalJSONGrThan: field V; %w", err)
		}
	}
	return result, nil
}
func (r *GrThan) _unmarshalJSONany(data []byte) (any, error) {
	var result any
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("ast: GrThan._unmarshalJSONany: native any unwrap; %w", err)
	}
	return result, nil
}

func OrFieldsFromJSON(x []byte) (*OrFields, error) {
	result := new(OrFields)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("ast.OrFieldsFromJSON: %w", err)
	}
	return result, nil
}

func OrFieldsToJSON(x *OrFields) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*OrFields)(nil)
	_ json.Marshaler   = (*OrFields)(nil)
)

func (r *OrFields) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONOrFields(*r)
}
func (r *OrFields) _marshalJSONOrFields(x OrFields) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldM []byte
	fieldM, err = r._marshalJSONmapLb_string_bLSyntaxSugar(x.M)
	if err != nil {
		return nil, fmt.Errorf("ast: OrFields._marshalJSONOrFields: field name M; %w", err)
	}
	partial["M"] = fieldM
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: OrFields._marshalJSONOrFields: struct; %w", err)
	}
	return result, nil
}
func (r *OrFields) _marshalJSONmapLb_string_bLSyntaxSugar(x map[string]SyntaxSugar) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	for k, v := range x {
		key := string(k)
		value, err := r._marshalJSONSyntaxSugar(v)
		if err != nil {
			return nil, fmt.Errorf("ast: OrFields._marshalJSONmapLb_string_bLSyntaxSugar: value; %w", err)
		}
		partial[string(key)] = value
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("ast: OrFields._marshalJSONmapLb_string_bLSyntaxSugar:; %w", err)
	}
	return result, nil
}
func (r *OrFields) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("ast: OrFields._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *OrFields) _marshalJSONSyntaxSugar(x SyntaxSugar) ([]byte, error) {
	result, err := shared.JSONMarshal[SyntaxSugar](x)
	if err != nil {
		return nil, fmt.Errorf("ast: OrFields._marshalJSONSyntaxSugar:; %w", err)
	}
	return result, nil
}
func (r *OrFields) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONOrFields(data)
	if err != nil {
		return fmt.Errorf("ast: OrFields.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *OrFields) _unmarshalJSONOrFields(data []byte) (OrFields, error) {
	result := OrFields{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("ast: OrFields._unmarshalJSONOrFields: native struct unwrap; %w", err)
	}
	if fieldM, ok := partial["M"]; ok {
		result.M, err = r._unmarshalJSONmapLb_string_bLSyntaxSugar(fieldM)
		if err != nil {
			return result, fmt.Errorf("ast: OrFields._unmarshalJSONOrFields: field M; %w", err)
		}
	}
	return result, nil
}
func (r *OrFields) _unmarshalJSONmapLb_string_bLSyntaxSugar(data []byte) (map[string]SyntaxSugar, error) {
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return nil, fmt.Errorf("ast: OrFields._unmarshalJSONmapLb_string_bLSyntaxSugar: native map unwrap; %w", err)
	}
	result := make(map[string]SyntaxSugar)
	for k, v := range partial {
		key := string(k)
		value, err := r._unmarshalJSONSyntaxSugar(v)
		if err != nil {
			return nil, fmt.Errorf("ast: OrFields._unmarshalJSONmapLb_string_bLSyntaxSugar: value; %w", err)
		}
		result[key] = value
	}
	return result, nil
}
func (r *OrFields) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("ast: OrFields._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *OrFields) _unmarshalJSONSyntaxSugar(data []byte) (SyntaxSugar, error) {
	result, err := shared.JSONUnmarshal[SyntaxSugar](data)
	if err != nil {
		return result, fmt.Errorf("ast: OrFields._unmarshalJSONSyntaxSugar: native ref unwrap; %w", err)
	}
	return result, nil
}
