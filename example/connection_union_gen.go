// Code generated by mkunion. DO NOT EDIT.
package example

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
	"net"
)

type ConnectionVisitor[State any] interface {
	VisitDisconnected(v *Disconnected[State]) any
	VisitConnecting(v *Connecting[State]) any
	VisitConnected(v *Connected[State]) any
}

type Connection[State any] interface {
	AcceptConnection(g ConnectionVisitor[State]) any
}

var (
	_ Connection[any] = (*Disconnected[any])(nil)
	_ Connection[any] = (*Connecting[any])(nil)
	_ Connection[any] = (*Connected[any])(nil)
)

func (r *Disconnected[State]) AcceptConnection(v ConnectionVisitor[State]) any {
	return v.VisitDisconnected(r)
}
func (r *Connecting[State]) AcceptConnection(v ConnectionVisitor[State]) any {
	return v.VisitConnecting(r)
}
func (r *Connected[State]) AcceptConnection(v ConnectionVisitor[State]) any {
	return v.VisitConnected(r)
}

func MatchConnectionR3[State any, T0, T1, T2 any](
	x Connection[State],
	f1 func(x *Disconnected[State]) (T0, T1, T2),
	f2 func(x *Connecting[State]) (T0, T1, T2),
	f3 func(x *Connected[State]) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Disconnected[State]:
		return f1(v)
	case *Connecting[State]:
		return f2(v)
	case *Connected[State]:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchConnectionR2[State any, T0, T1 any](
	x Connection[State],
	f1 func(x *Disconnected[State]) (T0, T1),
	f2 func(x *Connecting[State]) (T0, T1),
	f3 func(x *Connected[State]) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Disconnected[State]:
		return f1(v)
	case *Connecting[State]:
		return f2(v)
	case *Connected[State]:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchConnectionR1[State any, T0 any](
	x Connection[State],
	f1 func(x *Disconnected[State]) T0,
	f2 func(x *Connecting[State]) T0,
	f3 func(x *Connected[State]) T0,
) T0 {
	switch v := x.(type) {
	case *Disconnected[State]:
		return f1(v)
	case *Connecting[State]:
		return f2(v)
	case *Connected[State]:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchConnectionR0[State any](
	x Connection[State],
	f1 func(x *Disconnected[State]),
	f2 func(x *Connecting[State]),
	f3 func(x *Connected[State]),
) {
	switch v := x.(type) {
	case *Disconnected[State]:
		f1(v)
	case *Connecting[State]:
		f2(v)
	case *Connected[State]:
		f3(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Connected[any]", ConnectedFromJSON[any], ConnectedToJSON[any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Connecting[any]", ConnectingFromJSON[any], ConnectingToJSON[any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Connection[any]", ConnectionFromJSON[any], ConnectionToJSON[any])
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example.Disconnected[any]", DisconnectedFromJSON[any], DisconnectedToJSON[any])
}

type ConnectionUnionJSON[State any] struct {
	Type         string          `json:"$type,omitempty"`
	Disconnected json.RawMessage `json:"example.Disconnected,omitempty"`
	Connecting   json.RawMessage `json:"example.Connecting,omitempty"`
	Connected    json.RawMessage `json:"example.Connected,omitempty"`
}

func ConnectionFromJSON[State any](x []byte) (Connection[State], error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data ConnectionUnionJSON[State]
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("example.ConnectionFromJSON[State]: %w", err)
	}

	switch data.Type {
	case "example.Disconnected":
		return DisconnectedFromJSON[State](data.Disconnected)
	case "example.Connecting":
		return ConnectingFromJSON[State](data.Connecting)
	case "example.Connected":
		return ConnectedFromJSON[State](data.Connected)
	}

	if data.Disconnected != nil {
		return DisconnectedFromJSON[State](data.Disconnected)
	} else if data.Connecting != nil {
		return ConnectingFromJSON[State](data.Connecting)
	} else if data.Connected != nil {
		return ConnectedFromJSON[State](data.Connected)
	}
	return nil, fmt.Errorf("example.ConnectionFromJSON[State]: unknown type: %s", data.Type)
}

func ConnectionToJSON[State any](x Connection[State]) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchConnectionR2(
		x,
		func(y *Disconnected[State]) ([]byte, error) {
			body, err := DisconnectedToJSON[State](y)
			if err != nil {
				return nil, fmt.Errorf("example.ConnectionToJSON[State]: %w", err)
			}
			return json.Marshal(ConnectionUnionJSON[State]{
				Type:         "example.Disconnected",
				Disconnected: body,
			})
		},
		func(y *Connecting[State]) ([]byte, error) {
			body, err := ConnectingToJSON[State](y)
			if err != nil {
				return nil, fmt.Errorf("example.ConnectionToJSON[State]: %w", err)
			}
			return json.Marshal(ConnectionUnionJSON[State]{
				Type:       "example.Connecting",
				Connecting: body,
			})
		},
		func(y *Connected[State]) ([]byte, error) {
			body, err := ConnectedToJSON[State](y)
			if err != nil {
				return nil, fmt.Errorf("example.ConnectionToJSON[State]: %w", err)
			}
			return json.Marshal(ConnectionUnionJSON[State]{
				Type:      "example.Connected",
				Connected: body,
			})
		},
	)
}

func DisconnectedFromJSON[State any](x []byte) (*Disconnected[State], error) {
	result := new(Disconnected[State])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("example.DisconnectedFromJSON[State]: %w", err)
	}
	return result, nil
}

func DisconnectedToJSON[State any](x *Disconnected[State]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Disconnected[any])(nil)
	_ json.Marshaler   = (*Disconnected[any])(nil)
)

func (r *Disconnected[State]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONDisconnectedLb_State_bL(*r)
}
func (r *Disconnected[State]) _marshalJSONDisconnectedLb_State_bL(x Disconnected[State]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("example: Disconnected[State]._marshalJSONDisconnectedLb_State_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Disconnected[State]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONDisconnectedLb_State_bL(data)
	if err != nil {
		return fmt.Errorf("example: Disconnected[State].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Disconnected[State]) _unmarshalJSONDisconnectedLb_State_bL(data []byte) (Disconnected[State], error) {
	result := Disconnected[State]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("example: Disconnected[State]._unmarshalJSONDisconnectedLb_State_bL: native struct unwrap; %w", err)
	}
	return result, nil
}

func ConnectingFromJSON[State any](x []byte) (*Connecting[State], error) {
	result := new(Connecting[State])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("example.ConnectingFromJSON[State]: %w", err)
	}
	return result, nil
}

func ConnectingToJSON[State any](x *Connecting[State]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Connecting[any])(nil)
	_ json.Marshaler   = (*Connecting[any])(nil)
)

func (r *Connecting[State]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONConnectingLb_State_bL(*r)
}
func (r *Connecting[State]) _marshalJSONConnectingLb_State_bL(x Connecting[State]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldAddr []byte
	fieldAddr, err = r._marshalJSONstring(x.Addr)
	if err != nil {
		return nil, fmt.Errorf("example: Connecting[State]._marshalJSONConnectingLb_State_bL: field name Addr; %w", err)
	}
	partial["Addr"] = fieldAddr
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("example: Connecting[State]._marshalJSONConnectingLb_State_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Connecting[State]) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("example: Connecting[State]._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Connecting[State]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONConnectingLb_State_bL(data)
	if err != nil {
		return fmt.Errorf("example: Connecting[State].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Connecting[State]) _unmarshalJSONConnectingLb_State_bL(data []byte) (Connecting[State], error) {
	result := Connecting[State]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("example: Connecting[State]._unmarshalJSONConnectingLb_State_bL: native struct unwrap; %w", err)
	}
	if fieldAddr, ok := partial["Addr"]; ok {
		result.Addr, err = r._unmarshalJSONstring(fieldAddr)
		if err != nil {
			return result, fmt.Errorf("example: Connecting[State]._unmarshalJSONConnectingLb_State_bL: field Addr; %w", err)
		}
	}
	return result, nil
}
func (r *Connecting[State]) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("example: Connecting[State]._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func ConnectedFromJSON[State any](x []byte) (*Connected[State], error) {
	result := new(Connected[State])
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("example.ConnectedFromJSON[State]: %w", err)
	}
	return result, nil
}

func ConnectedToJSON[State any](x *Connected[State]) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Connected[any])(nil)
	_ json.Marshaler   = (*Connected[any])(nil)
)

func (r *Connected[State]) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONConnectedLb_State_bL(*r)
}
func (r *Connected[State]) _marshalJSONConnectedLb_State_bL(x Connected[State]) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldConn []byte
	fieldConn, err = r._marshalJSONnet_Conn(x.Conn)
	if err != nil {
		return nil, fmt.Errorf("example: Connected[State]._marshalJSONConnectedLb_State_bL: field name Conn; %w", err)
	}
	partial["Conn"] = fieldConn
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("example: Connected[State]._marshalJSONConnectedLb_State_bL: struct; %w", err)
	}
	return result, nil
}
func (r *Connected[State]) _marshalJSONnet_Conn(x net.Conn) ([]byte, error) {
	result, err := shared.JSONMarshal[net.Conn](x)
	if err != nil {
		return nil, fmt.Errorf("example: Connected[State]._marshalJSONnet_Conn:; %w", err)
	}
	return result, nil
}
func (r *Connected[State]) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONConnectedLb_State_bL(data)
	if err != nil {
		return fmt.Errorf("example: Connected[State].UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Connected[State]) _unmarshalJSONConnectedLb_State_bL(data []byte) (Connected[State], error) {
	result := Connected[State]{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("example: Connected[State]._unmarshalJSONConnectedLb_State_bL: native struct unwrap; %w", err)
	}
	if fieldConn, ok := partial["Conn"]; ok {
		result.Conn, err = r._unmarshalJSONnet_Conn(fieldConn)
		if err != nil {
			return result, fmt.Errorf("example: Connected[State]._unmarshalJSONConnectedLb_State_bL: field Conn; %w", err)
		}
	}
	return result, nil
}
func (r *Connected[State]) _unmarshalJSONnet_Conn(data []byte) (net.Conn, error) {
	result, err := shared.JSONUnmarshal[net.Conn](data)
	if err != nil {
		return result, fmt.Errorf("example: Connected[State]._unmarshalJSONnet_Conn: native ref unwrap; %w", err)
	}
	return result, nil
}
