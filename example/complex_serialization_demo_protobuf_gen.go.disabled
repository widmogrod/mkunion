// Code generated by mkunion. DO NOT EDIT.
package example

import (
	"encoding/binary"
	"encoding/json"
	"fmt"
	"google.golang.org/protobuf/proto"
	"time"
)

var (
	// Temporarily disabled - protobuf integration needs adjustment
	// // _ proto.Message = (*.*)(nil)
)

func (r *APIError) Marshal() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return json.Marshal(r)
}

func (r *APIError) Unmarshal(data []byte) error {
	if len(data) == 0 {
		return nil
	}
	return json.Unmarshal(data, r)
}

var (
	// _ proto.Message = (*.*)(nil)
)

func (r *ComplexOperation) Marshal() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return json.Marshal(r)
}

func (r *ComplexOperation) Unmarshal(data []byte) error {
	if len(data) == 0 {
		return nil
	}
	return json.Unmarshal(data, r)
}

var (
	// _ proto.Message = (*.*)(nil)
)

func (r *RequestLog) Marshal() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return json.Marshal(r)
}

func (r *RequestLog) Unmarshal(data []byte) error {
	if len(data) == 0 {
		return nil
	}
	return json.Unmarshal(data, r)
}

var (
	// _ proto.Message = (*.*)(nil)
)

func (r *SearchResponse) Marshal() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return json.Marshal(r)
}

func (r *SearchResponse) Unmarshal(data []byte) error {
	if len(data) == 0 {
		return nil
	}
	return json.Unmarshal(data, r)
}

var (
	// _ proto.Message = (*.*)(nil)
)

func (r *User) Marshal() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return json.Marshal(r)
}

func (r *User) Unmarshal(data []byte) error {
	if len(data) == 0 {
		return nil
	}
	return json.Unmarshal(data, r)
}

// Experimental Protobuf support - basic implementation

type FetchResultProtoType int32

const (
	FetchResultProtoType_UNKNOWN      FetchResultProtoType = 0
	FetchResultProtoType_FETCHSUCCESS FetchResultProtoType = 1
	FetchResultProtoType_FETCHERROR   FetchResultProtoType = 2
)

type FetchResultProtoMessage struct {
	Type         FetchResultProtoType `protobuf:"varint,1,opt,name=type,proto3,enum=FetchResultProtoType" json:"type,omitempty"`
	FetchSuccess []byte               `protobuf:"bytes,2,opt,name=fetchsuccess,proto3" json:"fetchsuccess,omitempty"`
	FetchError   []byte               `protobuf:"bytes,3,opt,name=fetcherror,proto3" json:"fetcherror,omitempty"`
}

func FetchResultFromProtobuf(data []byte) (FetchResult, error) {
	if len(data) == 0 {
		return nil, nil
	}
	var msg FetchResultProtoMessage
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, fmt.Errorf("example.FetchResultFromProtobuf: %w", err)
	}

	switch msg.Type {
	case FetchResultProtoType_FETCHSUCCESS:
		var result FetchSuccess
		err := proto.Unmarshal(msg.FetchSuccess, &result)
		if err != nil {
			return nil, fmt.Errorf("example.FetchResultFromProtobuf: variant 0; %w", err)
		}
		return &result, nil
	case FetchResultProtoType_FETCHERROR:
		var result FetchError
		err := proto.Unmarshal(msg.FetchError, &result)
		if err != nil {
			return nil, fmt.Errorf("example.FetchResultFromProtobuf: variant 1; %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("example.FetchResultFromProtobuf: unknown type: %d", msg.Type)
	}
}

func FetchResultToProtobuf(x FetchResult) ([]byte, error) {
	if x == nil {
		return nil, nil
	}

	return MatchFetchResultR2(
		x,
		func(y *FetchSuccess) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.FetchResultToProtobuf: variant 0; %w", err)
			}
			msg := &FetchResultProtoMessage{
				Type:         FetchResultProtoType_FETCHSUCCESS,
				FetchSuccess: data,
			}
			return proto.Marshal(msg)
		},
		func(y *FetchError) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.FetchResultToProtobuf: variant 1; %w", err)
			}
			msg := &FetchResultProtoMessage{
				Type:       FetchResultProtoType_FETCHERROR,
				FetchError: data,
			}
			return proto.Marshal(msg)
		},
	)
}

// Experimental Protobuf support - basic implementation

type NestedResultProtoType int32

const (
	NestedResultProtoType_UNKNOWN       NestedResultProtoType = 0
	NestedResultProtoType_NESTEDSUCCESS NestedResultProtoType = 1
	NestedResultProtoType_NESTEDFAILURE NestedResultProtoType = 2
)

type NestedResultProtoMessage struct {
	Type          NestedResultProtoType `protobuf:"varint,1,opt,name=type,proto3,enum=NestedResultProtoType" json:"type,omitempty"`
	NestedSuccess []byte                `protobuf:"bytes,2,opt,name=nestedsuccess,proto3" json:"nestedsuccess,omitempty"`
	NestedFailure []byte                `protobuf:"bytes,3,opt,name=nestedfailure,proto3" json:"nestedfailure,omitempty"`
}

func NestedResultFromProtobuf(data []byte) (NestedResult, error) {
	if len(data) == 0 {
		return nil, nil
	}
	var msg NestedResultProtoMessage
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, fmt.Errorf("example.NestedResultFromProtobuf: %w", err)
	}

	switch msg.Type {
	case NestedResultProtoType_NESTEDSUCCESS:
		var result NestedSuccess
		err := proto.Unmarshal(msg.NestedSuccess, &result)
		if err != nil {
			return nil, fmt.Errorf("example.NestedResultFromProtobuf: variant 0; %w", err)
		}
		return &result, nil
	case NestedResultProtoType_NESTEDFAILURE:
		var result NestedFailure
		err := proto.Unmarshal(msg.NestedFailure, &result)
		if err != nil {
			return nil, fmt.Errorf("example.NestedResultFromProtobuf: variant 1; %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("example.NestedResultFromProtobuf: unknown type: %d", msg.Type)
	}
}

func NestedResultToProtobuf(x NestedResult) ([]byte, error) {
	if x == nil {
		return nil, nil
	}

	return MatchNestedResultR2(
		x,
		func(y *NestedSuccess) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.NestedResultToProtobuf: variant 0; %w", err)
			}
			msg := &NestedResultProtoMessage{
				Type:          NestedResultProtoType_NESTEDSUCCESS,
				NestedSuccess: data,
			}
			return proto.Marshal(msg)
		},
		func(y *NestedFailure) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.NestedResultToProtobuf: variant 1; %w", err)
			}
			msg := &NestedResultProtoMessage{
				Type:          NestedResultProtoType_NESTEDFAILURE,
				NestedFailure: data,
			}
			return proto.Marshal(msg)
		},
	)
}

// Experimental Protobuf support - basic implementation

type OptionUserProtoType int32

const (
	OptionUserProtoType_UNKNOWN  OptionUserProtoType = 0
	OptionUserProtoType_SOMEUSER OptionUserProtoType = 1
	OptionUserProtoType_NONEUSER OptionUserProtoType = 2
)

type OptionUserProtoMessage struct {
	Type     OptionUserProtoType `protobuf:"varint,1,opt,name=type,proto3,enum=OptionUserProtoType" json:"type,omitempty"`
	SomeUser []byte              `protobuf:"bytes,2,opt,name=someuser,proto3" json:"someuser,omitempty"`
	NoneUser []byte              `protobuf:"bytes,3,opt,name=noneuser,proto3" json:"noneuser,omitempty"`
}

func OptionUserFromProtobuf(data []byte) (OptionUser, error) {
	if len(data) == 0 {
		return nil, nil
	}
	var msg OptionUserProtoMessage
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, fmt.Errorf("example.OptionUserFromProtobuf: %w", err)
	}

	switch msg.Type {
	case OptionUserProtoType_SOMEUSER:
		var result SomeUser
		err := proto.Unmarshal(msg.SomeUser, &result)
		if err != nil {
			return nil, fmt.Errorf("example.OptionUserFromProtobuf: variant 0; %w", err)
		}
		return &result, nil
	case OptionUserProtoType_NONEUSER:
		var result NoneUser
		err := proto.Unmarshal(msg.NoneUser, &result)
		if err != nil {
			return nil, fmt.Errorf("example.OptionUserFromProtobuf: variant 1; %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("example.OptionUserFromProtobuf: unknown type: %d", msg.Type)
	}
}

func OptionUserToProtobuf(x OptionUser) ([]byte, error) {
	if x == nil {
		return nil, nil
	}

	return MatchOptionUserR2(
		x,
		func(y *SomeUser) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.OptionUserToProtobuf: variant 0; %w", err)
			}
			msg := &OptionUserProtoMessage{
				Type:     OptionUserProtoType_SOMEUSER,
				SomeUser: data,
			}
			return proto.Marshal(msg)
		},
		func(y *NoneUser) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.OptionUserToProtobuf: variant 1; %w", err)
			}
			msg := &OptionUserProtoMessage{
				Type:     OptionUserProtoType_NONEUSER,
				NoneUser: data,
			}
			return proto.Marshal(msg)
		},
	)
}

// Experimental Protobuf support - basic implementation

type PagedUserResultProtoType int32

const (
	PagedUserResultProtoType_UNKNOWN          PagedUserResultProtoType = 0
	PagedUserResultProtoType_PAGEDUSERSUCCESS PagedUserResultProtoType = 1
	PagedUserResultProtoType_PAGEDUSERERROR   PagedUserResultProtoType = 2
)

type PagedUserResultProtoMessage struct {
	Type             PagedUserResultProtoType `protobuf:"varint,1,opt,name=type,proto3,enum=PagedUserResultProtoType" json:"type,omitempty"`
	PagedUserSuccess []byte                   `protobuf:"bytes,2,opt,name=pagedusersuccess,proto3" json:"pagedusersuccess,omitempty"`
	PagedUserError   []byte                   `protobuf:"bytes,3,opt,name=pagedusererror,proto3" json:"pagedusererror,omitempty"`
}

func PagedUserResultFromProtobuf(data []byte) (PagedUserResult, error) {
	if len(data) == 0 {
		return nil, nil
	}
	var msg PagedUserResultProtoMessage
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, fmt.Errorf("example.PagedUserResultFromProtobuf: %w", err)
	}

	switch msg.Type {
	case PagedUserResultProtoType_PAGEDUSERSUCCESS:
		var result PagedUserSuccess
		err := proto.Unmarshal(msg.PagedUserSuccess, &result)
		if err != nil {
			return nil, fmt.Errorf("example.PagedUserResultFromProtobuf: variant 0; %w", err)
		}
		return &result, nil
	case PagedUserResultProtoType_PAGEDUSERERROR:
		var result PagedUserError
		err := proto.Unmarshal(msg.PagedUserError, &result)
		if err != nil {
			return nil, fmt.Errorf("example.PagedUserResultFromProtobuf: variant 1; %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("example.PagedUserResultFromProtobuf: unknown type: %d", msg.Type)
	}
}

func PagedUserResultToProtobuf(x PagedUserResult) ([]byte, error) {
	if x == nil {
		return nil, nil
	}

	return MatchPagedUserResultR2(
		x,
		func(y *PagedUserSuccess) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.PagedUserResultToProtobuf: variant 0; %w", err)
			}
			msg := &PagedUserResultProtoMessage{
				Type:             PagedUserResultProtoType_PAGEDUSERSUCCESS,
				PagedUserSuccess: data,
			}
			return proto.Marshal(msg)
		},
		func(y *PagedUserError) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.PagedUserResultToProtobuf: variant 1; %w", err)
			}
			msg := &PagedUserResultProtoMessage{
				Type:           PagedUserResultProtoType_PAGEDUSERERROR,
				PagedUserError: data,
			}
			return proto.Marshal(msg)
		},
	)
}

// Experimental Protobuf support - basic implementation

type UserSearchResultProtoType int32

const (
	UserSearchResultProtoType_UNKNOWN       UserSearchResultProtoType = 0
	UserSearchResultProtoType_SEARCHSUCCESS UserSearchResultProtoType = 1
	UserSearchResultProtoType_SEARCHERROR   UserSearchResultProtoType = 2
)

type UserSearchResultProtoMessage struct {
	Type          UserSearchResultProtoType `protobuf:"varint,1,opt,name=type,proto3,enum=UserSearchResultProtoType" json:"type,omitempty"`
	SearchSuccess []byte                    `protobuf:"bytes,2,opt,name=searchsuccess,proto3" json:"searchsuccess,omitempty"`
	SearchError   []byte                    `protobuf:"bytes,3,opt,name=searcherror,proto3" json:"searcherror,omitempty"`
}

func UserSearchResultFromProtobuf(data []byte) (UserSearchResult, error) {
	if len(data) == 0 {
		return nil, nil
	}
	var msg UserSearchResultProtoMessage
	err := proto.Unmarshal(data, &msg)
	if err != nil {
		return nil, fmt.Errorf("example.UserSearchResultFromProtobuf: %w", err)
	}

	switch msg.Type {
	case UserSearchResultProtoType_SEARCHSUCCESS:
		var result SearchSuccess
		err := proto.Unmarshal(msg.SearchSuccess, &result)
		if err != nil {
			return nil, fmt.Errorf("example.UserSearchResultFromProtobuf: variant 0; %w", err)
		}
		return &result, nil
	case UserSearchResultProtoType_SEARCHERROR:
		var result SearchError
		err := proto.Unmarshal(msg.SearchError, &result)
		if err != nil {
			return nil, fmt.Errorf("example.UserSearchResultFromProtobuf: variant 1; %w", err)
		}
		return &result, nil
	default:
		return nil, fmt.Errorf("example.UserSearchResultFromProtobuf: unknown type: %d", msg.Type)
	}
}

func UserSearchResultToProtobuf(x UserSearchResult) ([]byte, error) {
	if x == nil {
		return nil, nil
	}

	return MatchUserSearchResultR2(
		x,
		func(y *SearchSuccess) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.UserSearchResultToProtobuf: variant 0; %w", err)
			}
			msg := &UserSearchResultProtoMessage{
				Type:          UserSearchResultProtoType_SEARCHSUCCESS,
				SearchSuccess: data,
			}
			return proto.Marshal(msg)
		},
		func(y *SearchError) ([]byte, error) {
			data, err := proto.Marshal(y)
			if err != nil {
				return nil, fmt.Errorf("example.UserSearchResultToProtobuf: variant 1; %w", err)
			}
			msg := &UserSearchResultProtoMessage{
				Type:        UserSearchResultProtoType_SEARCHERROR,
				SearchError: data,
			}
			return proto.Marshal(msg)
		},
	)
}
