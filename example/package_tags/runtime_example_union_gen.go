// Code generated by mkunion. DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type TaskStatusVisitor interface {
	VisitPending(v *Pending) any
	VisitRunning(v *Running) any
	VisitCompleted(v *Completed) any
	VisitFailed(v *Failed) any
}

type TaskStatus interface {
	AcceptTaskStatus(g TaskStatusVisitor) any
}

var (
	_ TaskStatus = (*Pending)(nil)
	_ TaskStatus = (*Running)(nil)
	_ TaskStatus = (*Completed)(nil)
	_ TaskStatus = (*Failed)(nil)
)

func (r *Pending) AcceptTaskStatus(v TaskStatusVisitor) any   { return v.VisitPending(r) }
func (r *Running) AcceptTaskStatus(v TaskStatusVisitor) any   { return v.VisitRunning(r) }
func (r *Completed) AcceptTaskStatus(v TaskStatusVisitor) any { return v.VisitCompleted(r) }
func (r *Failed) AcceptTaskStatus(v TaskStatusVisitor) any    { return v.VisitFailed(r) }

func MatchTaskStatusR3[T0, T1, T2 any](
	x TaskStatus,
	f1 func(x *Pending) (T0, T1, T2),
	f2 func(x *Running) (T0, T1, T2),
	f3 func(x *Completed) (T0, T1, T2),
	f4 func(x *Failed) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Pending:
		return f1(v)
	case *Running:
		return f2(v)
	case *Completed:
		return f3(v)
	case *Failed:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchTaskStatusR2[T0, T1 any](
	x TaskStatus,
	f1 func(x *Pending) (T0, T1),
	f2 func(x *Running) (T0, T1),
	f3 func(x *Completed) (T0, T1),
	f4 func(x *Failed) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Pending:
		return f1(v)
	case *Running:
		return f2(v)
	case *Completed:
		return f3(v)
	case *Failed:
		return f4(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchTaskStatusR1[T0 any](
	x TaskStatus,
	f1 func(x *Pending) T0,
	f2 func(x *Running) T0,
	f3 func(x *Completed) T0,
	f4 func(x *Failed) T0,
) T0 {
	switch v := x.(type) {
	case *Pending:
		return f1(v)
	case *Running:
		return f2(v)
	case *Completed:
		return f3(v)
	case *Failed:
		return f4(v)
	}
	var result1 T0
	return result1
}

func MatchTaskStatusR0(
	x TaskStatus,
	f1 func(x *Pending),
	f2 func(x *Running),
	f3 func(x *Completed),
	f4 func(x *Failed),
) {
	switch v := x.(type) {
	case *Pending:
		f1(v)
	case *Running:
		f2(v)
	case *Completed:
		f3(v)
	case *Failed:
		f4(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.Completed", CompletedFromJSON, CompletedToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.Failed", FailedFromJSON, FailedToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.Pending", PendingFromJSON, PendingToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.Running", RunningFromJSON, RunningToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.TaskStatus", TaskStatusFromJSON, TaskStatusToJSON)
}

type TaskStatusUnionJSON struct {
	Type      string          `json:"$type,omitempty"`
	Pending   json.RawMessage `json:"main.Pending,omitempty"`
	Running   json.RawMessage `json:"main.Running,omitempty"`
	Completed json.RawMessage `json:"main.Completed,omitempty"`
	Failed    json.RawMessage `json:"main.Failed,omitempty"`
}

func TaskStatusFromJSON(x []byte) (TaskStatus, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data TaskStatusUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("main.TaskStatusFromJSON: %w", err)
	}

	switch data.Type {
	case "main.Pending":
		return PendingFromJSON(data.Pending)
	case "main.Running":
		return RunningFromJSON(data.Running)
	case "main.Completed":
		return CompletedFromJSON(data.Completed)
	case "main.Failed":
		return FailedFromJSON(data.Failed)
	}

	if data.Pending != nil {
		return PendingFromJSON(data.Pending)
	} else if data.Running != nil {
		return RunningFromJSON(data.Running)
	} else if data.Completed != nil {
		return CompletedFromJSON(data.Completed)
	} else if data.Failed != nil {
		return FailedFromJSON(data.Failed)
	}
	return nil, fmt.Errorf("main.TaskStatusFromJSON: unknown type: %s", data.Type)
}

func TaskStatusToJSON(x TaskStatus) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchTaskStatusR2(
		x,
		func(y *Pending) ([]byte, error) {
			body, err := PendingToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.TaskStatusToJSON: %w", err)
			}
			return json.Marshal(TaskStatusUnionJSON{
				Type:    "main.Pending",
				Pending: body,
			})
		},
		func(y *Running) ([]byte, error) {
			body, err := RunningToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.TaskStatusToJSON: %w", err)
			}
			return json.Marshal(TaskStatusUnionJSON{
				Type:    "main.Running",
				Running: body,
			})
		},
		func(y *Completed) ([]byte, error) {
			body, err := CompletedToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.TaskStatusToJSON: %w", err)
			}
			return json.Marshal(TaskStatusUnionJSON{
				Type:      "main.Completed",
				Completed: body,
			})
		},
		func(y *Failed) ([]byte, error) {
			body, err := FailedToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.TaskStatusToJSON: %w", err)
			}
			return json.Marshal(TaskStatusUnionJSON{
				Type:   "main.Failed",
				Failed: body,
			})
		},
	)
}

func PendingFromJSON(x []byte) (*Pending, error) {
	result := new(Pending)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.PendingFromJSON: %w", err)
	}
	return result, nil
}

func PendingToJSON(x *Pending) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Pending)(nil)
	_ json.Marshaler   = (*Pending)(nil)
)

func (r *Pending) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONPending(*r)
}
func (r *Pending) _marshalJSONPending(x Pending) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("main: Pending._marshalJSONPending: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: Pending._marshalJSONPending: struct; %w", err)
	}
	return result, nil
}
func (r *Pending) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Pending._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Pending) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONPending(data)
	if err != nil {
		return fmt.Errorf("main: Pending.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Pending) _unmarshalJSONPending(data []byte) (Pending, error) {
	result := Pending{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: Pending._unmarshalJSONPending: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("main: Pending._unmarshalJSONPending: field ID; %w", err)
		}
	}
	return result, nil
}
func (r *Pending) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Pending._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func RunningFromJSON(x []byte) (*Running, error) {
	result := new(Running)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.RunningFromJSON: %w", err)
	}
	return result, nil
}

func RunningToJSON(x *Running) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Running)(nil)
	_ json.Marshaler   = (*Running)(nil)
)

func (r *Running) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONRunning(*r)
}
func (r *Running) _marshalJSONRunning(x Running) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("main: Running._marshalJSONRunning: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldProgress []byte
	fieldProgress, err = r._marshalJSONfloat64(x.Progress)
	if err != nil {
		return nil, fmt.Errorf("main: Running._marshalJSONRunning: field name Progress; %w", err)
	}
	partial["Progress"] = fieldProgress
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: Running._marshalJSONRunning: struct; %w", err)
	}
	return result, nil
}
func (r *Running) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Running._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Running) _marshalJSONfloat64(x float64) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Running._marshalJSONfloat64:; %w", err)
	}
	return result, nil
}
func (r *Running) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONRunning(data)
	if err != nil {
		return fmt.Errorf("main: Running.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Running) _unmarshalJSONRunning(data []byte) (Running, error) {
	result := Running{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: Running._unmarshalJSONRunning: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("main: Running._unmarshalJSONRunning: field ID; %w", err)
		}
	}
	if fieldProgress, ok := partial["Progress"]; ok {
		result.Progress, err = r._unmarshalJSONfloat64(fieldProgress)
		if err != nil {
			return result, fmt.Errorf("main: Running._unmarshalJSONRunning: field Progress; %w", err)
		}
	}
	return result, nil
}
func (r *Running) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Running._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Running) _unmarshalJSONfloat64(data []byte) (float64, error) {
	var result float64
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Running._unmarshalJSONfloat64: native primitive unwrap; %w", err)
	}
	return result, nil
}

func CompletedFromJSON(x []byte) (*Completed, error) {
	result := new(Completed)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.CompletedFromJSON: %w", err)
	}
	return result, nil
}

func CompletedToJSON(x *Completed) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Completed)(nil)
	_ json.Marshaler   = (*Completed)(nil)
)

func (r *Completed) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONCompleted(*r)
}
func (r *Completed) _marshalJSONCompleted(x Completed) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("main: Completed._marshalJSONCompleted: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldResult []byte
	fieldResult, err = r._marshalJSONstring(x.Result)
	if err != nil {
		return nil, fmt.Errorf("main: Completed._marshalJSONCompleted: field name Result; %w", err)
	}
	partial["Result"] = fieldResult
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: Completed._marshalJSONCompleted: struct; %w", err)
	}
	return result, nil
}
func (r *Completed) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Completed._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Completed) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONCompleted(data)
	if err != nil {
		return fmt.Errorf("main: Completed.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Completed) _unmarshalJSONCompleted(data []byte) (Completed, error) {
	result := Completed{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: Completed._unmarshalJSONCompleted: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("main: Completed._unmarshalJSONCompleted: field ID; %w", err)
		}
	}
	if fieldResult, ok := partial["Result"]; ok {
		result.Result, err = r._unmarshalJSONstring(fieldResult)
		if err != nil {
			return result, fmt.Errorf("main: Completed._unmarshalJSONCompleted: field Result; %w", err)
		}
	}
	return result, nil
}
func (r *Completed) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Completed._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func FailedFromJSON(x []byte) (*Failed, error) {
	result := new(Failed)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.FailedFromJSON: %w", err)
	}
	return result, nil
}

func FailedToJSON(x *Failed) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Failed)(nil)
	_ json.Marshaler   = (*Failed)(nil)
)

func (r *Failed) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONFailed(*r)
}
func (r *Failed) _marshalJSONFailed(x Failed) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldID []byte
	fieldID, err = r._marshalJSONstring(x.ID)
	if err != nil {
		return nil, fmt.Errorf("main: Failed._marshalJSONFailed: field name ID; %w", err)
	}
	partial["ID"] = fieldID
	var fieldError []byte
	fieldError, err = r._marshalJSONstring(x.Error)
	if err != nil {
		return nil, fmt.Errorf("main: Failed._marshalJSONFailed: field name Error; %w", err)
	}
	partial["Error"] = fieldError
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: Failed._marshalJSONFailed: struct; %w", err)
	}
	return result, nil
}
func (r *Failed) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Failed._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Failed) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONFailed(data)
	if err != nil {
		return fmt.Errorf("main: Failed.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Failed) _unmarshalJSONFailed(data []byte) (Failed, error) {
	result := Failed{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: Failed._unmarshalJSONFailed: native struct unwrap; %w", err)
	}
	if fieldID, ok := partial["ID"]; ok {
		result.ID, err = r._unmarshalJSONstring(fieldID)
		if err != nil {
			return result, fmt.Errorf("main: Failed._unmarshalJSONFailed: field ID; %w", err)
		}
	}
	if fieldError, ok := partial["Error"]; ok {
		result.Error, err = r._unmarshalJSONstring(fieldError)
		if err != nil {
			return result, fmt.Errorf("main: Failed._unmarshalJSONFailed: field Error; %w", err)
		}
	}
	return result, nil
}
func (r *Failed) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Failed._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
