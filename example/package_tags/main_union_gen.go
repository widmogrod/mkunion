// Code generated by mkunion. DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type StatusVisitor interface {
	VisitSuccess(v *Success) any
	VisitError(v *Error) any
}

type Status interface {
	AcceptStatus(g StatusVisitor) any
}

var (
	_ Status = (*Success)(nil)
	_ Status = (*Error)(nil)
)

func (r *Success) AcceptStatus(v StatusVisitor) any { return v.VisitSuccess(r) }
func (r *Error) AcceptStatus(v StatusVisitor) any   { return v.VisitError(r) }

func MatchStatusR3[T0, T1, T2 any](
	x Status,
	f1 func(x *Success) (T0, T1, T2),
	f2 func(x *Error) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *Success:
		return f1(v)
	case *Error:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchStatusR2[T0, T1 any](
	x Status,
	f1 func(x *Success) (T0, T1),
	f2 func(x *Error) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *Success:
		return f1(v)
	case *Error:
		return f2(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchStatusR1[T0 any](
	x Status,
	f1 func(x *Success) T0,
	f2 func(x *Error) T0,
) T0 {
	switch v := x.(type) {
	case *Success:
		return f1(v)
	case *Error:
		return f2(v)
	}
	var result1 T0
	return result1
}

func MatchStatusR0(
	x Status,
	f1 func(x *Success),
	f2 func(x *Error),
) {
	switch v := x.(type) {
	case *Success:
		f1(v)
	case *Error:
		f2(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.Error", ErrorFromJSON, ErrorToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.Status", StatusFromJSON, StatusToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/example/package_tags.Success", SuccessFromJSON, SuccessToJSON)
}

type StatusUnionJSON struct {
	Type    string          `json:"$type,omitempty"`
	Success json.RawMessage `json:"main.Success,omitempty"`
	Error   json.RawMessage `json:"main.Error,omitempty"`
}

func StatusFromJSON(x []byte) (Status, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data StatusUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("main.StatusFromJSON: %w", err)
	}

	switch data.Type {
	case "main.Success":
		return SuccessFromJSON(data.Success)
	case "main.Error":
		return ErrorFromJSON(data.Error)
	}

	if data.Success != nil {
		return SuccessFromJSON(data.Success)
	} else if data.Error != nil {
		return ErrorFromJSON(data.Error)
	}
	return nil, fmt.Errorf("main.StatusFromJSON: unknown type: %s", data.Type)
}

func StatusToJSON(x Status) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchStatusR2(
		x,
		func(y *Success) ([]byte, error) {
			body, err := SuccessToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.StatusToJSON: %w", err)
			}
			return json.Marshal(StatusUnionJSON{
				Type:    "main.Success",
				Success: body,
			})
		},
		func(y *Error) ([]byte, error) {
			body, err := ErrorToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.StatusToJSON: %w", err)
			}
			return json.Marshal(StatusUnionJSON{
				Type:  "main.Error",
				Error: body,
			})
		},
	)
}

func SuccessFromJSON(x []byte) (*Success, error) {
	result := new(Success)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.SuccessFromJSON: %w", err)
	}
	return result, nil
}

func SuccessToJSON(x *Success) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Success)(nil)
	_ json.Marshaler   = (*Success)(nil)
)

func (r *Success) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONSuccess(*r)
}
func (r *Success) _marshalJSONSuccess(x Success) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldMessage []byte
	fieldMessage, err = r._marshalJSONstring(x.Message)
	if err != nil {
		return nil, fmt.Errorf("main: Success._marshalJSONSuccess: field name Message; %w", err)
	}
	partial["Message"] = fieldMessage
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: Success._marshalJSONSuccess: struct; %w", err)
	}
	return result, nil
}
func (r *Success) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Success._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Success) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONSuccess(data)
	if err != nil {
		return fmt.Errorf("main: Success.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Success) _unmarshalJSONSuccess(data []byte) (Success, error) {
	result := Success{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: Success._unmarshalJSONSuccess: native struct unwrap; %w", err)
	}
	if fieldMessage, ok := partial["Message"]; ok {
		result.Message, err = r._unmarshalJSONstring(fieldMessage)
		if err != nil {
			return result, fmt.Errorf("main: Success._unmarshalJSONSuccess: field Message; %w", err)
		}
	}
	return result, nil
}
func (r *Success) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Success._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func ErrorFromJSON(x []byte) (*Error, error) {
	result := new(Error)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.ErrorFromJSON: %w", err)
	}
	return result, nil
}

func ErrorToJSON(x *Error) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*Error)(nil)
	_ json.Marshaler   = (*Error)(nil)
)

func (r *Error) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONError(*r)
}
func (r *Error) _marshalJSONError(x Error) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldCode []byte
	fieldCode, err = r._marshalJSONint(x.Code)
	if err != nil {
		return nil, fmt.Errorf("main: Error._marshalJSONError: field name Code; %w", err)
	}
	partial["Code"] = fieldCode
	var fieldMessage []byte
	fieldMessage, err = r._marshalJSONstring(x.Message)
	if err != nil {
		return nil, fmt.Errorf("main: Error._marshalJSONError: field name Message; %w", err)
	}
	partial["Message"] = fieldMessage
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: Error._marshalJSONError: struct; %w", err)
	}
	return result, nil
}
func (r *Error) _marshalJSONint(x int) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Error._marshalJSONint:; %w", err)
	}
	return result, nil
}
func (r *Error) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: Error._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *Error) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONError(data)
	if err != nil {
		return fmt.Errorf("main: Error.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *Error) _unmarshalJSONError(data []byte) (Error, error) {
	result := Error{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: Error._unmarshalJSONError: native struct unwrap; %w", err)
	}
	if fieldCode, ok := partial["Code"]; ok {
		result.Code, err = r._unmarshalJSONint(fieldCode)
		if err != nil {
			return result, fmt.Errorf("main: Error._unmarshalJSONError: field Code; %w", err)
		}
	}
	if fieldMessage, ok := partial["Message"]; ok {
		result.Message, err = r._unmarshalJSONstring(fieldMessage)
		if err != nil {
			return result, fmt.Errorf("main: Error._unmarshalJSONError: field Message; %w", err)
		}
	}
	return result, nil
}
func (r *Error) _unmarshalJSONint(data []byte) (int, error) {
	var result int
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Error._unmarshalJSONint: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *Error) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: Error._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
