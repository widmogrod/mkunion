// Code generated by mkunion. DO NOT EDIT.
package main

import (
	"encoding/json"
	"fmt"
	"github.com/sashabaranov/go-openai"
	"github.com/widmogrod/mkunion/x/shared"
)

type ChatCMDVisitor interface {
	VisitUserMessage(v *UserMessage) any
}

type ChatCMD interface {
	AcceptChatCMD(g ChatCMDVisitor) any
}

var (
	_ ChatCMD = (*UserMessage)(nil)
)

func (r *UserMessage) AcceptChatCMD(v ChatCMDVisitor) any { return v.VisitUserMessage(r) }

func MatchChatCMDR3[T0, T1, T2 any](
	x ChatCMD,
	f1 func(x *UserMessage) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *UserMessage:
		return f1(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchChatCMDR2[T0, T1 any](
	x ChatCMD,
	f1 func(x *UserMessage) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *UserMessage:
		return f1(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchChatCMDR1[T0 any](
	x ChatCMD,
	f1 func(x *UserMessage) T0,
) T0 {
	switch v := x.(type) {
	case *UserMessage:
		return f1(v)
	}
	var result1 T0
	return result1
}

func MatchChatCMDR0(
	x ChatCMD,
	f1 func(x *UserMessage),
) {
	switch v := x.(type) {
	case *UserMessage:
		f1(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/exammple/my-app.ChatCMD", ChatCMDFromJSON, ChatCMDToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/exammple/my-app.UserMessage", UserMessageFromJSON, UserMessageToJSON)
}

type ChatCMDUnionJSON struct {
	Type string `json:"$type,omitempty"`
	UserMessage json.RawMessage `json:"main.UserMessage,omitempty"`
}

func ChatCMDFromJSON(x []byte) (ChatCMD, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data ChatCMDUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("main.ChatCMDFromJSON: %w", err)
	}

	switch data.Type {
	case "main.UserMessage":
		return UserMessageFromJSON(data.UserMessage)
	}

	if data.UserMessage != nil {
		return UserMessageFromJSON(data.UserMessage)
	}
	return nil, fmt.Errorf("main.ChatCMDFromJSON: unknown type: %s", data.Type)
}

func ChatCMDToJSON(x ChatCMD) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchChatCMDR2(
		x,
		func (y *UserMessage) ([]byte, error) {
			body, err := UserMessageToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.ChatCMDToJSON: %w", err)
			}
			return json.Marshal(ChatCMDUnionJSON{
				Type: "main.UserMessage",
				UserMessage: body,
			})
		},
	)
}

func UserMessageFromJSON(x []byte) (*UserMessage, error) {
	result := new(UserMessage)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.UserMessageFromJSON: %w", err)
	}
	return result, nil
}

func UserMessageToJSON(x *UserMessage) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*UserMessage)(nil)
	_ json.Marshaler   = (*UserMessage)(nil)
)

func (r *UserMessage) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONUserMessage(*r)
}
func (r *UserMessage) _marshalJSONUserMessage(x UserMessage) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldMessage []byte
	fieldMessage, err = r._marshalJSONstring(x.Message)
	if err != nil {
		return nil, fmt.Errorf("main: UserMessage._marshalJSONUserMessage: field name Message; %w", err)
	}
	partial["Message"] = fieldMessage
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: UserMessage._marshalJSONUserMessage: struct; %w", err)
	}
	return result, nil
}
func (r *UserMessage) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: UserMessage._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *UserMessage) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONUserMessage(data)
	if err != nil {
		return fmt.Errorf("main: UserMessage.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *UserMessage) _unmarshalJSONUserMessage(data []byte) (UserMessage, error) {
	result := UserMessage{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: UserMessage._unmarshalJSONUserMessage: native struct unwrap; %w", err)
	}
	if fieldMessage, ok := partial["Message"]; ok {
		result.Message, err = r._unmarshalJSONstring(fieldMessage)
		if err != nil {
			return result, fmt.Errorf("main: UserMessage._unmarshalJSONUserMessage: field Message; %w", err)
		}
	}
	return result, nil
}
func (r *UserMessage) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: UserMessage._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

type ChatResultVisitor interface {
	VisitSystemResponse(v *SystemResponse) any
	VisitUserResponse(v *UserResponse) any
	VisitChatResponses(v *ChatResponses) any
}

type ChatResult interface {
	AcceptChatResult(g ChatResultVisitor) any
}

var (
	_ ChatResult = (*SystemResponse)(nil)
	_ ChatResult = (*UserResponse)(nil)
	_ ChatResult = (*ChatResponses)(nil)
)

func (r *SystemResponse) AcceptChatResult(v ChatResultVisitor) any { return v.VisitSystemResponse(r) }
func (r *UserResponse) AcceptChatResult(v ChatResultVisitor) any { return v.VisitUserResponse(r) }
func (r *ChatResponses) AcceptChatResult(v ChatResultVisitor) any { return v.VisitChatResponses(r) }

func MatchChatResultR3[T0, T1, T2 any](
	x ChatResult,
	f1 func(x *SystemResponse) (T0, T1, T2),
	f2 func(x *UserResponse) (T0, T1, T2),
	f3 func(x *ChatResponses) (T0, T1, T2),
) (T0, T1, T2) {
	switch v := x.(type) {
	case *SystemResponse:
		return f1(v)
	case *UserResponse:
		return f2(v)
	case *ChatResponses:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	var result3 T2
	return result1, result2, result3
}

func MatchChatResultR2[T0, T1 any](
	x ChatResult,
	f1 func(x *SystemResponse) (T0, T1),
	f2 func(x *UserResponse) (T0, T1),
	f3 func(x *ChatResponses) (T0, T1),
) (T0, T1) {
	switch v := x.(type) {
	case *SystemResponse:
		return f1(v)
	case *UserResponse:
		return f2(v)
	case *ChatResponses:
		return f3(v)
	}
	var result1 T0
	var result2 T1
	return result1, result2
}

func MatchChatResultR1[T0 any](
	x ChatResult,
	f1 func(x *SystemResponse) T0,
	f2 func(x *UserResponse) T0,
	f3 func(x *ChatResponses) T0,
) T0 {
	switch v := x.(type) {
	case *SystemResponse:
		return f1(v)
	case *UserResponse:
		return f2(v)
	case *ChatResponses:
		return f3(v)
	}
	var result1 T0
	return result1
}

func MatchChatResultR0(
	x ChatResult,
	f1 func(x *SystemResponse),
	f2 func(x *UserResponse),
	f3 func(x *ChatResponses),
) {
	switch v := x.(type) {
	case *SystemResponse:
		f1(v)
	case *UserResponse:
		f2(v)
	case *ChatResponses:
		f3(v)
	}
}
func init() {
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/exammple/my-app.ChatResponses", ChatResponsesFromJSON, ChatResponsesToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/exammple/my-app.ChatResult", ChatResultFromJSON, ChatResultToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/exammple/my-app.SystemResponse", SystemResponseFromJSON, SystemResponseToJSON)
	shared.JSONMarshallerRegister("github.com/widmogrod/mkunion/exammple/my-app.UserResponse", UserResponseFromJSON, UserResponseToJSON)
}

type ChatResultUnionJSON struct {
	Type string `json:"$type,omitempty"`
	SystemResponse json.RawMessage `json:"main.SystemResponse,omitempty"`
	UserResponse json.RawMessage `json:"main.UserResponse,omitempty"`
	ChatResponses json.RawMessage `json:"main.ChatResponses,omitempty"`
}

func ChatResultFromJSON(x []byte) (ChatResult, error) {
	if x == nil || len(x) == 0 {
		return nil, nil
	}
	if string(x[:4]) == "null" {
		return nil, nil
	}
	var data ChatResultUnionJSON
	err := json.Unmarshal(x, &data)
	if err != nil {
		return nil, fmt.Errorf("main.ChatResultFromJSON: %w", err)
	}

	switch data.Type {
	case "main.SystemResponse":
		return SystemResponseFromJSON(data.SystemResponse)
	case "main.UserResponse":
		return UserResponseFromJSON(data.UserResponse)
	case "main.ChatResponses":
		return ChatResponsesFromJSON(data.ChatResponses)
	}

	if data.SystemResponse != nil {
		return SystemResponseFromJSON(data.SystemResponse)
	} else if data.UserResponse != nil {
		return UserResponseFromJSON(data.UserResponse)
	} else if data.ChatResponses != nil {
		return ChatResponsesFromJSON(data.ChatResponses)
	}
	return nil, fmt.Errorf("main.ChatResultFromJSON: unknown type: %s", data.Type)
}

func ChatResultToJSON(x ChatResult) ([]byte, error) {
	if x == nil {
		return []byte(`null`), nil
	}
	return MatchChatResultR2(
		x,
		func (y *SystemResponse) ([]byte, error) {
			body, err := SystemResponseToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.ChatResultToJSON: %w", err)
			}
			return json.Marshal(ChatResultUnionJSON{
				Type: "main.SystemResponse",
				SystemResponse: body,
			})
		},
		func (y *UserResponse) ([]byte, error) {
			body, err := UserResponseToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.ChatResultToJSON: %w", err)
			}
			return json.Marshal(ChatResultUnionJSON{
				Type: "main.UserResponse",
				UserResponse: body,
			})
		},
		func (y *ChatResponses) ([]byte, error) {
			body, err := ChatResponsesToJSON(y)
			if err != nil {
				return nil, fmt.Errorf("main.ChatResultToJSON: %w", err)
			}
			return json.Marshal(ChatResultUnionJSON{
				Type: "main.ChatResponses",
				ChatResponses: body,
			})
		},
	)
}

func SystemResponseFromJSON(x []byte) (*SystemResponse, error) {
	result := new(SystemResponse)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.SystemResponseFromJSON: %w", err)
	}
	return result, nil
}

func SystemResponseToJSON(x *SystemResponse) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*SystemResponse)(nil)
	_ json.Marshaler   = (*SystemResponse)(nil)
)

func (r *SystemResponse) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONSystemResponse(*r)
}
func (r *SystemResponse) _marshalJSONSystemResponse(x SystemResponse) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldMessage []byte
	fieldMessage, err = r._marshalJSONstring(x.Message)
	if err != nil {
		return nil, fmt.Errorf("main: SystemResponse._marshalJSONSystemResponse: field name Message; %w", err)
	}
	partial["Message"] = fieldMessage
	var fieldToolCalls []byte
	fieldToolCalls, err = r._marshalJSONSliceopenai_ToolCall(x.ToolCalls)
	if err != nil {
		return nil, fmt.Errorf("main: SystemResponse._marshalJSONSystemResponse: field name ToolCalls; %w", err)
	}
	partial["ToolCalls"] = fieldToolCalls
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: SystemResponse._marshalJSONSystemResponse: struct; %w", err)
	}
	return result, nil
}
func (r *SystemResponse) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: SystemResponse._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *SystemResponse) _marshalJSONSliceopenai_ToolCall(x []openai.ToolCall) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONopenai_ToolCall(v)
		if err != nil {
			return nil, fmt.Errorf("main: SystemResponse._marshalJSONSliceopenai_ToolCall: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: SystemResponse._marshalJSONSliceopenai_ToolCall:; %w", err)
	}
	return result, nil
}
func (r *SystemResponse) _marshalJSONopenai_ToolCall(x openai.ToolCall) ([]byte, error) {
	result, err := shared.JSONMarshal[openai.ToolCall](x)
	if err != nil {
		return nil, fmt.Errorf("main: SystemResponse._marshalJSONopenai_ToolCall:; %w", err)
	}
	return result, nil
}
func (r *SystemResponse) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONSystemResponse(data)
	if err != nil {
		return fmt.Errorf("main: SystemResponse.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *SystemResponse) _unmarshalJSONSystemResponse(data []byte) (SystemResponse, error) {
	result := SystemResponse{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: SystemResponse._unmarshalJSONSystemResponse: native struct unwrap; %w", err)
	}
	if fieldMessage, ok := partial["Message"]; ok {
		result.Message, err = r._unmarshalJSONstring(fieldMessage)
		if err != nil {
			return result, fmt.Errorf("main: SystemResponse._unmarshalJSONSystemResponse: field Message; %w", err)
		}
	}
	if fieldToolCalls, ok := partial["ToolCalls"]; ok {
		result.ToolCalls, err = r._unmarshalJSONSliceopenai_ToolCall(fieldToolCalls)
		if err != nil {
			return result, fmt.Errorf("main: SystemResponse._unmarshalJSONSystemResponse: field ToolCalls; %w", err)
		}
	}
	return result, nil
}
func (r *SystemResponse) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: SystemResponse._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}
func (r *SystemResponse) _unmarshalJSONSliceopenai_ToolCall(data []byte) ([]openai.ToolCall, error) {
	result := make([]openai.ToolCall, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: SystemResponse._unmarshalJSONSliceopenai_ToolCall: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONopenai_ToolCall(v)
		if err != nil {
			return result, fmt.Errorf("main: SystemResponse._unmarshalJSONSliceopenai_ToolCall: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *SystemResponse) _unmarshalJSONopenai_ToolCall(data []byte) (openai.ToolCall, error) {
	result, err := shared.JSONUnmarshal[openai.ToolCall](data)
	if err != nil {
		return result, fmt.Errorf("main: SystemResponse._unmarshalJSONopenai_ToolCall: native ref unwrap; %w", err)
	}
	return result, nil
}

func UserResponseFromJSON(x []byte) (*UserResponse, error) {
	result := new(UserResponse)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.UserResponseFromJSON: %w", err)
	}
	return result, nil
}

func UserResponseToJSON(x *UserResponse) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*UserResponse)(nil)
	_ json.Marshaler   = (*UserResponse)(nil)
)

func (r *UserResponse) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONUserResponse(*r)
}
func (r *UserResponse) _marshalJSONUserResponse(x UserResponse) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldMessage []byte
	fieldMessage, err = r._marshalJSONstring(x.Message)
	if err != nil {
		return nil, fmt.Errorf("main: UserResponse._marshalJSONUserResponse: field name Message; %w", err)
	}
	partial["Message"] = fieldMessage
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: UserResponse._marshalJSONUserResponse: struct; %w", err)
	}
	return result, nil
}
func (r *UserResponse) _marshalJSONstring(x string) ([]byte, error) {
	result, err := json.Marshal(x)
	if err != nil {
		return nil, fmt.Errorf("main: UserResponse._marshalJSONstring:; %w", err)
	}
	return result, nil
}
func (r *UserResponse) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONUserResponse(data)
	if err != nil {
		return fmt.Errorf("main: UserResponse.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *UserResponse) _unmarshalJSONUserResponse(data []byte) (UserResponse, error) {
	result := UserResponse{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: UserResponse._unmarshalJSONUserResponse: native struct unwrap; %w", err)
	}
	if fieldMessage, ok := partial["Message"]; ok {
		result.Message, err = r._unmarshalJSONstring(fieldMessage)
		if err != nil {
			return result, fmt.Errorf("main: UserResponse._unmarshalJSONUserResponse: field Message; %w", err)
		}
	}
	return result, nil
}
func (r *UserResponse) _unmarshalJSONstring(data []byte) (string, error) {
	var result string
	err := json.Unmarshal(data, &result)
	if err != nil {
		return result, fmt.Errorf("main: UserResponse._unmarshalJSONstring: native primitive unwrap; %w", err)
	}
	return result, nil
}

func ChatResponsesFromJSON(x []byte) (*ChatResponses, error) {
	result := new(ChatResponses)
	err := result.UnmarshalJSON(x)
	if err != nil {
		return nil, fmt.Errorf("main.ChatResponsesFromJSON: %w", err)
	}
	return result, nil
}

func ChatResponsesToJSON(x *ChatResponses) ([]byte, error) {
	return x.MarshalJSON()
}

var (
	_ json.Unmarshaler = (*ChatResponses)(nil)
	_ json.Marshaler   = (*ChatResponses)(nil)
)

func (r *ChatResponses) MarshalJSON() ([]byte, error) {
	if r == nil {
		return nil, nil
	}
	return r._marshalJSONChatResponses(*r)
}
func (r *ChatResponses) _marshalJSONChatResponses(x ChatResponses) ([]byte, error) {
	partial := make(map[string]json.RawMessage)
	var err error
	var fieldResponses []byte
	fieldResponses, err = r._marshalJSONSliceChatResult(x.Responses)
	if err != nil {
		return nil, fmt.Errorf("main: ChatResponses._marshalJSONChatResponses: field name Responses; %w", err)
	}
	partial["Responses"] = fieldResponses
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: ChatResponses._marshalJSONChatResponses: struct; %w", err)
	}
	return result, nil
}
func (r *ChatResponses) _marshalJSONSliceChatResult(x []ChatResult) ([]byte, error) {
	partial := make([]json.RawMessage, len(x))
	for i, v := range x {
		item, err := r._marshalJSONChatResult(v)
		if err != nil {
			return nil, fmt.Errorf("main: ChatResponses._marshalJSONSliceChatResult: at index %d; %w", i, err)
		}
		partial[i] = item
	}
	result, err := json.Marshal(partial)
	if err != nil {
		return nil, fmt.Errorf("main: ChatResponses._marshalJSONSliceChatResult:; %w", err)
	}
	return result, nil
}
func (r *ChatResponses) _marshalJSONChatResult(x ChatResult) ([]byte, error) {
	result, err := shared.JSONMarshal[ChatResult](x)
	if err != nil {
		return nil, fmt.Errorf("main: ChatResponses._marshalJSONChatResult:; %w", err)
	}
	return result, nil
}
func (r *ChatResponses) UnmarshalJSON(data []byte) error {
	result, err := r._unmarshalJSONChatResponses(data)
	if err != nil {
		return fmt.Errorf("main: ChatResponses.UnmarshalJSON: %w", err)
	}
	*r = result
	return nil
}
func (r *ChatResponses) _unmarshalJSONChatResponses(data []byte) (ChatResponses, error) {
	result := ChatResponses{}
	var partial map[string]json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: ChatResponses._unmarshalJSONChatResponses: native struct unwrap; %w", err)
	}
	if fieldResponses, ok := partial["Responses"]; ok {
		result.Responses, err = r._unmarshalJSONSliceChatResult(fieldResponses)
		if err != nil {
			return result, fmt.Errorf("main: ChatResponses._unmarshalJSONChatResponses: field Responses; %w", err)
		}
	}
	return result, nil
}
func (r *ChatResponses) _unmarshalJSONSliceChatResult(data []byte) ([]ChatResult, error) {
	result := make([]ChatResult, 0)
	var partial []json.RawMessage
	err := json.Unmarshal(data, &partial)
	if err != nil {
		return result, fmt.Errorf("main: ChatResponses._unmarshalJSONSliceChatResult: native list unwrap; %w", err)
	}
	for i, v := range partial {
		item, err := r._unmarshalJSONChatResult(v)
		if err != nil {
			return result, fmt.Errorf("main: ChatResponses._unmarshalJSONSliceChatResult: at index %d; %w", i, err)
		}
		result = append(result, item)
	}
	return result, nil
}
func (r *ChatResponses) _unmarshalJSONChatResult(data []byte) (ChatResult, error) {
	result, err := shared.JSONUnmarshal[ChatResult](data)
	if err != nil {
		return result, fmt.Errorf("main: ChatResponses._unmarshalJSONChatResult: native ref unwrap; %w", err)
	}
	return result, nil
}

