package main

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSaveFile_FormatsGeneratedGoCode(t *testing.T) {
	// Create a temporary directory for test files
	tempDir := t.TempDir()
	sourcePath := filepath.Join(tempDir, "test.go")

	// Test case 1: Unformatted Go code should be formatted
	t.Run("formats_unformatted_go_code", func(t *testing.T) {
		// Unformatted Go code
		unformattedCode := `package test

import "fmt"

func   main()  {
fmt.Println("Hello, World!")
		if   true   {
	fmt.Println("This is unformatted")
}
}`

		buffer := bytes.Buffer{}
		buffer.WriteString(unformattedCode)

		fileName, err := SaveFile(buffer, sourcePath, "formatted")
		require.NoError(t, err)
		require.NotEmpty(t, fileName)

		// Read the saved file
		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		// The saved content should be formatted
		expectedFormatted := `package test

import "fmt"

func main() {
	fmt.Println("Hello, World!")
	if true {
		fmt.Println("This is unformatted")
	}
}
`
		assert.Equal(t, expectedFormatted, string(content))
	})

	// Test case 2: Already formatted code should remain the same
	t.Run("preserves_already_formatted_code", func(t *testing.T) {
		formattedCode := `package test

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}
`

		buffer := bytes.Buffer{}
		buffer.WriteString(formattedCode)

		fileName, err := SaveFile(buffer, sourcePath, "already_formatted")
		require.NoError(t, err)

		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		assert.Equal(t, formattedCode, string(content))
	})

	// Test case 3: Invalid Go code should still be saved (graceful fallback)
	t.Run("saves_invalid_go_code_without_formatting", func(t *testing.T) {
		invalidCode := `package test

func main() {
	// Missing closing brace
`

		buffer := bytes.Buffer{}
		buffer.WriteString(invalidCode)

		fileName, err := SaveFile(buffer, sourcePath, "invalid")
		require.NoError(t, err)

		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		// Invalid code should be saved as-is
		assert.Equal(t, invalidCode, string(content))
	})

	// Test case 4: Empty buffer should not create a file
	t.Run("empty_buffer_returns_empty_filename", func(t *testing.T) {
		buffer := bytes.Buffer{}

		fileName, err := SaveFile(buffer, sourcePath, "empty")
		require.NoError(t, err)
		assert.Empty(t, fileName)

		// Verify no file was created
		expectedPath := strings.Replace(sourcePath, ".go", "_empty.go", 1)
		_, err = os.Stat(expectedPath)
		assert.True(t, os.IsNotExist(err))
	})

	// Test case 5: Complex generated code with imports
	t.Run("formats_complex_generated_code", func(t *testing.T) {
		complexCode := `// Code generated by mkunion. DO NOT EDIT.
package example

import (
"fmt"
	"github.com/widmogrod/mkunion/x/shared"
"context"
)

type   Vehicle   interface {
isVehicle()
}

type  Car  struct{
Brand  string
Model string
}

func  (c *Car)  isVehicle() {}

func   MatchVehicleR1[T any](x Vehicle,
f1   func(x *Car)   T,
)   T   {
switch v   :=  x.(type)  {
case   *Car:
return   f1(v)
default:
panic("unreachable")
}
}`

		buffer := bytes.Buffer{}
		buffer.WriteString(complexCode)

		fileName, err := SaveFile(buffer, sourcePath, "complex")
		require.NoError(t, err)

		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		// Should be properly formatted
		expectedFormatted := `// Code generated by mkunion. DO NOT EDIT.
package example

import (
	"context"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type Vehicle interface {
	isVehicle()
}

type Car struct {
	Brand string
	Model string
}

func (c *Car) isVehicle() {}

func MatchVehicleR1[T any](x Vehicle,
	f1 func(x *Car) T,
) T {
	switch v := x.(type) {
	case *Car:
		return f1(v)
	default:
		panic("unreachable")
	}
}
`
		assert.Equal(t, expectedFormatted, string(content))
	})
}
