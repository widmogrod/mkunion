package main

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSaveFile_FormatsGeneratedGoCode(t *testing.T) {
	// Create a temporary directory for test files
	tempDir := t.TempDir()
	sourcePath := filepath.Join(tempDir, "test.go")

	// Test case 1: Unformatted Go code should be formatted
	t.Run("formats_unformatted_go_code", func(t *testing.T) {
		// Unformatted Go code
		unformattedCode := `package test

import "fmt"

func   main()  {
fmt.Println("Hello, World!")
		if   true   {
	fmt.Println("This is unformatted")
}
}`

		buffer := bytes.Buffer{}
		buffer.WriteString(unformattedCode)

		fileName, err := SaveFile(buffer, sourcePath, "formatted")
		require.NoError(t, err)
		require.NotEmpty(t, fileName)

		// Read the saved file
		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		// The saved content should be formatted
		expectedFormatted := `package test

import "fmt"

func main() {
	fmt.Println("Hello, World!")
	if true {
		fmt.Println("This is unformatted")
	}
}
`
		assert.Equal(t, expectedFormatted, string(content))
	})

	// Test case 2: Already formatted code should remain the same
	t.Run("preserves_already_formatted_code", func(t *testing.T) {
		formattedCode := `package test

import "fmt"

func main() {
	fmt.Println("Hello, World!")
}
`

		buffer := bytes.Buffer{}
		buffer.WriteString(formattedCode)

		fileName, err := SaveFile(buffer, sourcePath, "already_formatted")
		require.NoError(t, err)

		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		assert.Equal(t, formattedCode, string(content))
	})

	// Test case 3: Invalid Go code should still be saved (graceful fallback)
	t.Run("saves_invalid_go_code_without_formatting", func(t *testing.T) {
		invalidCode := `package test

func main() {
	// Missing closing brace
`

		buffer := bytes.Buffer{}
		buffer.WriteString(invalidCode)

		fileName, err := SaveFile(buffer, sourcePath, "invalid")
		require.NoError(t, err)

		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		// Invalid code should be saved as-is
		assert.Equal(t, invalidCode, string(content))
	})

	// Test case 4: Empty buffer should not create a file
	t.Run("empty_buffer_returns_empty_filename", func(t *testing.T) {
		buffer := bytes.Buffer{}

		fileName, err := SaveFile(buffer, sourcePath, "empty")
		require.NoError(t, err)
		assert.Empty(t, fileName)

		// Verify no file was created
		expectedPath := strings.Replace(sourcePath, ".go", "_empty.go", 1)
		_, err = os.Stat(expectedPath)
		assert.True(t, os.IsNotExist(err))
	})

	// Test case 5: Complex generated code with imports
	t.Run("formats_complex_generated_code", func(t *testing.T) {
		complexCode := `// Code generated by mkunion. DO NOT EDIT.
package example

import (
"fmt"
	"github.com/widmogrod/mkunion/x/shared"
"context"
)

type   Vehicle   interface {
isVehicle()
}

type  Car  struct{
Brand  string
Model string
}

func  (c *Car)  isVehicle() {}

func   MatchVehicleR1[T any](x Vehicle,
f1   func(x *Car)   T,
)   T   {
switch v   :=  x.(type)  {
case   *Car:
return   f1(v)
default:
panic("unreachable")
}
}`

		buffer := bytes.Buffer{}
		buffer.WriteString(complexCode)

		fileName, err := SaveFile(buffer, sourcePath, "complex")
		require.NoError(t, err)

		content, err := os.ReadFile(fileName)
		require.NoError(t, err)

		// Should be properly formatted
		expectedFormatted := `// Code generated by mkunion. DO NOT EDIT.
package example

import (
	"context"
	"fmt"
	"github.com/widmogrod/mkunion/x/shared"
)

type Vehicle interface {
	isVehicle()
}

type Car struct {
	Brand string
	Model string
}

func (c *Car) isVehicle() {}

func MatchVehicleR1[T any](x Vehicle,
	f1 func(x *Car) T,
) T {
	switch v := x.(type) {
	case *Car:
		return f1(v)
	default:
		panic("unreachable")
	}
}
`
		assert.Equal(t, expectedFormatted, string(content))
	})
}

func TestRunGoGenerate(t *testing.T) {
	t.Run("executes_go_generate_successfully", func(t *testing.T) {
		// Create temporary directory
		tempDir := t.TempDir()

		// Create go.mod file
		goMod := filepath.Join(tempDir, "go.mod")
		modContent := `module test

go 1.21
`
		err := os.WriteFile(goMod, []byte(modContent), 0644)
		require.NoError(t, err)

		// Create a simple Go file with generate directive
		goFile := filepath.Join(tempDir, "test.go")
		content := `package test

//go:generate touch generated.txt
`
		err = os.WriteFile(goFile, []byte(content), 0644)
		require.NoError(t, err)

		// Test the function
		err = runGoGenerate([]string{tempDir})
		require.NoError(t, err)

		// Verify that go generate was executed
		generatedFile := filepath.Join(tempDir, "generated.txt")
		_, err = os.Stat(generatedFile)
		assert.NoError(t, err, "generated file should exist")
	})

	t.Run("handles_multiple_directories", func(t *testing.T) {
		// Create multiple temporary directories
		tempDir1 := t.TempDir()
		tempDir2 := t.TempDir()

		// Create Go files in both directories
		for i, dir := range []string{tempDir1, tempDir2} {
			// Create go.mod file
			goMod := filepath.Join(dir, "go.mod")
			modContent := `module test` + string(rune('1'+i)) + `

go 1.21
`
			err := os.WriteFile(goMod, []byte(modContent), 0644)
			require.NoError(t, err)

			goFile := filepath.Join(dir, "test.go")
			content := `package test

//go:generate touch generated.txt
`
			err = os.WriteFile(goFile, []byte(content), 0644)
			require.NoError(t, err)
		}

		// Test the function with multiple directories
		err := runGoGenerate([]string{tempDir1, tempDir2})
		require.NoError(t, err)

		// Verify that go generate was executed in both directories
		for _, dir := range []string{tempDir1, tempDir2} {
			generatedFile := filepath.Join(dir, "generated.txt")
			_, err = os.Stat(generatedFile)
			assert.NoError(t, err, "generated file should exist in %s", dir)
		}
	})

	t.Run("continues_on_failure_in_one_directory", func(t *testing.T) {
		// Create multiple temporary directories
		tempDir1 := t.TempDir()
		tempDir2 := t.TempDir()

		// First directory with valid command
		goMod1 := filepath.Join(tempDir1, "go.mod")
		modContent1 := `module test1

go 1.21
`
		err := os.WriteFile(goMod1, []byte(modContent1), 0644)
		require.NoError(t, err)

		goFile1 := filepath.Join(tempDir1, "test.go")
		content1 := `package test

//go:generate touch generated.txt
`
		err = os.WriteFile(goFile1, []byte(content1), 0644)
		require.NoError(t, err)

		// Second directory with invalid command
		goMod2 := filepath.Join(tempDir2, "go.mod")
		modContent2 := `module test2

go 1.21
`
		err = os.WriteFile(goMod2, []byte(modContent2), 0644)
		require.NoError(t, err)

		goFile2 := filepath.Join(tempDir2, "test.go")
		// Using string concatenation to prevent go generate from picking this up
		content2 := "package test\n\n" +
			"//go" + ":generate invalid-command-that-does-not-exist\n"
		err = os.WriteFile(goFile2, []byte(content2), 0644)
		require.NoError(t, err)

		// Test the function with multiple directories - should return error but continue processing
		err = runGoGenerate([]string{tempDir1, tempDir2})
		assert.Error(t, err, "should return error when one directory fails")

		// Verify that go generate was still executed in the first directory
		generatedFile := filepath.Join(tempDir1, "generated.txt")
		_, err = os.Stat(generatedFile)
		assert.NoError(t, err, "generated file should exist in first directory despite second directory failure")
	})

	t.Run("returns_error_on_go_generate_failure", func(t *testing.T) {
		// Create temporary directory
		tempDir := t.TempDir()

		// Create go.mod file
		goMod := filepath.Join(tempDir, "go.mod")
		modContent := `module test

go 1.21
`
		err := os.WriteFile(goMod, []byte(modContent), 0644)
		require.NoError(t, err)

		// Create a Go file with invalid generate directive
		goFile := filepath.Join(tempDir, "test.go")
		// Note: Using a comment prefix to prevent go generate from picking this up in the test file itself
		content := "package test\n\n" +
			"//go" + ":generate invalid-command-that-does-not-exist\n"
		err = os.WriteFile(goFile, []byte(content), 0644)
		require.NoError(t, err)

		// Test the function - should return error
		err = runGoGenerate([]string{tempDir})
		assert.Error(t, err, "should return error for invalid command")
	})

	t.Run("handles_empty_directory_list", func(t *testing.T) {
		// Test with empty directory list
		err := runGoGenerate([]string{})
		assert.NoError(t, err, "should handle empty directory list gracefully")
	})

	t.Run("handles_nil_directory_list", func(t *testing.T) {
		// Test with nil directory list
		err := runGoGenerate(nil)
		assert.NoError(t, err, "should handle nil directory list gracefully")
	})

	t.Run("skips_directories_without_generate_directives", func(t *testing.T) {
		// Create temporary directory without go:generate
		tempDir := t.TempDir()

		// Create go.mod file
		goMod := filepath.Join(tempDir, "go.mod")
		modContent := `module test

go 1.21
`
		err := os.WriteFile(goMod, []byte(modContent), 0644)
		require.NoError(t, err)

		// Create a Go file WITHOUT generate directive
		goFile := filepath.Join(tempDir, "test.go")
		content := `package test

func main() {
	// No generate directive here
}
`
		err = os.WriteFile(goFile, []byte(content), 0644)
		require.NoError(t, err)

		// Test the function - should not run go generate
		err = runGoGenerate([]string{tempDir})
		assert.NoError(t, err, "should skip directories without generate directives")
	})
}

func TestWatchCommandWithGoGenerate(t *testing.T) {
	// This test would require a more complex setup to test the integration
	// of the --dont-run-go-generate flag with the watch command.
	// For now, we'll focus on unit testing the runGoGenerate function.
	t.Skip("Integration test for watch command with go generate")
}

func TestCleanGeneratedFiles(t *testing.T) {
	t.Run("removes_generated_files_with_correct_patterns", func(t *testing.T) {
		// Create temporary directory
		tempDir := t.TempDir()

		// Create various generated files
		generatedFiles := []string{
			"test_union_gen.go",
			"test_shape_gen.go",
			"test_serde_gen.go",
			"test_match_gen.go",
			"types_reg_gen.go",
		}

		// Create non-generated files that should not be removed
		nonGeneratedFiles := []string{
			"test.go",
			"test_test.go",
			"helper.go",
			"types.go",
		}

		// Write all files
		allFiles := append(generatedFiles, nonGeneratedFiles...)
		for _, fileName := range allFiles {
			filePath := filepath.Join(tempDir, fileName)
			err := os.WriteFile(filePath, []byte("package test"), 0644)
			require.NoError(t, err)
		}

		// Test clean without dry-run
		removedFiles, err := CleanGeneratedFiles([]string{tempDir}, false)
		require.NoError(t, err)

		// Verify correct files were removed
		assert.Len(t, removedFiles, len(generatedFiles))
		for _, expectedFile := range generatedFiles {
			found := false
			for _, removedFile := range removedFiles {
				if filepath.Base(removedFile) == expectedFile {
					found = true
					break
				}
			}
			assert.True(t, found, "Expected %s to be removed", expectedFile)
		}

		// Verify generated files no longer exist
		for _, fileName := range generatedFiles {
			filePath := filepath.Join(tempDir, fileName)
			_, err := os.Stat(filePath)
			assert.True(t, os.IsNotExist(err), "Generated file %s should be removed", fileName)
		}

		// Verify non-generated files still exist
		for _, fileName := range nonGeneratedFiles {
			filePath := filepath.Join(tempDir, fileName)
			_, err := os.Stat(filePath)
			assert.NoError(t, err, "Non-generated file %s should not be removed", fileName)
		}
	})

	t.Run("dry_run_does_not_remove_files", func(t *testing.T) {
		tempDir := t.TempDir()

		// Create generated files
		generatedFiles := []string{
			"test_union_gen.go",
			"types_reg_gen.go",
		}

		for _, fileName := range generatedFiles {
			filePath := filepath.Join(tempDir, fileName)
			err := os.WriteFile(filePath, []byte("package test"), 0644)
			require.NoError(t, err)
		}

		// Test dry-run
		removedFiles, err := CleanGeneratedFiles([]string{tempDir}, true)
		require.NoError(t, err)

		// Verify files would be removed but still exist
		assert.Len(t, removedFiles, len(generatedFiles))
		for _, fileName := range generatedFiles {
			filePath := filepath.Join(tempDir, fileName)
			_, err := os.Stat(filePath)
			assert.NoError(t, err, "File %s should still exist in dry-run", fileName)
		}
	})

	t.Run("handles_recursive_directories", func(t *testing.T) {
		tempDir := t.TempDir()

		// Create subdirectories
		subDir1 := filepath.Join(tempDir, "sub1")
		subDir2 := filepath.Join(tempDir, "sub2")
		err := os.MkdirAll(subDir1, 0755)
		require.NoError(t, err)
		err = os.MkdirAll(subDir2, 0755)
		require.NoError(t, err)

		// Create generated files in different directories
		files := map[string]string{
			filepath.Join(tempDir, "root_union_gen.go"): "package test",
			filepath.Join(subDir1, "sub1_shape_gen.go"): "package sub1",
			filepath.Join(subDir2, "sub2_serde_gen.go"): "package sub2",
			filepath.Join(subDir2, "types_reg_gen.go"):  "package sub2",
		}

		for filePath, content := range files {
			err := os.WriteFile(filePath, []byte(content), 0644)
			require.NoError(t, err)
		}

		// Test clean
		removedFiles, err := CleanGeneratedFiles([]string{tempDir}, false)
		require.NoError(t, err)

		// Should find all generated files recursively
		assert.Len(t, removedFiles, len(files))

		// Verify all files are removed
		for filePath := range files {
			_, err := os.Stat(filePath)
			assert.True(t, os.IsNotExist(err), "File %s should be removed", filePath)
		}
	})

	t.Run("handles_multiple_directories", func(t *testing.T) {
		tempDir1 := t.TempDir()
		tempDir2 := t.TempDir()

		// Create generated files in both directories
		files1 := []string{"test1_union_gen.go", "types_reg_gen.go"}
		files2 := []string{"test2_shape_gen.go"}

		for _, fileName := range files1 {
			filePath := filepath.Join(tempDir1, fileName)
			err := os.WriteFile(filePath, []byte("package test1"), 0644)
			require.NoError(t, err)
		}

		for _, fileName := range files2 {
			filePath := filepath.Join(tempDir2, fileName)
			err := os.WriteFile(filePath, []byte("package test2"), 0644)
			require.NoError(t, err)
		}

		// Test clean with multiple directories
		removedFiles, err := CleanGeneratedFiles([]string{tempDir1, tempDir2}, false)
		require.NoError(t, err)

		// Should remove files from both directories
		totalExpected := len(files1) + len(files2)
		assert.Len(t, removedFiles, totalExpected)
	})

	t.Run("handles_empty_directory", func(t *testing.T) {
		tempDir := t.TempDir()

		// Test clean on empty directory
		removedFiles, err := CleanGeneratedFiles([]string{tempDir}, false)
		require.NoError(t, err)
		assert.Len(t, removedFiles, 0)
	})

	t.Run("handles_nonexistent_directory", func(t *testing.T) {
		nonExistentDir := "/path/that/does/not/exist"

		// Should return error for non-existent directory
		_, err := CleanGeneratedFiles([]string{nonExistentDir}, false)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to find generated files")
	})

	t.Run("deduplicates_files_from_overlapping_directories", func(t *testing.T) {
		tempDir := t.TempDir()
		subDir := filepath.Join(tempDir, "sub")
		err := os.MkdirAll(subDir, 0755)
		require.NoError(t, err)

		// Create a generated file in subdirectory
		filePath := filepath.Join(subDir, "test_union_gen.go")
		err = os.WriteFile(filePath, []byte("package test"), 0644)
		require.NoError(t, err)

		// Test with both parent and child directory
		removedFiles, err := CleanGeneratedFiles([]string{tempDir, subDir}, false)
		require.NoError(t, err)

		// Should only remove the file once (deduplicated)
		assert.Len(t, removedFiles, 1)
		assert.Equal(t, filePath, removedFiles[0])
	})
}

func TestIsGeneratedFile(t *testing.T) {
	tests := []struct {
		fileName string
		expected bool
	}{
		// Generated files
		{"test_union_gen.go", true},
		{"test_shape_gen.go", true},
		{"test_serde_gen.go", true},
		{"test_match_gen.go", true},
		{"types_reg_gen.go", true},

		// Non-generated files
		{"test.go", false},
		{"test_test.go", false},
		{"helper.go", false},
		{"types.go", false},
		{"main.go", false},
		{"gen.go", false},
		{"_gen.go", false},
		{"test_gen.go", false},   // Missing specific suffix
		{"test_union.go", false}, // Missing _gen suffix

		// Edge cases
		{"", false},
		{"a_union_gen.go", true},
		{"very_long_filename_union_gen.go", true},
	}

	for _, tt := range tests {
		t.Run(tt.fileName, func(t *testing.T) {
			// Create a temporary file path for testing
			tempDir := t.TempDir()
			fullPath := filepath.Join(tempDir, tt.fileName)

			result := isGeneratedFile(fullPath)
			assert.Equal(t, tt.expected, result, "isGeneratedFile(%q) = %v, want %v", tt.fileName, result, tt.expected)
		})
	}
}

func TestFindGeneratedFiles(t *testing.T) {
	t.Run("finds_all_generated_files", func(t *testing.T) {
		tempDir := t.TempDir()

		// Create mix of generated and non-generated files
		files := map[string]bool{
			"test_union_gen.go": true,  // generated
			"test_shape_gen.go": true,  // generated
			"types_reg_gen.go":  true,  // generated
			"test.go":           false, // not generated
			"helper.go":         false, // not generated
			"README.md":         false, // not a go file
		}

		for fileName := range files {
			filePath := filepath.Join(tempDir, fileName)
			err := os.WriteFile(filePath, []byte("content"), 0644)
			require.NoError(t, err)
		}

		generatedFiles, err := findGeneratedFiles(tempDir)
		require.NoError(t, err)

		// Count expected generated files
		expectedCount := 0
		for _, isGenerated := range files {
			if isGenerated {
				expectedCount++
			}
		}

		assert.Len(t, generatedFiles, expectedCount)

		// Verify all found files are actually generated
		for _, filePath := range generatedFiles {
			fileName := filepath.Base(filePath)
			assert.True(t, files[fileName], "File %s should be marked as generated", fileName)
		}
	})

	t.Run("handles_subdirectories", func(t *testing.T) {
		tempDir := t.TempDir()
		subDir := filepath.Join(tempDir, "subdir")
		err := os.MkdirAll(subDir, 0755)
		require.NoError(t, err)

		// Create generated files in both root and subdirectory
		rootFile := filepath.Join(tempDir, "root_union_gen.go")
		subFile := filepath.Join(subDir, "sub_shape_gen.go")

		err = os.WriteFile(rootFile, []byte("package root"), 0644)
		require.NoError(t, err)
		err = os.WriteFile(subFile, []byte("package sub"), 0644)
		require.NoError(t, err)

		generatedFiles, err := findGeneratedFiles(tempDir)
		require.NoError(t, err)

		assert.Len(t, generatedFiles, 2)
		assert.Contains(t, generatedFiles, rootFile)
		assert.Contains(t, generatedFiles, subFile)
	})

	t.Run("skips_hidden_directories", func(t *testing.T) {
		tempDir := t.TempDir()
		hiddenDir := filepath.Join(tempDir, ".hidden")
		err := os.MkdirAll(hiddenDir, 0755)
		require.NoError(t, err)

		// Create generated file in hidden directory
		hiddenFile := filepath.Join(hiddenDir, "hidden_union_gen.go")
		err = os.WriteFile(hiddenFile, []byte("package hidden"), 0644)
		require.NoError(t, err)

		// Create generated file in visible directory
		visibleFile := filepath.Join(tempDir, "visible_union_gen.go")
		err = os.WriteFile(visibleFile, []byte("package visible"), 0644)
		require.NoError(t, err)

		generatedFiles, err := findGeneratedFiles(tempDir)
		require.NoError(t, err)

		// Should only find the visible file
		assert.Len(t, generatedFiles, 1)
		assert.Contains(t, generatedFiles, visibleFile)
		assert.NotContains(t, generatedFiles, hiddenFile)
	})
}
