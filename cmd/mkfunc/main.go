package main

import (
	"context"
	"github.com/urfave/cli/v2"
	"github.com/widmogrod/mkunion"
	"github.com/widmogrod/mkunion/x/shape"
	"log"
	"os"
	"os/signal"
	"path"
	"syscall"
)

func main() {
	ctx, _ := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)

	var app *cli.App
	app = &cli.App{
		Name:                   "mkfunc",
		Description:            "mkfunc is a tool for generating function signatures",
		EnableBashCompletion:   true,
		DefaultCommand:         "golang",
		UseShortOptionHandling: true,
		Flags: []cli.Flag{
			&cli.IntFlag{
				Name:     "max-size",
				Required: true,
			},
		},
		Action: func(c *cli.Context) error {
			cwd, _ := syscall.Getwd()
			sourceName := path.Base(os.Getenv("GOFILE"))
			sourcePath := path.Join(cwd, sourceName)

			// file name without extension
			inferred, err := shape.InferFromFile(sourcePath)
			if err != nil {
				return err
			}

			match := mkunion.FunctionMatchGenerator{
				Header:      "// Code generated by mkfunc. DO NOT EDIT.",
				PackageName: inferred.PackageName,
				MaxSize:     c.Int("max-size"),
			}

			generators := []struct {
				gen  mkunion.Generator
				name string
			}{
				{gen: &match, name: "match"},
			}
			for _, g := range generators {
				b, err := g.gen.Generate()
				if err != nil {
					return err
				}
				err = os.WriteFile(path.Join(cwd,
					"mkfunc_"+g.name+".go"), b, 0644)
				if err != nil {
					return err
				}
			}

			return nil
		},
	}

	err := app.RunContext(ctx, os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
